//=========================================================================
//
//  PS2_Engine.CPP
//
//=========================================================================

////////////////////////////////////////////////////////////////////////////
// To enable SN Systems profiler, define ENABLE_SN_PROFILER for this file.
// Just PLEASE remember to un-define it when you're done!
////////////////////////////////////////////////////////////////////////////

//#define ENABLE_SN_PROFILER 1

#ifdef TARGET_PS2_DVD
	//#define   EXCEPTION_CONTEXT_DUMP
#endif

#include <stdlib.h>
#include <eekernel.h>
#include <eeregs.h>
#include <math.h>
#include <libdma.h>
#include <libmc.h>
#include <libcdvd.h>
#include <libgraph.h>
#include <libsn.h>
#include <sifdev.h>
#include <sif.h>
#include <libvu0.h>
#include <stdio.h>
#include <sifrpc.h>

#ifdef EXCEPTION_CONTEXT_DUMP
#include <libexcep.h>
#include <libpkt.h>
#endif

#include "x_files.hpp"
#include "x_debug.hpp"
#include "x_time.hpp"
#include "x_plus.hpp"
#include "x_bitmap.hpp"
#include "x_stdio.hpp"
#include "x_stats.hpp"

#include "Q_Engine.hpp"
#include "Q_PS2.hpp"
#include "Q_SMem.hpp"
#include "Q_View.hpp"
#include "Q_Draw.hpp"
#include "E_SMem.hpp"
#include "E_AccumTimer.hpp"
#include "E_Text.hpp"
#include "Q_FileReadQueue.h"

#include "PS2_Input.hpp"
#include "PS2_Font.hpp"
#include "PS2_MemoryUnit.hpp"
#include "PS2_Debug.hpp"

#include "PS2_Dev.hpp"
#include "PS2_CD.hpp"
#include "PS2_usb.hpp"

#include "vifhelp.hpp"
#include "dmahelp.hpp"
#include "dmaman.hpp"
#include "dvtrace.hpp"
#include "sprhelp.hpp"
#include "Framebuf.hpp"
#include "PS2Perf.h"

#ifdef __MWERKS__
    #include "mwUtils.h"
#endif

#ifdef EXCEPTION_CONTEXT_DUMP
static char    FinalPanicIrx[255];
#endif

color eng_fog_color(0,0,0,0);
eng_fog g_EngineFog={0,0,0,0};

xbool s_bDoFog = FALSE;
s32 s_SpecialCaseFog = 0;
static s32 s_OddFrame = 0;

//=========================================================================
// DEFINES
//=========================================================================

static s32 s_ScissorTop = ((2048-kDisplayHeight/2) << 4);
static s32 s_ScissorLeft = ((2048-kDisplayWidth/2) << 4);

static s32 s_WindowLeft = (2048-(kDisplayWidth/2));
static s32 s_WindowTop = (2048-(kDisplayHeight/2));

static const s32 MIN_DLIST_SIZE = (32*1024);
static const s32 MIN_SMEM_SIZE  =  (MIN_DLIST_SIZE+(32*1024));

static const s32 PATH_VIF1 = 0;
static const s32 PATH_GIF  = 1;

static xbool s_bUseNonBlockingVSync             = FALSE;
static xbool s_bIsProgressive		            = FALSE;
static xbool s_bScreenConversionOverride        = FALSE;
static xbool s_bGraphicsCheatActive             = FALSE;
static xbool s_bIsGame_graphicsave              = FALSE;
static xbool s_bIsProgressive_graphicsave       = FALSE;
static xbool s_bIsPAL_graphicsave               = FALSE;
static xbool s_bGraphicsCheatActive_graphicsave = FALSE;

//=========================================================================
// STRUCTS
//=========================================================================

typedef struct
{
    sceDmaTag   DMA;
    s32         VIF[4];
    sceGifTag   GIF;
    u64         AD[12];
} engtest_header;

typedef struct
{
    s32         VIF[4];
    sceGifTag   GIF;
    u64         AD[2];
} engblend_header;

struct ps2_screenfill_sprite_packet
{
    u32         VIF[ 4 ];
    sceGifTag   GIFTag;
    u64         GSCmds[ 54 ];
};


static const s32 knBlendEnv = 81;
static engblend_header s_BlendEnv[ knBlendEnv ];

//=========================================================================
// TYPES
//=========================================================================

enum
{
    PS2_ALPHA_ZERO=0,   // 0
    PS2_ALPHA_CS,       // SrcColor
    PS2_ALPHA_CD,       // DstColor
    PS2_ALPHA_AS,       // SrcAlpha
    PS2_ALPHA_AD,       // DestAlpha
    PS2_ALPHA_FIX       // Fixed value
};

//=========================================================================
// VARIABLES
//=========================================================================

static xbool        s_EngActivated = FALSE;
static s32          s_XRes;
static s32          s_YRes;
static f32          s_fXConversion;
static f32          s_fYConversion;
static view         s_View;
static s32          s_2DClipL = 0;
static s32          s_2DClipT = 0;
static s32          s_2DClipR = (ENG_GetScreenWidth()-1);
static s32          s_2DClipB = (ENG_GetScreenHeight()-1);
static xbool        s_2DClipDirty = FALSE;
static xbool        s_InsideRenderMode;
static f64          s_StartRunTime;
static accum_timer  s_FPSTimer;
static accum_timer  s_CPUTimer;
static accum_timer  s_GSTimer;
static s32          s_RequestedDListSize;
static s32          s_DListSize = -1;
static s32          s_SMemSize  = -1;

// Display list memory
static s32          s_DListSizeUsed;
static byte*        s_DListTaskStart;
static byte*        s_DList;
       byte*        pDList;

PSTAT( StatDListAvailable );
PSTAT( StatDListUsed  );

static s32          s_Frame; 
static xbool        s_ClearScreen = TRUE;
static s32          s_OddEven;

fsAABuff aaBuff;
fsAABuff *pAAbuff;
gsDrawDecalSprite shrinkSprite __attribute__ ((aligned(16)));
gsDrawDecalSprite *pShrinkSprite __attribute__ ((aligned(16)));

static sceDmaChan*  s_DMA1;

static matrix4      s_MWorldToScreen;
static matrix4      s_MWorldToView;
static matrix4      s_MWorldToClip;
static matrix4      s_MClipToScreen;

static lighting     s_ActiveLighting[ ENG_LIGHTING_MAX_LEVELS ];
static matrix4      s_LightingDir[ ENG_LIGHTING_MAX_LEVELS ];
static matrix4      s_LightingColor[ ENG_LIGHTING_MAX_LEVELS ];

static xbool        s_AAToggle;

static s32          s_AlphaBlendA   = 0x2;
static s32          s_AlphaBlendB   = 0x2;
static s32          s_AlphaBlendC   = 0x2;
static s32          s_AlphaBlendD   = 0x00;
static s32          s_AlphaBlendFix = 0x00;
static xbool        s_DestAlphaTest = FALSE;
static s32          s_DestAlphaMode = 0x1;
static u32          s_RenderFlags   = ENG_ZBUFFER_TEST_ON |
                                      ENG_ZBUFFER_FILL_ON |
                                      ENG_ALPHA_TEST_OFF  |
                                      ENG_ALPHA_BLEND_OFF;
static u32          s_BlendFlags    = ENG_BLEND_NORMAL;
static xbool        s_FBA = FALSE;


//==========================================================================
// FUNCTION PROTOTYPES
//==========================================================================

void PS2_ResetToDefaultStates();
void PS2_ClearScreen( color C, xbool bClearDisplay = FALSE );
void PS2_SetAlphaEnv( u32 RenderFlags );
void PS2_SetAlphaBlending( s32 A, s32 B, s32 C, s32 D, u8 FIX = 0 );
extern void PS2_CDUtilInit();
extern void PS2_CDUtilKill( void );


//=========================================================================
// FUNCTIONS
//=========================================================================

#ifdef PS2_DLIST_DEBUGGING

static byte*        s_pDListForCheckSum = NULL;
static s32          s_DListSizeForCheckSum = 0;
static u32          s_DListCheckSum = 0;


//=========================================================================
u32 DListCheckSum( byte* pD, s32 Size )
{
    u32*    pData = (u32*)pD;
    s32     i;
    u32     Total = 0;

    ASSERT( ((u32)pD & 0x3) == 0 );
    ASSERT( (Size & 0x3) == 0 );

    for ( i = 0; i < (Size >> 2); ++i )
    {
        Total += *pData;
        pData++;
    }

    return Total;
}

void PS2_DListVerify( const char* Filename, s32 LineNumber )
{
    if ( s_pDListForCheckSum == NULL )
        return;

    if ( DListCheckSum( s_pDListForCheckSum, s_DListSizeForCheckSum ) != s_DListCheckSum )
    {
        x_printf( "*** CORRUPT DISPLAY LIST ***\n" );
        x_printf( "File: %32s\n", Filename );
        x_printf( "Line: %d\n", LineNumber );

#ifdef X_DEBUG
        //---   debug mode, just assert
        ASSERTS( FALSE, "Corrupt display list" );
#else
        //---   force a divide-by-zero so we can get to the exception-handler screen,
        //      or cause the program to generally break.
        s_DListCheckSum = s_DListCheckSum / 0;
#endif
    }
}

#endif

//==========================================================================

int VSync_HandleID;
volatile int VSync_SemaID;
 
static int VBlankStartHandler(int ch)
{
    struct SemaParam sp;
    iReferSemaStatus( VSync_SemaID, &sp );
    if( sp.currentCount == 0 )
        iSignalSema(VSync_SemaID);
    ExitHandler();
    return -1;
}

//=========================================================================

void PS2_WaitVSync( void )
{
    if (s_bUseNonBlockingVSync)
    {
        WaitSema(VSync_SemaID);
        s_OddFrame = 1 - s_OddFrame;
        s_bDoFog = FALSE;
    }
    else
    {
        sceGsSyncV(0);
        s_OddFrame = !s_OddFrame;
    }
}

//==========================================================================

void PS2_ScreenShot_16bit( const char* pFilename )
{
    /////////////////////////////////////////////////////////////////
    // LOCAL STRUCTURES
    /////////////////////////////////////////////////////////////////
    struct SBMPHeader
    {
        s16 headerAlignment;        //for proper strut alignment

        s16 bfType;                 //ascii "BM"
        s32 bfSize;                 //size of file
        s16 bfRsrv1;                //reserved 1- zeroes
        s16 bfRsrv2;                //reserved 2- zeroes
        s32 bfOffbits;              //byte offset to pixel data
        s32 biSize;                 //size of header
        s32 biWidth;                //width of BMP
        s32 biHeight;               //height of BMP
        s16 biPlanes;               //# of color planes
        s16 biBitCount;             //color resolution(1, 4, 8, 24)
        s32 biCompression;          //compressoin type(encoding)
        s32 biSizeImage;            //size of compressed image
        s32 biXPelsPerM;            //horiz. resolution(pix per meter)
        s32 biYPelsPerM;            //vert. resolution(pix per meter)
        s32 biColorUsed;            //# of colors used
        s32 biClrImportant;         //# of "important colors
    };

    struct SBGR { u8 B, G, R; };    //BMP data format
    struct SRGBA16
    {
        u16 R:5,
            G:5,
            B:5,
            A:1;
    };

    /////////////////////////////////////////////////////////////////

    const s32 WIDTH     = aaBuff.dispW;
    const s32 HEIGHT    = aaBuff.dispH;

    static s32 sShotCount = 0;

    SRGBA16 FBImage[WIDTH * HEIGHT] __attribute__((aligned(16)));

    // Get the frame buffer image from the GS
    {   
        x_printf( "\nCapturing screen image...\n" );

        sceGsStoreImage sp;

        while( !DMAMAN_AreTasksFinished() ) {} //intentionally left empty

        DMAMAN_HandlersOff();
        if (aaBuff.dispPSM == SCE_GS_PSMCT16)
            sceGsSetDefStoreImage( &sp, 0, WIDTH/64, SCE_GS_PSMCT16, 0, 0, WIDTH, HEIGHT );
        else
            sceGsSetDefStoreImage( &sp, 0, WIDTH/64, SCE_GS_PSMCT16S, 0, 0, WIDTH, HEIGHT );
        FlushCache( 0 );
        sceGsExecStoreImage( &sp, (u_long128 *)FBImage );
        sceGsSyncPath( 0, 0 );
        DMAMAN_HandlersOn();
        DMAMAN_ExecuteTasks();
    }

    X_FILE* pFile;

    // Make filename
    {   
        char fname[128];

        if( pFilename == NULL )
            x_sprintf( fname, "ScreenShot%d.bmp", sShotCount++ );
        else
            x_sprintf( fname, "%s%d.bmp", pFilename, sShotCount++ );

        x_printf( "Screen shot obtained, saving to file \"%s\"...\n", fname );
        pFile = x_fopen( fname, "wb" );
        ASSERT( pFile != NULL );
    }

    const s32 BMP_HEADER_SIZE       = sizeof(SBMPHeader) - sizeof(s16);
    const s32 BMP_INFO_HEADER_SIZE  = BMP_HEADER_SIZE - sizeof(s16)*3 - sizeof(s32)*2;
    const s32 BMP_PADDING           = (4 - ( (WIDTH * sizeof(SBGR) ) & 0x03)) & 0x03;
    const s32 BMP_PHYSICAL_WIDTH    = WIDTH * sizeof(SBGR) + BMP_PADDING;

    // Setup BMP file header
    {   
        SBMPHeader bmHeader;

        bmHeader.bfType         = 'B' | ('M' << 8);
        bmHeader.bfSize         = BMP_HEADER_SIZE + (BMP_PHYSICAL_WIDTH * HEIGHT);
        bmHeader.bfRsrv1        = 0;
        bmHeader.bfRsrv2        = 0;
        bmHeader.bfOffbits      = BMP_HEADER_SIZE;
        bmHeader.biSize         = BMP_INFO_HEADER_SIZE;
        bmHeader.biWidth        = WIDTH;
        bmHeader.biHeight       = HEIGHT;
        bmHeader.biPlanes       = 1;
        bmHeader.biBitCount     = 24;
        bmHeader.biCompression  = 0;
        bmHeader.biSizeImage    = 0;    //BMP_PHYSICAL_WIDTH * HEIGHT;
        bmHeader.biXPelsPerM    = 2834; //28.34 pels/cm or 72 pels/inch
        bmHeader.biYPelsPerM    = 2834; //28.34 pels/cm or 72 pels/inch
        bmHeader.biColorUsed    = 0;
        bmHeader.biClrImportant = 0;

        x_fwrite( &(bmHeader.bfType), BMP_HEADER_SIZE, 1, pFile );
    }

    const s32 IMAGE_LINE_OFFSET = 1;

    // Convert frame buffer image to BMP format and write to file
    byte    TwoLineData[ 2 * BMP_PHYSICAL_WIDTH ];

    SBGR    *BMPLineOne = (SBGR*)TwoLineData;
    SBGR    *BMPLineTwo = (SBGR*)(TwoLineData + BMP_PHYSICAL_WIDTH);
    SRGBA16 *ImageData;
    s32     CurPixel;
    s32     CurBMPLine;

    // BMP format starts from last scan line of image and moves toward first
    CurBMPLine = HEIGHT - 1;
    while( CurBMPLine >= 0 )
    {
        // Convert scanline to BMP format
        CurPixel = 0;
        ImageData = FBImage + (CurBMPLine * WIDTH);
        while( CurPixel < WIDTH )
        {
            BMPLineOne[CurPixel].B = (u8)MIN(255.0f, ((f32)ImageData->B * 8.0f));
            BMPLineOne[CurPixel].G = (u8)MIN(255.0f, ((f32)ImageData->G * 8.0f));
            BMPLineOne[CurPixel].R = (u8)MIN(255.0f, ((f32)ImageData->R * 8.0f));
            CurPixel++;
            ImageData++;
        }

        // Convert next scanline to BMP format
        CurPixel = 0;
        ImageData = FBImage + ((CurBMPLine - IMAGE_LINE_OFFSET) * WIDTH);
        while( CurPixel < WIDTH )
        {
            BMPLineTwo[CurPixel].B = (u8)MIN(255.0f, ((f32)ImageData->B * 8.0f));
            BMPLineTwo[CurPixel].G = (u8)MIN(255.0f, ((f32)ImageData->G * 8.0f));
            BMPLineTwo[CurPixel].R = (u8)MIN(255.0f, ((f32)ImageData->R * 8.0f));
            CurPixel++;
            ImageData++;
        }

        // Note that HEIGHT MUST be a multiple of 2 for this loop to execute properly
        CurBMPLine -= 2;

        x_fwrite( TwoLineData, 2 * BMP_PHYSICAL_WIDTH, 1, pFile );
    }

    x_fclose( pFile );
    pFile = NULL;

    x_printf( "Screen shot capture finished.\n" );
}

//==========================================================================

void PS2_ScreenShot( const char* pFilename )
{
    if (aaBuff.dispPSM == SCE_GS_PSMCT16 || aaBuff.dispPSM == SCE_GS_PSMCT16S)
    {
        PS2_ScreenShot_16bit( pFilename );
        return;
    }
    /////////////////////////////////////////////////////////////////
    // LOCAL STRUCTURES
    /////////////////////////////////////////////////////////////////
    struct SBMPHeader
    {
        s16 headerAlignment;        //for proper strut alignment

        s16 bfType;                 //ascii "BM"
        s32 bfSize;                 //size of file
        s16 bfRsrv1;                //reserved 1- zeroes
        s16 bfRsrv2;                //reserved 2- zeroes
        s32 bfOffbits;              //byte offset to pixel data
        s32 biSize;                 //size of header
        s32 biWidth;                //width of BMP
        s32 biHeight;               //height of BMP
        s16 biPlanes;               //# of color planes
        s16 biBitCount;             //color resolution(1, 4, 8, 24)
        s32 biCompression;          //compressoin type(encoding)
        s32 biSizeImage;            //size of compressed image
        s32 biXPelsPerM;            //horiz. resolution(pix per meter)
        s32 biYPelsPerM;            //vert. resolution(pix per meter)
        s32 biColorUsed;            //# of colors used
        s32 biClrImportant;         //# of "important colors
    };

    struct SBGR { u8 B, G, R; };    //BMP data format
    struct SRGB { u8 R, G, B; };    //Frame buffer format

    /////////////////////////////////////////////////////////////////

	// hard-coding values to make MW happy 
	//	will need another solution - PM
    const s32 WIDTH     = aaBuff.dispW;
    const s32 HEIGHT    = aaBuff.dispH;

    static s32 sShotCount = 0;

    SRGB FBImage[WIDTH * HEIGHT] __attribute__((aligned(16)));

    // Get the frame buffer image from the GS
    {   x_printf( "\nCapturing screen image...\n" );

    sceGsStoreImage sp;

    while( !DMAMAN_AreTasksFinished() ) {} //intentionally left empty

    DMAMAN_HandlersOff();
    sceGsSetDefStoreImage( &sp, 0, WIDTH/64, SCE_GS_PSMCT24, 0, 0, WIDTH, HEIGHT );
    FlushCache( 0 );
    sceGsExecStoreImage( &sp, (u_long128 *)FBImage );
    sceGsSyncPath( 0, 0 );
    DMAMAN_HandlersOn();
    DMAMAN_ExecuteTasks();
    }

    X_FILE* pFile;

    // Make filename
    {   char fname[128];

    if( pFilename == NULL )
        x_sprintf( fname, "ScreenShot%d.bmp", sShotCount++ );
    else
        x_sprintf( fname, "%s%d.bmp", pFilename, sShotCount++ );

    x_printf( "Screen shot obtained, saving to file \"%s\"...\n", fname );
    pFile = x_fopen( fname, "wb" );
    ASSERT( pFile != NULL );
    }

    const s32 BMP_HEADER_SIZE       = sizeof(SBMPHeader) - sizeof(s16);
    const s32 BMP_INFO_HEADER_SIZE  = BMP_HEADER_SIZE - sizeof(s16)*3 - sizeof(s32)*2;
    const s32 BMP_PADDING           = (4 - ( (WIDTH * sizeof(SBGR) ) & 0x03)) & 0x03;
    const s32 BMP_PHYSICAL_WIDTH    = WIDTH * sizeof(SBGR) + BMP_PADDING;

    // Setup BMP file header
    {   SBMPHeader bmHeader;

    bmHeader.bfType         = 'B' | ('M' << 8);
    bmHeader.bfSize         = BMP_HEADER_SIZE + (BMP_PHYSICAL_WIDTH * HEIGHT);
    bmHeader.bfRsrv1        = 0;
    bmHeader.bfRsrv2        = 0;
    bmHeader.bfOffbits      = BMP_HEADER_SIZE;
    bmHeader.biSize         = BMP_INFO_HEADER_SIZE;
    bmHeader.biWidth        = WIDTH;
    bmHeader.biHeight       = HEIGHT;
    bmHeader.biPlanes       = 1;
    bmHeader.biBitCount     = 24;
    bmHeader.biCompression  = 0;
    bmHeader.biSizeImage    = 0;    //BMP_PHYSICAL_WIDTH * HEIGHT;
    bmHeader.biXPelsPerM    = 2834; //28.34 pels/cm or 72 pels/inch
    bmHeader.biYPelsPerM    = 2834; //28.34 pels/cm or 72 pels/inch
    bmHeader.biColorUsed    = 0;
    bmHeader.biClrImportant = 0;

    x_fwrite( &(bmHeader.bfType), BMP_HEADER_SIZE, 1, pFile );
    }

    const s32 IMAGE_LINE_OFFSET = 1;

    // Convert frame buffer image to BMP format and write to file
    byte    TwoLineData[ 2 * BMP_PHYSICAL_WIDTH ];

    SBGR*   BMPLineOne = (SBGR*)TwoLineData;
    SBGR*   BMPLineTwo = (SBGR*)(TwoLineData + BMP_PHYSICAL_WIDTH);
    SRGB*   ImageData;
    s32     CurPixel;
    s32     CurBMPLine;

    // BMP format starts from last scan line of image and moves toward first
    CurBMPLine = HEIGHT - 1;
    while( CurBMPLine >= 0 )
    {
        // Convert scanline to BMP format
        CurPixel = 0;
        ImageData = FBImage + (CurBMPLine * WIDTH);
        while( CurPixel < WIDTH )
        {
            BMPLineOne[CurPixel].B = ImageData->B;
            BMPLineOne[CurPixel].G = ImageData->G;
            BMPLineOne[CurPixel].R = ImageData->R;
            CurPixel++;
            ImageData++;
        }

        // Convert next scanline to BMP format
        CurPixel = 0;
        ImageData = FBImage + ((CurBMPLine - IMAGE_LINE_OFFSET) * WIDTH);
        while( CurPixel < WIDTH )
        {
            BMPLineTwo[CurPixel].B = ImageData->B;
            BMPLineTwo[CurPixel].G = ImageData->G;
            BMPLineTwo[CurPixel].R = ImageData->R;
            CurPixel++;
            ImageData++;
        }

        // Note that HEIGHT MUST be a multiple of 2 for this loop to execute properly
        CurBMPLine -= 2;

        x_fwrite( TwoLineData, 2 * BMP_PHYSICAL_WIDTH, 1, pFile );
    }

    x_fclose( pFile );
    pFile = NULL;

    x_printf( "Screen shot capture finished.\n" );
}

//=========================================================================

static
void SetScissorRegion( void )
{
    sceDmaTag*  pDMA;
    u32*        pVIF;
    sceGifTag*  pGIF;
    u64*        pAD;

    ASSERT( s_InsideRenderMode );

    //---   build the DMA packet
    pDMA = (sceDmaTag*)pDList;
    DMAHELP_BuildTagCont( pDMA, sizeof(sceGifTag) +
        sizeof(u64) * 2 +
        sizeof(u32) * 4 );
    pDList += sizeof(sceDmaTag);

    //---   build the VIF packet to send stuff directly to the GS
    pVIF = (u32*)pDList;
    pVIF[0] = 0;
    pVIF[1] = 0;
    pVIF[2] = SCE_VIF1_SET_FLUSH(0);
    pVIF[3] = SCE_VIF1_SET_DIRECT( 2, 0 );
    pDList += sizeof(u32) * 4;

    //---   build the GIF tag saying I want to set a register directly
    pGIF = (sceGifTag*)pDList;
    VIFHELP_BuildGifTag1( pGIF, VIFHELP_GIFMODE_PACKED, 1, 1, FALSE, 0, 0, TRUE );
    VIFHELP_BuildGifTag2( pGIF, VIFHELP_GIFREG_AD, 0, 0, 0 );
    pDList += sizeof(sceGifTag);

    //---   set up the AD register
    pAD = (u64*)pDList;
    pAD[0] = SCE_GS_SET_SCISSOR_1( s_2DClipL, s_2DClipR, s_2DClipT, s_2DClipB );
    pAD[1] = SCE_GS_SCISSOR_1;
    pDList += sizeof(u64) * 2;

    //---   clear out the dirty flag
    s_2DClipDirty = FALSE;
}

//==========================================================================

void ENG_GetRenderFlags( u32& RenderFlags )
{
    RenderFlags = s_RenderFlags;
}

//==========================================================================

void ENG_GetBlendMode( u32& BlendMode, u8& FixedAlpha )
{
    BlendMode = s_BlendFlags;
    FixedAlpha = s_AlphaBlendFix;
}

//==========================================================================

void ENG_SetRenderFlags( u32 RenderFlags )
{
    ASSERT( ENG_GetRenderMode() );

    //------------------------------
    //---   flags sanity checking
    //------------------------------

    ASSERT( ( RenderFlags & ENG_ZBUFFER_TEST_ON  ) |
            ( RenderFlags & ENG_ZBUFFER_TEST_OFF ) );

    ASSERT( ( RenderFlags & ENG_ZBUFFER_FILL_ON  ) |
            ( RenderFlags & ENG_ZBUFFER_FILL_OFF ) );

    ASSERT( ( RenderFlags & ENG_ALPHA_TEST_ON    ) |
            ( RenderFlags & ENG_ALPHA_TEST_OFF   ) );

    ASSERT( ( RenderFlags & ENG_ALPHA_BLEND_ON   ) |
            ( RenderFlags & ENG_ALPHA_BLEND_OFF  ) );

    if ( RenderFlags != s_RenderFlags )
    {
        PS2_SetAlphaEnv( RenderFlags );
    }
}

//==========================================================================

void ENG_SetBlendMode( u32 BlendFlags, u8 FixedAlpha )
{
    //if (BlendFlags == s_BlendFlags) return;

    switch( BlendFlags & 0x0f )
    {
    case ENG_BLEND_NORMAL: 
        PS2_SetAlphaBlending( PS2_ALPHA_CS, 
                              PS2_ALPHA_CD, 
                              ((BlendFlags & ENG_BLEND_FIXED_ALPHA) ? PS2_ALPHA_FIX : PS2_ALPHA_AS), 
                              PS2_ALPHA_CD, 
                              FixedAlpha );
        break;
    case ENG_BLEND_ADDITIVE:
        PS2_SetAlphaBlending( PS2_ALPHA_CS, 
                              PS2_ALPHA_ZERO, 
                              ((BlendFlags & ENG_BLEND_FIXED_ALPHA) ? PS2_ALPHA_FIX : PS2_ALPHA_AS), 
                              PS2_ALPHA_CD, 
                              FixedAlpha );
        break;
    case ENG_BLEND_SUBTRACTIVE:
        PS2_SetAlphaBlending( PS2_ALPHA_ZERO, 
                              PS2_ALPHA_CS, 
                              ((BlendFlags & ENG_BLEND_FIXED_ALPHA) ? PS2_ALPHA_FIX : PS2_ALPHA_AS), 
                              PS2_ALPHA_CD, 
                              FixedAlpha );
        break;
    case ENG_BLEND_DEST:
        PS2_SetAlphaBlending( PS2_ALPHA_ZERO, 
                              PS2_ALPHA_ZERO, 
                              ((BlendFlags & ENG_BLEND_FIXED_ALPHA) ? PS2_ALPHA_FIX : PS2_ALPHA_AD), 
                              PS2_ALPHA_CD, 
                              FixedAlpha );
        break;
    case ENG_BLEND_MULTIPLY:
        ASSERT(0);  //NOT SUPPORTED
        break;

    case ENG_BLEND_MULTI_1:
        PS2_SetAlphaBlending( PS2_ALPHA_CS,
                              PS2_ALPHA_CD,
                              PS2_ALPHA_FIX,
                              PS2_ALPHA_CD,
                              FixedAlpha );
        break;

    case ENG_BLEND_MULTI_2:
        PS2_SetAlphaBlending( PS2_ALPHA_CD,
                              PS2_ALPHA_CS,
                              PS2_ALPHA_AS,
                              PS2_ALPHA_CS,
                              0 );
        break;
    }

    s_BlendFlags = BlendFlags;
}

//==========================================================================

void ENG_SpecialCaseFog( xbool bActivateSpecial )
{
    if (bActivateSpecial)
        s_SpecialCaseFog++;
    else
        s_SpecialCaseFog--;
}

//==========================================================================

void    ENG_SetFogColor         ( u8 Red, u8 Green, u8 Blue )
{
    if (Red != eng_fog_color.R || Green != eng_fog_color.G || Blue != eng_fog_color.B)
    {
        ResetFogPackets();
    }
    eng_fog_color.Set( Red, Green, Blue );
}

//==========================================================================

void ENG_SetFogParameters( xbool bEnable, f32 fStart, f32 fAccumDepth, f32 fMaxFog, f32 fDensity )
{
    // dammit.  
    //  The gfStadiumAvgFogDensity values are coming out broken.
    //  Fogging is too slow right now.
    //  Worlds are falling apart because of things
    // Hard-coding fog values to fix the shizzits
    fStart = 3750.0f;
    fAccumDepth = 0.0f;
    fMaxFog = 0.25f;
    fDensity = 1.0f / 30000.0f;

    g_EngineFog.bEnabled = bEnable;
    g_EngineFog.fStart = fStart*2.0f;
    g_EngineFog.fDepth = fAccumDepth;
    g_EngineFog.fMaxFog = fMaxFog;
    // (1.75/30000)is our most dense fog
    // 1/(1.75/30000) is what we multiply by to get in a 0 to 1 range for density...
    g_EngineFog.fDensity = (fDensity * 17142.857142857142857142857142857f); 

    ResetFogPackets();
}

//==========================================================================

void ENG_ActivateFog( xbool bEnable )
{
    if (g_EngineFog.fDepth <= 0.0f)
        return;

    g_EngineFog.bEnabled = bEnable;

    if (bEnable)
    {
        s_bDoFog = TRUE;
    }

//    s_bDoFog = FALSE;
}

//==========================================================================

void PS2_SetAlphaEnv( u32 RenderFlags )
{
    engtest_header* pHeader;


    // A pre-built packet note - there's just too many variables in this data to make it easily prebuilt.
    //  We already have the ALPHA packets if we'd like to separate them.  If this function shows up on
    //  a profile, then all of the data will need to be dumped into individual packets - we'll be able to
    //  have an overall smaller footprint if we split all of the data, but we willl have a larger DMA cost...



    //---   grab some space from the display list
    pHeader = (engtest_header*)pDList;
    pDList += sizeof(engtest_header);

    //---   Build the dma command
    DMAHELP_BuildTagCont( &pHeader->DMA, sizeof(engtest_header)-sizeof(sceDmaTag) );

    //---   Build the VIF command
    pHeader->VIF[0] = 0;
    pHeader->VIF[1] = 0;
    pHeader->VIF[2] = SCE_VIF1_SET_FLUSH(0);
    pHeader->VIF[3] = SCE_VIF1_SET_DIRECT( 7, 0 );

    //---   Set the appropriate GIF tag
    VIFHELP_BuildGifTag1( &pHeader->GIF,
                          VIFHELP_GIFMODE_PACKED,
                          1,
                          6,
                          FALSE,
                          0,
                          0,
                          TRUE );
    VIFHELP_BuildGifTag2( &pHeader->GIF,
                          VIFHELP_GIFREG_AD, 0, 0, 0 );

    //---   Now fill in the appropriate data based on the render flags
    pHeader->AD[0] = 0;
    pHeader->AD[1] = SCE_GS_FINISH;
    if (s_bDoFog && s_SpecialCaseFog == 0)
    {
        pHeader->AD[2] = SCE_GS_SET_ZBUF( aaBuff.zFBP,  // Z-buffer address
                                          aaBuff.zPSM,  // Storage format
                                          0x0 );
        pHeader->AD[4] = SCE_GS_SET_TEST( 0x1,          // Alpha test (on/off)
                                          0x5,                                              // Alpha test method (>= refval)
                                          (RenderFlags & ENG_ALPHA_BLEND_ON) ? 1 : 0x7e,    // Alpha value to be compared
                                          0,                                                // how to handle failed alpha,
                                          s_DestAlphaTest,                                  // Dest alpha test
                                          s_DestAlphaMode,                                  // Dest alpha test mode
                                          0x1,
                                          (RenderFlags & ENG_ZBUFFER_TEST_ON) ? 0x2 : 1 );
    }
    else
    {
        pHeader->AD[2] = SCE_GS_SET_ZBUF( aaBuff.zFBP,  // Z-buffer address
                                          aaBuff.zPSM,  // Storage format
                                          (RenderFlags & ENG_ZBUFFER_FILL_ON) ? 0x0 : 0x1 );
        pHeader->AD[4] = SCE_GS_SET_TEST( (RenderFlags & ENG_ALPHA_TEST_OFF) ? 0x0 : 0x1,   // Alpha test (on/off)
                                          0x5,                                              // Alpha test method (>= refval)
                                          (RenderFlags & ENG_ALPHA_BLEND_ON) ? 0x0 : 0x7e,  // Alpha value to be compared
                                          0x0,                                              // how to handle failed alpha,
                                          s_DestAlphaTest,                                  // Dest alpha test
                                          s_DestAlphaMode,                                  // Dest alpha test mode
                                          0x1,
                                          (RenderFlags & ENG_ZBUFFER_TEST_ON) ? 0x2 : 0x1 );
    }
    pHeader->AD[3] = SCE_GS_ZBUF_1;
    pHeader->AD[5] = SCE_GS_TEST_1;

    if ( RenderFlags & ENG_ALPHA_BLEND_ON )
    {
        pHeader->AD[6] = SCE_GS_SET_ALPHA( s_AlphaBlendA,
                                           s_AlphaBlendB,
                                           s_AlphaBlendC,
                                           s_AlphaBlendD,
                                           s_AlphaBlendFix );
        pHeader->AD[7] = SCE_GS_ALPHA_1;
    }
    else
    {
        pHeader->AD[6] = SCE_GS_SET_ALPHA( 0x2, 0x2, 0x2, 0x00, 0x00 );
        pHeader->AD[7] = SCE_GS_ALPHA_1;
    }

    pHeader->AD[8] = SCE_GS_SET_FBA( s_FBA );
    pHeader->AD[9] = SCE_GS_FBA_1;

    pHeader->AD[10] = SCE_GS_SET_COLCLAMP( 1 );
    pHeader->AD[11] = SCE_GS_COLCLAMP;

    s_RenderFlags = RenderFlags;
}

//==========================================================================

void PS2_SetBlendEnv( void )
{
//    engblend_header*    pHeader;
    static s32          iPrevIndex = -1;


    // A PreBuilt packet note - 
    //  The A, B, C, and D data is prebaked into the packets.
    //  However, if C is set to be "FIXed" data then another value is required.
    //  The packet is modified to stuff in the proper FIX value.
    //  There's a potential problem with this, though.  The FIX value is stuffed into a "permanent"
    //  data packet.  If a different FIX value is needed in the same cycle, and A, B, and D are all 
    //  the same for both cases, then there will be contention for the correct FIX value.  The second
    //  value will override the first value and there may be noticable consequences.
    // I'm not expecting to ever see this occur, so I left it as is.  If something is cropping up,
    //  create a data packet on the stack and stuff it in the DList with a CONT call.  


    // if we are not blending, then use index 78
    // A=2,B=2,C=2,D=0
    // (2*27)+(2*9)+(2*3)=78
    s32 iIndex = 78;
    if ( s_RenderFlags & ENG_ALPHA_BLEND_ON )
    {
        iIndex = s_AlphaBlendD + (s_AlphaBlendC*3) + (s_AlphaBlendB*9) + (s_AlphaBlendA*27);
        if (s_AlphaBlendC == 2)
        {
            s_BlendEnv[ iIndex ].AD[ 0 ] = SCE_GS_SET_ALPHA( s_AlphaBlendA,
                                                             s_AlphaBlendB,
                                                             s_AlphaBlendC,
                                                             s_AlphaBlendD,
                                                             s_AlphaBlendFix );
        }
    }
    if (iIndex != iPrevIndex)
    {
        sceDmaTag *pBlend = (sceDmaTag *)pDList;
        pDList += sizeof( sceDmaTag );
        DMAHELP_BuildTagRef( pBlend, (u32)&s_BlendEnv[ iIndex ], sizeof( s_BlendEnv[ iIndex ] ) );
        iPrevIndex = iIndex;
    }
}

//==========================================================================

void PS2_SetAlphaBlending( s32 A, s32 B, s32 C, s32 D, u8 FIX )
{

    s32 NewAlphaBlendA      = 0x2;
    s32 NewAlphaBlendB      = 0x2;
    s32 NewAlphaBlendC      = 0x2;
    s32 NewAlphaBlendD      = 0x00;
    s32 NewAlphaBlendFix    = 0x00;

    switch( A )
    {
        case PS2_ALPHA_CS:      NewAlphaBlendA = 0; break;
        case PS2_ALPHA_CD:      NewAlphaBlendA = 1; break;
        case PS2_ALPHA_ZERO:    NewAlphaBlendA = 2; break;
        default:                ASSERT( FALSE );    break;
    }

    switch( B )
    {
        case PS2_ALPHA_CS:      NewAlphaBlendB = 0; break;
        case PS2_ALPHA_CD:      NewAlphaBlendB = 1; break;
        case PS2_ALPHA_ZERO:    NewAlphaBlendB = 2; break;
        default:                ASSERT( FALSE );    break;
    }

    switch( C )
    {
        case PS2_ALPHA_AS:      NewAlphaBlendC = 0; break;
        case PS2_ALPHA_AD:      NewAlphaBlendC = 1; break;
        case PS2_ALPHA_FIX:     NewAlphaBlendC = 2; break;
        default:                ASSERT( FALSE );    break;
    }

    switch( D )
    {
        case PS2_ALPHA_CS:      NewAlphaBlendD = 0; break;
        case PS2_ALPHA_CD:      NewAlphaBlendD = 1; break;
        case PS2_ALPHA_ZERO:    NewAlphaBlendD = 2; break;
        default:                ASSERT( FALSE );    break;
    }

    NewAlphaBlendFix = FIX;

    if ((NewAlphaBlendA   != s_AlphaBlendA)   ||
        (NewAlphaBlendB   != s_AlphaBlendB)   ||
        (NewAlphaBlendC   != s_AlphaBlendC)   ||
        (NewAlphaBlendD   != s_AlphaBlendD)   ||
        (NewAlphaBlendFix != s_AlphaBlendFix) )
    {
        s_AlphaBlendA      = NewAlphaBlendA;
        s_AlphaBlendB      = NewAlphaBlendB;
        s_AlphaBlendC      = NewAlphaBlendC;
        s_AlphaBlendD      = NewAlphaBlendD;
        s_AlphaBlendFix    = NewAlphaBlendFix;

        if (s_RenderFlags & ENG_ALPHA_BLEND_ON)
            PS2_SetBlendEnv();
    }
}



//=========================================================================

void ENG_SetBackgroundColor( color C )
{
    //NOT IMPLEMENTED FOR PS2
}

//=========================================================================

void PS2_SetDestAlphaTest( xbool OnOff, s32 mode )
{
    s_DestAlphaTest = OnOff;
    s_DestAlphaMode = mode;
    PS2_SetAlphaEnv( s_RenderFlags );
}

//==========================================================================

void PS2_SetFBA( xbool OnOff )
{
    if ( s_FBA != OnOff )
    {
        sceDmaTag*      pDMA;
        u32*            pVIF;
        u64*            pAD;
        sceGifTag*      pGIF;

        //---   update our static
        s_FBA = OnOff;

        //---   build the DMA packet
        pDMA = (sceDmaTag*)pDList;
        DMAHELP_BuildTagCont( pDMA, sizeof(sceGifTag) + sizeof(u64) * 4 + sizeof(u32) * 4 );
        pDList += sizeof(sceDmaTag);

        //---   build the vif packet to send stuff directly to the GS
        pVIF = (u32*)pDList;
        pVIF[0] = 0;
        pVIF[1] = 0;
        pVIF[2] = SCE_VIF1_SET_FLUSH( 0 );
        pVIF[3] = SCE_VIF1_SET_DIRECT( 3, 0 );
        pDList += sizeof(u32) * 4;

        //---   build the GIF tag saying I want to set a register directly
        pGIF = (sceGifTag*)pDList;
        VIFHELP_BuildGifTag1( pGIF,
                              VIFHELP_GIFMODE_PACKED,
                              1,
                              2,
                              FALSE,
                              0,
                              0,
                              TRUE );
        VIFHELP_BuildGifTag2( pGIF, VIFHELP_GIFREG_AD, 0, 0, 0 );
        pDList += sizeof(sceGifTag );

        //---   set up the AD register
        pAD = (u64*)pDList;
        pAD[0] = 0;
        pAD[1] = SCE_GS_FINISH;
        pAD[2] = SCE_GS_SET_FBA( OnOff );
        pAD[3] = SCE_GS_FBA_1;
        pDList += sizeof(u64) * 4;
    }
}

//==========================================================================
//  PS2_PeekZBuffer()
//      Peeks into the z-buffer and returns the value at a pixel position(X,Y)
//==========================================================================
s32 PS2_PeekZBuffer( s32 X, s32 Y )
{
    ASSERTS( FALSE, "Function not working properly." );
    return 0;

    /*
    ASSERT( (X >= 0) && (X < ENG_GetScreenWidth()) );
    ASSERT( (Y >= 0) && (Y < ENG_GetScreenHeight()) );

    return 0;   // this function currently is screwed

    unsigned char z_buf[4] __attribute__((aligned(16)));
    sceGsStoreImage sp;

    while (!DMAMAN_AreTasksFinished());
    DMAMAN_HandlersOff();

    sceGsSetDefStoreImage(&sp, 0x2300, kDisplayWidth/64, SCE_GS_PSMZ24, X, Y, 1, 1);

    FlushCache(0);
    sceGsExecStoreImage(&sp, (u_long128 *)z_buf);
    sceGsSyncPath(0, 0);

    //while (!DMAMAN_AreTasksFinished());
    DMAMAN_HandlersOn();
    DMAMAN_ExecuteTasks();

    return (((s32)*((s32*)z_buf)) & 0x00ffffff);*/
}
//=========================================================================

void PS2_InitializeGraphics( xbool bIsGame, xbool bIsProgressive, xbool bIsPAL )
{
    ENG_WaitForGraphicsSynch();
    ENG_WaitForGraphicsSynch();
    PS2_ScreenClearImmediate( TRUE, 0,0,0,0 );

    s32 buff1W;
    s32 buff1H;
    s32 buff1PSM;
    s32 buff2W;
    s32 buff2H;
    s32 buff2PSM;
    s32 zPSM;

    if (   bIsGame == s_bIsGame_graphicsave
        && bIsProgressive == s_bIsProgressive_graphicsave
        && bIsPAL == s_bIsPAL_graphicsave
        && s_bGraphicsCheatActive == s_bGraphicsCheatActive_graphicsave)
        return; // do nothing

    s_bIsGame_graphicsave = bIsGame;
    s_bIsProgressive_graphicsave = bIsProgressive;
    s_bIsPAL_graphicsave = bIsPAL;

    if (bIsGame)
        s_bGraphicsCheatActive_graphicsave = s_bGraphicsCheatActive; // only save this state when entering game

    if (bIsGame && s_bGraphicsCheatActive)
    {
        zPSM = SCE_GS_PSMCT32;
        if (bIsProgressive)
        {
            // 2 640x480x16 buffers
            sceGsResetGraph( 0, SCE_GS_NOINTERLACE, SCE_GS_DTV480P, SCE_GS_FRAME );
            buff1W = buff2W = 640;
            buff1H = buff2H = 480;
            buff1PSM = buff2PSM = SCE_GS_PSMCT16S;
        }
        else if (bIsPAL)
        {
            // 2 640x448x32 buffers
            sceGsResetGraph( 0, SCE_GS_INTERLACE, SCE_GS_PAL, SCE_GS_FIELD );
            buff1W = buff2W = 640;
            buff1H = buff2H = 448;
            buff1PSM = buff2PSM = SCE_GS_PSMCT32;
        }
        else
        {
            // 2 640x448x32 buffers
            sceGsResetGraph( 0, SCE_GS_INTERLACE, SCE_GS_NTSC, SCE_GS_FIELD );
            buff1W = buff2W = 640;
            buff1H = buff2H = 448;
            buff1PSM = buff2PSM = SCE_GS_PSMCT32;
        }
        Setup_Cheat_buffer( pAAbuff, buff1W, buff1H, buff1PSM,
                            buff2W, buff2H, buff2PSM,
                            SCE_GS_ZGEQUAL, SCE_GS_PSMZ32, SCE_GS_NOCLEAR,
                            bIsProgressive );
    }
    else
    {
        if (bIsGame)
        {
            zPSM = SCE_GS_PSMZ32;
            if (bIsProgressive)
            {
                // 640x480x16 Display
                //  704x512x32 Frame & ZBuff
                sceGsResetGraph( 0, SCE_GS_NOINTERLACE, SCE_GS_DTV480P, SCE_GS_FRAME );
                buff1W = 640;
                buff1H = 480;
                buff1PSM = SCE_GS_PSMCT16S;
                buff2W = 704;
                buff2H = 512;
                buff2PSM = SCE_GS_PSMCT32;
            }
            else if (bIsPAL)
            {
                // 512x448x16 Display
                // 704x576x32 Frame & ZBuff
                sceGsResetGraph( 0, SCE_GS_INTERLACE, SCE_GS_PAL, SCE_GS_FIELD );
                buff1W = 512;
                buff1H = 448;
                buff1PSM = SCE_GS_PSMCT16S;
                buff2W = 704;
                buff2H = 576;
                buff2PSM = SCE_GS_PSMCT32;
            }
            else
            {
                // 512x448x16 Display
                // 704x576x32 Frame & ZBuff
                sceGsResetGraph( 0, SCE_GS_INTERLACE, SCE_GS_NTSC, SCE_GS_FIELD );
                buff1W = 512;
                buff1H = 448;
                buff1PSM = SCE_GS_PSMCT16S;
                buff2W = 704;
                buff2H = 576;
                buff2PSM = SCE_GS_PSMCT32;
            }
        }
        else    // frontend setup
        {
            if (bIsProgressive)
            {
                // 640x480x32 Display
                // 640x480x32 Frame
                // 640x480x16 ZBuff
                sceGsResetGraph( 0, SCE_GS_NOINTERLACE, SCE_GS_DTV480P, SCE_GS_FRAME );
                buff1W = 640;
                buff1H = 480;
                buff1PSM = SCE_GS_PSMCT32;
                buff2W = 640;
                buff2H = 480;
                buff2PSM = SCE_GS_PSMCT32;
                zPSM = SCE_GS_PSMZ16S;
            }
            else if (bIsPAL)
            {
                // 640x448x32 Display
                // 640x448x32 Frame
                // 640x448x16 ZZBuff
                sceGsResetGraph( 0, SCE_GS_INTERLACE, SCE_GS_PAL, SCE_GS_FIELD );
                buff1W = 640;
                buff1H = 448;
                buff1PSM = SCE_GS_PSMCT32;
                buff2W = 640;
                buff2H = 448;
                buff2PSM = SCE_GS_PSMCT32;
                zPSM = SCE_GS_PSMZ16S;
            }
            else
            {
                // 640x448x32 Display
                // 640x448x32 Frame
                // 640x448x16 ZZBuff
                sceGsResetGraph( 0, SCE_GS_INTERLACE, SCE_GS_NTSC, SCE_GS_FIELD );
                buff1W = 640;
                buff1H = 448;
                buff1PSM = SCE_GS_PSMCT32;
                buff2W = 640;
                buff2H = 448;
                buff2PSM = SCE_GS_PSMCT32;
                zPSM = SCE_GS_PSMZ16S;
            }
        }

        Setup_FSAA_buffer( pAAbuff, buff1W, buff1H, buff1PSM,   // disp size, mode
                           buff2W, buff2H, buff2PSM,            // draw size, mode
                           SCE_GS_ZGEQUAL, zPSM,                // z    test, mode
                           SCE_GS_NOCLEAR,                      // clear
                           bIsProgressive );                    // passing through Progressive settings for merge circuit
    }

    s_bIsProgressive = bIsProgressive;

    s_XRes = buff2W;
    s_YRes = buff2H;
    s_fXConversion = (f32)buff2W / 640.0f;
    s_fYConversion = (f32)buff2H / 448.0f;
    s_ScissorLeft = ((2048-(buff2W>>1)) << 4);
    s_ScissorTop = ((2048-(buff2H>>1)) << 4);

    s_WindowLeft = (2048-(buff2W>>1));
    s_WindowTop = (2048-(buff2H>>1));

    s_View.SetViewport( 0, 0, s_XRes, s_YRes );

    PS2_ScreenClearImmediate( TRUE, 0,0,0,0 );

/*    
    // clear the frame buffer and display buffer
    // using s_ScreenClearSprite;
    sceDmaTag *pTag = (sceDmaTag *)pDList;
    pDList += sizeof( sceDmaTag );

    s_ScreenClearSprite.VIF[ 0 ] = 0;
    s_ScreenClearSprite.VIF[ 1 ] = 0;
    s_ScreenClearSprite.VIF[ 2 ] = SCE_VIF1_SET_FLUSH( 0 );
    s_ScreenClearSprite.VIF[ 3 ] = SCE_VIF1_SET_DIRECT( 28, 0 );
    VIFHELP_BuildGifTag1( &s_ScreenClearSprite.GIFTag, VIFHELP_GIFMODE_PACKED, 1, 27, FALSE, 0, 0, TRUE );
    VIFHELP_BuildGifTag2( &s_ScreenClearSprite.GIFTag, VIFHELP_GIFREG_AD, 0, 0, 0 );
    s_ScreenClearSprite.GSCmds[ 0 ] = 0;
    s_ScreenClearSprite.GSCmds[ 1 ] = SCE_GS_TEXFLUSH;
    s_ScreenClearSprite.GSCmds[ 2 ] = SCE_GS_SET_TEX1_1( 1, 0, 0, 0, 1, 0, 0 );
    s_ScreenClearSprite.GSCmds[ 3 ] = SCE_GS_TEX1_1;
    // sorry for the hard-coded address - first texture goes to 13696
    s32 shiftW = 9;
    s32 shiftH = 9;
    s_ScreenClearSprite.GSCmds[ 4 ] = SCE_GS_SET_TEX0_1( 16380-1660, aaBuff.drawW/64, aaBuff.drawPSM, shiftW, shiftH, 1, 1, 16380, 0, 0, 0, 1 );
    s_ScreenClearSprite.GSCmds[ 5 ] = SCE_GS_TEX0_1;
    s_ScreenClearSprite.GSCmds[ 6 ] = SCE_GS_SET_CLAMP_1( 0, 0, 0, 0, 0, 0 );
    s_ScreenClearSprite.GSCmds[ 7 ] = SCE_GS_CLAMP_1;
    s_ScreenClearSprite.GSCmds[ 8 ] = SCE_GS_SET_ALPHA_1( 0, 1, 0, 1, 0 );
    s_ScreenClearSprite.GSCmds[ 9 ] = SCE_GS_ALPHA_1;
    s32 W = ENG_GetScreenWidth();
    s32 H = ENG_GetScreenHeight();

    s_ScreenClearSprite.GSCmds[ 10 ] = SCE_GS_SET_FRAME_1( 0, 10, aaBuff.drawSmall.frame1.PSM, 0 );
    s_ScreenClearSprite.GSCmds[ 11 ] = SCE_GS_FRAME_1;
    s_ScreenClearSprite.GSCmds[ 12 ] = SCE_GS_SET_PRIM( 6, 0, 1, 0, 0, 0, 1, 0, 0 );
    s_ScreenClearSprite.GSCmds[ 13 ] = SCE_GS_PRIM;
    s_ScreenClearSprite.GSCmds[ 14 ] = SCE_GS_SET_RGBAQ( 255, 0, 0, 0x3F, 0x3F800000 );
    s_ScreenClearSprite.GSCmds[ 15 ] = SCE_GS_RGBAQ;
    s_ScreenClearSprite.GSCmds[ 16 ] = SCE_GS_SET_SCISSOR_1( 0, ENG_GetScreenWidth()-1, 0, ENG_GetScreenHeight()-1 );
    s_ScreenClearSprite.GSCmds[ 17 ] = SCE_GS_SCISSOR_1;
    s_ScreenClearSprite.GSCmds[ 18 ] = SCE_GS_SET_TEST_1( 0, 1, 0, 0, 0, 0, 1, 2 );
    s_ScreenClearSprite.GSCmds[ 19 ] = SCE_GS_TEST_1;
    s_ScreenClearSprite.GSCmds[ 20 ] = SCE_GS_SET_COLCLAMP( 1 );
    s_ScreenClearSprite.GSCmds[ 21 ] = SCE_GS_COLCLAMP;

    s32 count = 4;
    s32 Width = ENG_GetScreenWidth();
    s32 Height = ENG_GetScreenHeight();
    s32 index2 = 22;
    s32 XStep = (Width/count)<<4;
    s32 X0 = (2048-(Width>>1))<<4;
    s32 Y0 = (2048-(Height>>1))<<4;
    s32 X1 = X0 + (XStep-1);
    s32 Y1 = (2048+(Height>>1))<<4;
    s32 i;
    for (i=0; i<count; ++i)
    {
        s_ScreenClearSprite.GSCmds[ index2++ ] = SCE_GS_SET_UV( 0, 0 );
        s_ScreenClearSprite.GSCmds[ index2++ ] = SCE_GS_UV;
        s_ScreenClearSprite.GSCmds[ index2++ ] = SCE_GS_SET_XYZ2( X0, Y0, 10 );
        s_ScreenClearSprite.GSCmds[ index2++ ] = SCE_GS_XYZ2;
        s_ScreenClearSprite.GSCmds[ index2++ ] = SCE_GS_SET_UV( 0, 0 );
        s_ScreenClearSprite.GSCmds[ index2++ ] = SCE_GS_UV;
        s_ScreenClearSprite.GSCmds[ index2++ ] = SCE_GS_SET_XYZ2( X1, Y1, 10 );
        s_ScreenClearSprite.GSCmds[ index2++ ] = SCE_GS_XYZ2;
        X0 = X1 + 1;
        X1 += XStep;
    }
    DMAHELP_BuildTagRef( pTag, (u32)&s_ScreenClearSprite, sizeof( ps2_screenfill_sprite_packet ) );
*/
}


//=========================================================================

xbool	PS2_IsProgressiveScanOn()
{
	return s_bIsProgressive;
}

//=========================================================================

struct TextureDMA
{
    u32         VIF[ 4 ];
    sceGifTag   GIFTag;
    u64         GSData[ 8 ];
    sceGifTag   GIFImage;
};

struct ViewDMA
{
    u32         VIF[ 4 ];
    sceGifTag   GIFTag;
    u64         GSData[ 8 ];
};

struct SpriteDMA
{
    u32         VIF[ 4 ];
    sceGifTag   GIFTag;
    u64         GSData[ 186 ];
};

const s32 knTextureWidth = 8;
const s32 knTextureHeight = 8;
const s32 knBytesPerPixel = 4;

static byte TheTexture[ (knTextureWidth * knTextureHeight * knBytesPerPixel) ] __attribute__((aligned(16)));

static TextureDMA TextureSetup;

static ViewDMA FrameSetup;
static SpriteDMA SpriteData;

static ViewDMA FrameRestore;

void PS2_ScreenClearImmediate( xbool bClearAll, u8 Red, u8 Green, u8 Blue, u8 Alpha )
{



    // building a series of small sprites to clear VRAM
    // since we want to fill memory...

    // transfer a texture of the given color to VRAM
    // draw a sprite using that texture all over the damn place...

    // setup a temporary display list in SMEM
    // build a solid color texture map in SMEM as well
    // point to the texture map from the dlist in the "first" VRAM slot (arbitrary)
    // build a setup packet for a new frame setup - height based on bClearAll var
    //  add it to the dlist
    // build sprite packets for each screen slice to be cleared
    //  add them to the dlist
    // build a shutdown packet that restores the frame settings
    //  add it to the dlist
    // kick the dlist
    // wait for it to go through

    s32 size = 0;
    // let's see...  "size" needs to be big enough to hold:
    //  a ref to texture map setup data
    //  a ref to the texture itself (or does it go CONT?)
    //  a ref to the frame buffer setup - dimensions for screen, clipping, etc.
    //  a ref for the sprite list setup
    //  a ref to each sprite to be drawn
    //  a ref to the frame buffer restore - puts it back to normal
    // That is sizeof(sceDmaTag) * (5+(kDisplayWidth/32))
    // if we are sending the texture, it would be (sizeof(sceDmaTag)*(5+(kDisplayWidth/32))+(8*8*4)

//    s32 loop;
//    for (loop=0; loop<2; ++loop)
    {
        s32 nDmaTags;
        nDmaTags = 5;
        size = (sizeof( sceDmaTag ) * (nDmaTags + (aaBuff.drawW>>5))) + (knTextureWidth * knTextureHeight * knBytesPerPixel);

        s32 iTempDList = DMAIMMEDIATE_InitDisplayList( size );
        if (iTempDList >= 0)
        {
            s32 ImageSize = ((knTextureWidth * knTextureHeight * (knBytesPerPixel)) >> 4);
            s32 TextureSize = ((knTextureWidth * knTextureHeight * (knBytesPerPixel*8)) >> 7);

            x_memset( &TextureSetup, 0, sizeof( TextureDMA ) );
            TextureSetup.VIF[ 0 ] = 0;
            TextureSetup.VIF[ 1 ] = 0;
            TextureSetup.VIF[ 2 ] = SCE_VIF1_SET_FLUSH( 0 );
            TextureSetup.VIF[ 3 ] = SCE_VIF1_SET_DIRECT( 6+TextureSize, 0 );
            VIFHELP_BuildGifTag1( &TextureSetup.GIFTag, VIFHELP_GIFMODE_PACKED, 1, 4, FALSE, 0, 0, TRUE );
            VIFHELP_BuildGifTag2( &TextureSetup.GIFTag, VIFHELP_GIFREG_AD, 0, 0, 0 );
            TextureSetup.GSData[ 0 ] = SCE_GS_SET_BITBLTBUF( 16380 - 1660, 1, SCE_GS_PSMCT32, 16380 - 1660, 1, SCE_GS_PSMCT32 );
            TextureSetup.GSData[ 1 ] = SCE_GS_BITBLTBUF;
            TextureSetup.GSData[ 2 ] = SCE_GS_SET_TRXPOS( 0, 0, 0, 0, 0 );
            TextureSetup.GSData[ 3 ] = SCE_GS_TRXPOS;
            TextureSetup.GSData[ 4 ] = SCE_GS_SET_TRXREG( 8, 8 );
            TextureSetup.GSData[ 5 ] = SCE_GS_TRXREG;
            TextureSetup.GSData[ 6 ] = SCE_GS_SET_TRXDIR( 0 );
            TextureSetup.GSData[ 7 ] = SCE_GS_TRXDIR;

            VIFHELP_BuildGifTag1( &TextureSetup.GIFImage, VIFHELP_GIFMODE_IMAGE, 0, TextureSize, FALSE, 0, 0, TRUE );

            if (!DMAIMMEDIATE_AddDisplayListRef( iTempDList, sizeof( TextureSetup ), (u32)&TextureSetup, FALSE ))
                DMAIMMEDIATE_ReportLastError();


            s32 i;
            for (i=0; i<8; ++i)
            {
                s32 j;
                for (j=0; j<8; ++j)
                {
                    s32 index = ((i * 4) * 8) + (j * 4);
                    TheTexture[ index + 0 ] = Red;
                    TheTexture[ index + 1 ] = Green;
                    TheTexture[ index + 2 ] = Blue;
                    TheTexture[ index + 3 ] = Alpha;
                }
            }

            if (!DMAIMMEDIATE_AddDisplayListRef( iTempDList, ImageSize, (u32)&TheTexture, FALSE, TRUE ))
                DMAIMMEDIATE_ReportLastError();

            x_memset( &FrameSetup, 0, sizeof( ViewDMA ) );
            FrameSetup.VIF[ 0 ] = 0;
            FrameSetup.VIF[ 1 ] = 0;
            FrameSetup.VIF[ 2 ] = SCE_VIF1_SET_FLUSH( 0 );
            FrameSetup.VIF[ 3 ] = SCE_VIF1_SET_DIRECT( 5, 0 );
            VIFHELP_BuildGifTag1( &FrameSetup.GIFTag, VIFHELP_GIFMODE_PACKED, 1, 4, FALSE, 0, 0, TRUE );
            VIFHELP_BuildGifTag2( &FrameSetup.GIFTag, VIFHELP_GIFREG_AD, 0, 0, 0 );

            if (bClearAll)
            {
                FrameSetup.GSData[ 0 ] = SCE_GS_SET_FRAME_1( 0, 10, SCE_GS_PSMCT32, 0 );
                FrameSetup.GSData[ 2 ] = SCE_GS_SET_SCISSOR_1( 0, 639, 0, 1343 );   // includes z buffer
                FrameSetup.GSData[ 6 ] = SCE_GS_SET_XYOFFSET_1( (2048-(640>>1))<<4, (2048-(448>>1))<<4 );
            }
            else
            {
                FrameSetup.GSData[ 0 ] = SCE_GS_SET_FRAME_1( aaBuff.drawFBP, aaBuff.drawW/64, SCE_GS_PSMCT32, 0 );
                FrameSetup.GSData[ 2 ] = SCE_GS_SET_SCISSOR_1( 0, aaBuff.drawW-1, 0, (aaBuff.drawH*2)-1 );
                FrameSetup.GSData[ 6 ] = SCE_GS_SET_XYOFFSET_1( (2048-(aaBuff.drawW>>1))<<4, (2048-(aaBuff.drawH>>1))<<4 );
            }
            FrameSetup.GSData[ 1 ] = SCE_GS_FRAME_1;
            FrameSetup.GSData[ 3 ] = SCE_GS_SCISSOR_1;
            FrameSetup.GSData[ 4 ] = SCE_GS_SET_TEST_1( 1, 1, 0x4f, 0, 0, 0, 0, 0 );
            FrameSetup.GSData[ 5 ] = SCE_GS_TEST_1;
            FrameSetup.GSData[ 7 ] = SCE_GS_XYOFFSET_1;

            if (!DMAIMMEDIATE_AddDisplayListRef( iTempDList, sizeof( FrameSetup ), (u32)&FrameSetup, FALSE ))
                DMAIMMEDIATE_ReportLastError();

            s32 nStrips = (aaBuff.drawW>>5);
            f32 fX = 2048.0f - (f32)(aaBuff.drawW>>1);
            f32 fY = 2048.0f - (f32)(aaBuff.drawH>>1);
            f32 fWidth = 32.0f;
            f32 fHeight = (f32)aaBuff.drawH * 2.0f;
            s32 count = 5 + ((aaBuff.drawW>>5)*4);
            if (bClearAll)
            {
                nStrips = 20;
                fX = 2048.0f - 320.0f;
                fY = 2048.0f - 224.0f;
                fHeight = 1344.0f;
                count = 85;
            }

            s32 X = (s32)(fX * 16.0f);
            s32 Y = (s32)(fY * 16.0f);
            s32 width = (s32)(fWidth * 16.0f);
            s32 height = (s32)(fHeight * 16.0f);

            x_memset( &SpriteData, 0, sizeof( SpriteDMA ) );
            SpriteData.VIF[ 0 ] = 0;
            SpriteData.VIF[ 1 ] = 0;
            SpriteData.VIF[ 2 ] = SCE_VIF1_SET_FLUSH( 0 );
            SpriteData.VIF[ 3 ] = SCE_VIF1_SET_DIRECT( count+1, 0 );    // big!!!!  bleh!!!!
            VIFHELP_BuildGifTag1( &SpriteData.GIFTag, VIFHELP_GIFMODE_PACKED, 1, count, FALSE, 0, 0, TRUE );
            VIFHELP_BuildGifTag2( &SpriteData.GIFTag, VIFHELP_GIFREG_AD, 0, 0, 0 );
            SpriteData.GSData[ 0 ] = 0;
            SpriteData.GSData[ 1 ] = SCE_GS_TEXFLUSH;
            SpriteData.GSData[ 2 ] = SCE_GS_SET_TEX1_1( 1, 0, 0, 0, 0, 0, 0 );
            SpriteData.GSData[ 3 ] = SCE_GS_TEX1_1;
            SpriteData.GSData[ 4 ] = SCE_GS_SET_TEX0_1( 16380 - 1660, 0, 0, 3, 3, 1, 0, 0, 0, 0, 0, 0 );
            SpriteData.GSData[ 5 ] = SCE_GS_TEX0_1;
            SpriteData.GSData[ 6 ] = SCE_GS_SET_PRIM( 6, 0, 1, 0, 0, 0, 1, 0, 0 );
            SpriteData.GSData[ 7 ] = SCE_GS_PRIM;
            SpriteData.GSData[ 8 ] = SCE_GS_SET_RGBAQ( Red, Green, Blue, Alpha, 0x3F800000 );
            SpriteData.GSData[ 9 ] = SCE_GS_RGBAQ;
            s32 index = 10;  // the sprite vert data starts after the PRIM and COLOR data
            for (i=0; i<nStrips; ++i)
            {
                // build the "sprite strip"
                SpriteData.GSData[ index++ ] = SCE_GS_SET_XYZ2( X, Y, 1 );
                SpriteData.GSData[ index++ ] = SCE_GS_XYZ2;
                SpriteData.GSData[ index++ ] = SCE_GS_SET_UV( 0, 0 );
                SpriteData.GSData[ index++ ] = SCE_GS_UV;
                SpriteData.GSData[ index++ ] = SCE_GS_SET_XYZ2( X + width, Y + height, 1 );
                SpriteData.GSData[ index++ ] = SCE_GS_XYZ2;
                SpriteData.GSData[ index++ ] = SCE_GS_SET_UV( 8 << 4, 8 << 4 );
                SpriteData.GSData[ index++ ] = SCE_GS_UV;

                // increment to the next X
                X += width;
            }
            if (!DMAIMMEDIATE_AddDisplayListRef( iTempDList, sizeof( SpriteData ), (u32)&SpriteData, FALSE ))
                DMAIMMEDIATE_ReportLastError();

            x_memset( &FrameRestore, 0, sizeof( ViewDMA ) );
            FrameRestore.VIF[ 0 ] = 0;
            FrameRestore.VIF[ 1 ] = 0;
            FrameRestore.VIF[ 2 ] = SCE_VIF1_SET_FLUSH( 0 );
            FrameRestore.VIF[ 3 ] = SCE_VIF1_SET_DIRECT( 5, 0 );
            VIFHELP_BuildGifTag1( &FrameRestore.GIFTag, VIFHELP_GIFMODE_PACKED, 1, 4, FALSE, 0, 0, TRUE );
            VIFHELP_BuildGifTag2( &FrameRestore.GIFTag, VIFHELP_GIFREG_AD, 0, 0, 0 );
            FrameRestore.GSData[ 0 ] = SCE_GS_SET_FRAME_1( aaBuff.drawFBP, aaBuff.drawW/64, aaBuff.drawPSM, 0 );
            FrameRestore.GSData[ 1 ] = SCE_GS_FRAME_1;
            FrameRestore.GSData[ 2 ] = SCE_GS_SET_SCISSOR_1( 0, aaBuff.drawW-1, 0, aaBuff.drawW-1 );
            FrameRestore.GSData[ 3 ] = SCE_GS_SCISSOR_1;
            FrameRestore.GSData[ 4 ] = SCE_GS_SET_TEST_1( 0, 1, 0x4f, 0, 0, 0, 0, 0 );
            FrameRestore.GSData[ 5 ] = SCE_GS_TEST_1;
            FrameRestore.GSData[ 6 ] = SCE_GS_SET_XYOFFSET_1( (2048-(aaBuff.drawW>>1))<<4, (2048-(aaBuff.drawH>>1))<<4 );
            FrameRestore.GSData[ 7 ] = SCE_GS_XYOFFSET_1;

            if (!DMAIMMEDIATE_AddDisplayListRef( iTempDList, sizeof( FrameRestore ), (u32)&FrameRestore, FALSE ))
                DMAIMMEDIATE_ReportLastError();

            if (!DMAIMMEDIATE_DisplayListEnd( iTempDList ))
                DMAIMMEDIATE_ReportLastError();
            if (!DMAIMMEDIATE_SendDisplayList( iTempDList ))
                DMAIMMEDIATE_ReportLastError();
            if (!DMAIMMEDIATE_KillDisplayList( iTempDList ))
                DMAIMMEDIATE_ReportLastError();
        }
        else
        {
            DMAIMMEDIATE_ReportLastError();
        }
//        ENG_PageFlip();
    }

    DMAMAN_HandlersOn();
//    ENG_WaitForGraphicsSynch();
}

//=========================================================================

void DRAW_Init( void );

xbool ENG_Activate( s32   XRes,    
                    s32   YRes, 
                    xbool ZBuffer,
                    s32   SMemSize,
                    char* ApplicationName )
{
    sceDmaEnv denv;

    x_DebugSetHandler( PS2AssertHandler );

    ASSERT( !s_EngActivated );
    ASSERT( ZBuffer );

    // Confirm scratch mem size and dlist size    
    ASSERT( s_DListSize >= MIN_DLIST_SIZE );
    ASSERT( SMemSize    >= MIN_SMEM_SIZE  );

    // Confirm resolution
//    ASSERT( XRes == kDisplayWidth );
//    ASSERT( YRes == kDisplayHeight );
    s_XRes = kDisplayWidth;
    s_YRes = kDisplayHeight;
//    s_XRes = XRes;
//    s_YRes = YRes;
    s_View.SetViewport( 0, 0, XRes, YRes );

    PSTAT_ClearMinMax( StatDListAvailable  );
    PSTAT_ClearMinMax( StatDListUsed  );

    x_printf("---------------------------------------\n");
    x_printf("ENGINE: Initializing graphics.\n");

    // Initialize scratch memory
    x_printf("ENGINE: Initializing scratch memory.\n");
    s_SMemSize = SMemSize;
    SMEM_InitModule(s_SMemSize);

    // Setup default environment    
    x_printf("ENGINE: Initializing render environment.\n");
    sceDmaReset(1);
    sceDmaGetEnv(&denv);
    denv.notify = 0x0100; // enable Ch.8 CPCOND 
    sceDmaPutEnv(&denv);
    sceGsResetPath();

    // Get DMA channels
    s_DMA1 = sceDmaGetChan(SCE_DMA_VIF1);

    //Setup FSAA stuff
    s_AAToggle = TRUE;
    pShrinkSprite = (gsDrawDecalSprite*) (((u32)(&shrinkSprite)) | 0x20000000);
    //    pShrinkSprite = (gsDrawDecalSprite*) 0x70000000;

    FlushCache( WRITEBACK_DCACHE );

    // Setup graphics environment
    sceGsResetPath();
    sceDmaReset(1);
//    xbool bIsProgressive = FALSE;
//    xbool bIsPAL = FALSE;
//#ifdef PAL_VERSION
//    bIsPAL = TRUE;
//#endif
//    PS2_InitializeGraphics( FALSE, bIsProgressive, bIsPAL );

    FlushCache(0);
    while(sceGsSyncV(0) == 0);  

    s_OddEven = 0;//!sceGsSyncV(0);
    s_Frame = 0;

    // Setup initial display list
    x_printf("ENGINE: Initializing display lists.\n");
    s_DList = SMEM_BufferAlloc( s_DListSize );
    pDList = s_DList;

    // Initialize input 
    x_printf("ENGINE: Initializing controllers.\n");
    VERIFY( INPUT_InitModule() );

    x_printf("ENGINE: Initializing memcards.\n");
    MEMORY_UNIT_Create( ApplicationName );

    // Startup DMA Manager
    x_printf("ENGINE: Initializing dma task manager.\n");
    DMAMAN_Init();

    // Clear timers
    s_FPSTimer.Clear();
    s_CPUTimer.Clear();
    s_GSTimer.Clear();

    // Setup 2D clip area
    ENG_Set2DClipArea( 0, 0, XRes-1, YRes-1 );
    s_InsideRenderMode = FALSE;

    // Store engine startup time
    s_StartRunTime = x_GetTime();

    x_printf("ENGINE: Initializing draw.\n");
    DRAW_Init();

    x_printf("ENGINE: Initializing default lighting.\n");
    {
        lighting L;
        L.Locked = FALSE;
        L.Ambient = color(32,32,32,255);
        L.Directional[0].Active     = TRUE;
        L.Directional[0].Color      = color(128,0,0,255);
        L.Directional[0].Direction  = vector3(0,1,0);
        L.Directional[1].Active     = TRUE;
        L.Directional[1].Color      = color(0,128,0,255);
        L.Directional[1].Direction  = vector3(1,0,0);
        L.Directional[2].Active     = TRUE;
        L.Directional[2].Color      = color(0,0,128,255);
        L.Directional[2].Direction  = vector3(0,0,1);
        ENG_SetActiveLighting( L );
    }

    x_printf("ENGINE: Initializing vram manager.\n");
    VRAM_Init();

    // Init text
    x_printf("ENGINE: Initializing font.\n");
    FONT_InitModule();

    x_printf("ENGINE: Initializing text manager.\n");
    TEXT_InitModule( s_XRes, s_YRes, 16, 16, 16, 16, FONT_RenderText );


    PS2PERF_Install();

    // create some prebuilt blend data
    s32 i;
    s32 A = 0;
    s32 B = 0;
    s32 C = 0;
    s32 D = 0;
    for (i=0; i<knBlendEnv; ++i)
    {
        s_BlendEnv[ i ].VIF[ 0 ] = 0;
        s_BlendEnv[ i ].VIF[ 1 ] = 0;
        s_BlendEnv[ i ].VIF[ 2 ] = SCE_VIF1_SET_FLUSH(0);
        s_BlendEnv[ i ].VIF[ 3 ] = SCE_VIF1_SET_DIRECT( 2, 0 );
        VIFHELP_BuildGifTag1( &s_BlendEnv[ i ].GIF, VIFHELP_GIFMODE_PACKED, 1, 1, FALSE, 0, 0, TRUE );
        VIFHELP_BuildGifTag2( &s_BlendEnv[ i ].GIF, VIFHELP_GIFREG_AD, 0, 0, 0 );

        s_BlendEnv[ i ].AD[0] = SCE_GS_SET_ALPHA( A, B, C, D, 0x00 );
        s_BlendEnv[ i ].AD[1] = SCE_GS_ALPHA_1;

        D ++;
        if (D > 2)
        {
            D = 0;
            C ++;
        }
        if (C > 2)
        {
            C = 0;
            B ++;
        }
        if (B > 2)
        {
            B = 0;
            A ++;
        }
    }




    // Mark engine as activated and return
    x_printf("ENGINE: Initialized.\n");
    x_printf("---------------------------------------\n");
    s_EngActivated = TRUE;
    return( TRUE );
}

//=========================================================================

void    ENG_Deactivate( void )
{
    ASSERT( s_EngActivated );

    ENG_WaitForGraphicsSynch();

    SMEM_KillModule();
    INPUT_KillModule();
    TEXT_KillModule();
    MEMORY_UNIT_Destroy( );

    // Shutdown dma manager
    DMAMAN_Kill();
    VRAM_Kill();
    FONT_KillModule();
    s_EngActivated = FALSE;    
}

//=========================================================================

static xbool bInit = TRUE;
static xbool s_bFirstLoop = TRUE;

extern void VRAM_Flush( void );

void    ENG_PageFlip( xbool ClearNewScreen )
{

#if defined( TARGET_PS2_DVD )
    // Update any async reads that are going on
    PS2CD_UpdateAsyncReads();
#endif

    // Render the text into current dlist                      
    ENG_BeginRenderMode();
    FONT_BeginRender();
    TEXT_RenderAllText();
    FONT_EndRender();
    ENG_EndRenderMode();

    PS2PERF_DrawStats();

    PS2_DLIST_VERIFY();

    // End timing of CPU
    s_CPUTimer.EndTiming();

    //-- Hack To Force The First Screen To Render -------------------
    if (s_bFirstLoop)
    {
        // Run The DMA Chain
        DMAMAN_HandlersOn();
        FlushCache(WRITEBACK_DCACHE);
        DMAMAN_ExecuteTasks();

        // Only Needs To Be Done Once
        s_bFirstLoop = FALSE;
    }
    //-- Hack To Force The First Screen To Render -------------------

    // Wait for tasks to finish    
    {
        s64 StartTime;
        s32 Count=0;

        StartTime = x_GetTimerTicks();
        while(1)
        {
            if( DMAMAN_AreTasksFinished() ) 
                break;

            Count++;
            if( (Count % 0xFFF) == 0 )
            {
                if( x_TicksToMs( x_GetTimerTicks()-StartTime ) > 3000 )
                {
                    x_printf( "Graphics task did not return...timing out.\n" );
                    DMAMAN_DumpRunChainTasks( 0, 2 );
//                    break;
                    BREAK;
                }
            }
        }
    }

    // End timing of GS
    s_GSTimer.EndTiming();

    // Wait for previous render to finish and turn
    // off dma manager interrupts
    DMAMAN_HandlersOff();

    // Build a sprite out of the DRAW buffer
    if (bInit)
    {
        SetDownSampleSpriteToDisplay( pAAbuff, pShrinkSprite, TRUE );
//        bInit = FALSE;
    }

    // Waiting for the head of V-Blank 
    PS2_WaitVSync();

    // Now dump the sprite to the DISP buffer
    if (s_bGraphicsCheatActive && s_OddFrame)
        PutDrawBufferLarge( pAAbuff );
    else
        PutDrawBufferSmall( pAAbuff );
    if (!s_bGraphicsCheatActive)
        PutDownSampleSprite( &pShrinkSprite->GIFtag );
    sceGsSyncPath(0,0);

    // Do the foggity fog
    if (s_bDoFog)
    {
        s_bDoFog = FALSE;
        if (bInit)
        {
            ResetFogPackets();
            bInit = FALSE;
            BuildGSZBufferTextureOffScreen( (u64)pAAbuff->zFBP, (u64)pAAbuff->drawFBP );
            BuildGSZBufferTextureOnScreen( (u64)pAAbuff->zFBP, (u64)pAAbuff->dispFBP );
            BuildGSZBufferSkyMask( (u64)pAAbuff->dispFBP, (u64)pAAbuff->drawFBP, (u64)pAAbuff->zFBP );
            BuildGSFogSpriteToDisplayData( (u64)pAAbuff->drawFBP, (u64)pAAbuff->dispFBP, (u64)pAAbuff->zFBP );
            BuildGSFogSprite( (u64)pAAbuff->drawFBP, (u64)pAAbuff->zFBP );
        }
        // Build the Z-Intensity texture
        ActivateGSZBufferTextureOffScreen();
        ActivateGSZBufferTextureOnScreen();

        // Write a fog sprite over the entire screen
        //  The color of this sprite is the fog color!
        DrawGSFogSprite();
        ActivateGSZBufferSkyMask();
        CopyGSFogSpriteToDisplay();

        sceGsSyncPath(0,0);
    }

    // Draw it all to screen, using the merge circuit
    PutDispBuffer( pAAbuff, !s_OddFrame );




    // set things up for the next round
    if (s_bGraphicsCheatActive && s_OddFrame)
        PutDrawBufferSmall( pAAbuff );
    else
        PutDrawBufferLarge( pAAbuff );
    sceGsSyncPath(0,0);      

    // Update FPS timer
    s_FPSTimer.EndTiming();
    s_FPSTimer.StartTiming();

    // Determing dlist size
    s_DListSizeUsed = (s32)((u32)pDList - (u32)s_DList);
    ASSERTS( s_DListSizeUsed < s_DListSize, fs("s_DListSizeUsed is %d, max allowed is %d", s_DListSizeUsed/1024, s_DListSize/1024));

    PSTAT_SetValue( StatDListAvailable, s_DListSize );
    PSTAT_SetValue( StatDListUsed, s_DListSizeUsed );

    // Begin timing of user CPU again
    s_CPUTimer.StartTiming();

    // Start timing of GS
    s_GSTimer.StartTiming();

    // Turn dma handlers on and start executing tasks
    DMAMAN_HandlersOn();

    // Writeback data from D-Cache to Memory 
    FlushCache(WRITEBACK_DCACHE);
    DMAMAN_ExecuteTasks();

    // Increment to next frame
    s_Frame++;

    // Toggle scratch buffers and text buffers
    SMEM_Toggle();
    TEXT_SwitchBuffers();

    // Check the input devices 
    INPUT_CheckDevices();

    // Pulse the memcard system
    MEMORY_UNIT_Update();

    // Setup display list
    s_DList = SMEM_BufferAlloc( s_DListSize );
    pDList = s_DList;

    // Update any File Reads from the FileReadQueue/
    ENG_UpdateFileReadQueue( );




    //x_printfxy(0,5,"TIME: %1.1f",1000*s_GSTimer.GetTime(0));

    // The PS2 library will reset the scissor region on its buffer swap, set it back
    s_2DClipL = 0;
    s_2DClipR = aaBuff.drawW-1;
    s_2DClipT = 0;
    s_2DClipB = aaBuff.drawH-1;
    s_2DClipDirty = TRUE;

    s_ClearScreen = ClearNewScreen;

    //---   the process of doing the page flip will reset the hardware render flags,
    //      make sure our settings match what is in the hardware
    s_RenderFlags   = ENG_ZBUFFER_TEST_OFF | ENG_ZBUFFER_FILL_ON | ENG_ALPHA_TEST_OFF | ENG_ALPHA_BLEND_OFF;


    PS2PERF_Pageflip();

    VRAM_Flush();
    PS2_InvalidateMicroCode();
}

//=========================================================================

void ENG_GetW2S( matrix4& pM )
{
    pM = s_MWorldToScreen;
}
//=========================================================================

void ENG_GetW2C( matrix4& pM )
{
    pM = s_MWorldToClip;
}

//=========================================================================

void ENG_GetC2S( matrix4& pM )
{
    pM = s_MClipToScreen;
}

//=========================================================================

struct SDirtyData
{
    radian saveXFOV;
    radian saveYFOV;
    radian saveClipXFOV;
    radian saveClipYFOV;
    s32 saveL;
    s32 saveT;
    s32 saveR;
    s32 saveB;
    f32 saveZN;
    f32 saveZF;
};

struct ClipRegion
{
    s32 L;
    s32 T;
    s32 R;
    s32 B;
    f32 ZN;
    f32 ZF;
};

static void CreateYFOV( view &s_View, ClipRegion &Screen, radian XFOV, radian &YFOV, SDirtyData &Savers )
{
    s_View.GetYFOV( YFOV );

    // crap cheese tweak to get square aspect ratio stuff to work on PS2
    //  SOMEBODY PLEASE FIX THIS INSANITY!
    if (XFOV == YFOV)
        YFOV *= 0.5f;

    Savers.saveXFOV = XFOV;
    Savers.saveYFOV = YFOV;
    Savers.saveL = Screen.L;
    Savers.saveT = Screen.T;
    Savers.saveR = Screen.R;
    Savers.saveB = Screen.B;
    Savers.saveZN = Screen.ZN;
    Savers.saveZF = Screen.ZF;
}

static void CreateClipYFOV( view &s_View, ClipRegion &Screen, radian XFOV, radian &YFOV, SDirtyData &Savers )
{
    s_View.GetClipYFOV( YFOV );

    Savers.saveClipXFOV = XFOV;
    Savers.saveClipYFOV = YFOV;
}

static void BuildMV2C( matrix4 &MV2C, ClipRegion &Clip, radian XFOV, radian YFOV, f32 ViewScale )
{
    radian Height = (1.0f / x_tan( YFOV * 0.5f ));
    radian Width = (1.0f / x_tan( XFOV * 0.5f ));

    MV2C.Identity();
    MV2C.M[0][0] = -(1.0f/ViewScale) * Width;
    MV2C.M[1][1] =  (1.0f/ViewScale) * Height;
    MV2C.M[2][2] = (Clip.ZF+Clip.ZN)/(Clip.ZF-Clip.ZN);
    MV2C.M[3][2] = (-2.0f*Clip.ZN*Clip.ZF)/(Clip.ZF-Clip.ZN);
    MV2C.M[2][3] = 1.0f;
    MV2C.M[3][3] = 0.0f;
}

static void BuildMC2S( matrix4 &MC2S, ClipRegion &Clip, f32 ZScale, radian XFOV, radian YFOV, f32 VS )
{
    f32 W = (Clip.R-Clip.L)*0.5f;
    f32 H = (Clip.B-Clip.T)*0.5f;

    MC2S.Identity();
    MC2S.M[0][0] =  (VS)*W;
    MC2S.M[1][1] = -(VS)*H;
    MC2S.M[3][3] = 1.0f;
    MC2S.M[3][0] = W + Clip.L + (f32)s_WindowLeft;
    MC2S.M[3][1] = H + Clip.T + (f32)s_WindowTop;
    MC2S.M[2][2] = -ZScale*0.5f;
    MC2S.M[3][2] = ZScale*0.5f;
}

static f32 CalcZScale()
{
    /*
    f32 temp1 = 16.f + ((27.f-16.f));//*(g_EngineFog.fStart/30000.0f));
    f32 temp2 = x_floor( temp1 );
    f32 temp3 = temp2 + 1.f;
    f32 temp4 = (f32)(1<<(s32)temp2);
    f32 temp5 = (f32)(1<<(s32)temp3);
    return( temp4 + ((temp5-temp4) * (temp1-temp2)) );
    */
    if (aaBuff.zPSM == SCE_GS_PSMZ16 || aaBuff.zPSM == SCE_GS_PSMZ16S)
        return (f32)(1<<14);
    else
        return (f32)(1<<27);
}

f32 s_fEyeTweak = 1.0f;
void ENG_SetActiveView( const view& View )
{
    static matrix4      MV2C;
    static matrix4      MC2S;
    static SDirtyData   Savers = {0,0,0,0,0,0,0,0};
    static f32          ZScale = 0.0f;
    static f32          fogStart = -994253.00125f;      // bogus start value
    matrix4             MW2V;
    radian              XFOV;
    radian              YFOV;
    radian              ClipXFOV;
    radian              ClipYFOV;
    xbool               bDirtyMV2C = FALSE;
    xbool               bDirtyMC2S = FALSE;

//    if (fogStart != g_EngineFog.fStart)
    {
        ZScale = CalcZScale();
        fogStart = g_EngineFog.fStart;
    }

    //    
    // Copy view into active view and get ingredients
    //
    x_memcpy( &s_View, &View, sizeof(view));

    if (s_bGraphicsCheatActive_graphicsave)
    {
        vector3 pos;
        matrix4 orient;
        s_View.GetPosition( pos );
        s_View.GetOrientation( orient );
        vector3 offset( 0, 0, 1.0f );
        offset = orient * offset;
        offset.RotateY( R_90 );
        if (s_OddFrame)
            offset *= s_fEyeTweak;
        else
            offset *= -s_fEyeTweak;

        pos += offset;
        s_View.SetPosition( view::V_WORLD, pos );
        s_View.SetRotations( view::V_WORLD, orient );
    }


    //
    // Get viewport bounds and other info
    //
    ClipRegion Clip;//( L, T, R, B, ZN, ZF );
    s_View.GetViewport  ( Clip.L, Clip.T, Clip.R, Clip.B );
    s_View.GetZLimits   ( Clip.ZN, Clip.ZF );
    s_View.GetXFOV      ( XFOV );
    s_View.GetClipXFOV  ( ClipXFOV );

    // Get half height YFOV, but only if something has changed
    if (       XFOV != Savers.saveXFOV 
        || ClipXFOV != Savers.saveClipXFOV
        ||  Clip.ZN != Savers.saveZN 
        ||  Clip.ZF != Savers.saveZF
        ||   Clip.L != Savers.saveL 
        ||   Clip.T != Savers.saveT 
        ||   Clip.R != Savers.saveR 
        ||   Clip.B != Savers.saveB) 
    {
        CreateYFOV( s_View, Clip, XFOV, YFOV, Savers );
        CreateClipYFOV( s_View, Clip, ClipXFOV, ClipYFOV, Savers );

        bDirtyMV2C = TRUE;
        bDirtyMC2S = TRUE;
    }
    else
    {
        YFOV = Savers.saveYFOV;
        ClipYFOV = Savers.saveClipYFOV;
    }

    //
    // Build world to view matrix
    //
    s_View.GetW2VMatrix ( MW2V );

    //
    // Build view to clip matrix.  All components map
    // into (-1,+1) cube after W division
    //
    if (bDirtyMV2C)
    {
        BuildMV2C( MV2C, Clip, XFOV, YFOV, 1.0f );
    }

    //    
    // Build clip to screen matrix.  Takes (-1,+1) cube
    // and maps to viewport.  Z gets mapped NZ=1.0, FZ=0.0
    //
    if (bDirtyMC2S)
    {
        BuildMC2S( MC2S, Clip, ZScale, XFOV, YFOV, 1.0f );
    }

    //  
    // Build final matrices
    //
    s_MWorldToView      = MW2V;
    s_MWorldToClip      = MV2C * s_MWorldToView;
    s_MClipToScreen     = MC2S;
    s_MWorldToScreen    = s_MClipToScreen * s_MWorldToClip;

    ENG_Set2DClipArea( Clip.L, Clip.T, Clip.R, Clip.B );
}

//=========================================================================

view*   ENG_GetActiveView( void )
{
    return( &s_View );
}

//==========================================================================

void    ENG_Set2DClipArea( s32  L, s32  T, s32  R, s32  B )
{
    xbool bSetScissor = FALSE;

    if ( (s_2DClipL != L) ||
         (s_2DClipT != T) ||
         (s_2DClipR != R) ||
         (s_2DClipB != B) )
    {
        if ( s_InsideRenderMode )
        {
            bSetScissor = TRUE;
        }
        else
        {
            s_2DClipDirty = TRUE;
        }
    }

    if ( L < 0 )        L = 0;
    if ( L >= s_XRes )  L = aaBuff.drawW-1;

    if ( T < 0 )        T = 0;
    if ( T >= s_YRes )  T = aaBuff.drawH-1;

    if ( R < 0 )        R = 0;
    if ( R >= s_XRes )  R = aaBuff.drawW-1;

    if ( B < 0 )        B = 0;
    if ( B >= s_YRes )  B = aaBuff.drawH-1;


    s_2DClipL = L;
    s_2DClipT = T;
    s_2DClipR = R;
    s_2DClipB = B;

    if ( bSetScissor )
    {
        SetScissorRegion();
    }
}

//=========================================================================

void    ENG_Get2DClipArea( s32& L, s32& T, s32& R, s32& B )
{
    L = s_2DClipL;
    T = s_2DClipT;
    R = s_2DClipR;
    B = s_2DClipB;
}

//=========================================================================

void    ENG_SetActiveLighting( const lighting& Lighting, s32 iSet )
{
    s32 i;
    if (iSet >= ENG_LIGHTING_MAX_LEVELS)
        iSet = ENG_LIGHTING_MAX_LEVELS - 1;
    else if (iSet < 0)
        iSet = 0;

    // Copy lighting for engine use
    s_ActiveLighting[ iSet ] = Lighting;

    // Setup lighting direction matrix.  If you push an xyz1 normal vector 
    // through this matrix you will get the 3 intensities for the three
    // directional lights in xyz and a 1.0 in the w for ambient
    s_LightingDir[ iSet ].Zero();
    s_LightingColor[ iSet ].Zero();

    for( i=0; i<3;  i++ )
    {
        if( s_ActiveLighting[ iSet ].Directional[i].Active )
        {
            // Setup lighting direction for this light
            vector3* pD;
            pD = &s_ActiveLighting[ iSet ].Directional[i].Direction;
            s_LightingDir[ iSet ].M[0][i] = pD->X;
            s_LightingDir[ iSet ].M[1][i] = pD->Y;
            s_LightingDir[ iSet ].M[2][i] = pD->Z;

            // Setup lighting color for this light
            color* pC;
            pC = &s_ActiveLighting[ iSet ].Directional[i].Color;
            s_LightingColor[ iSet ].M[i][0] = (f32)pC->R;
            s_LightingColor[ iSet ].M[i][1] = (f32)pC->G;
            s_LightingColor[ iSet ].M[i][2] = (f32)pC->B;
            s_LightingColor[ iSet ].M[i][3] = (f32)pC->A;
        }
    }
    s_LightingDir[ iSet ].M[3][3] = 1.0f;
    s_LightingColor[ iSet ].M[3][0] = (f32)s_ActiveLighting[ iSet ].Ambient.R;
    s_LightingColor[ iSet ].M[3][1] = (f32)s_ActiveLighting[ iSet ].Ambient.G;
    s_LightingColor[ iSet ].M[3][2] = (f32)s_ActiveLighting[ iSet ].Ambient.B;
    s_LightingColor[ iSet ].M[3][3] = (f32)s_ActiveLighting[ iSet ].Ambient.A;
}

//=========================================================================

void ENG_GetLightDirAndColor( matrix4& LDir, matrix4& LColor, s32 iSet )
{
    if (iSet >= ENG_LIGHTING_MAX_LEVELS)
        iSet = ENG_LIGHTING_MAX_LEVELS - 1;
    else if (iSet < 0)
        iSet = 0;
    LDir = s_LightingDir[ iSet ];
    LColor = s_LightingColor[ iSet ];
}

//=========================================================================

void    ENG_GetActiveLighting( lighting& Lighting, s32 iSet )
{
    if (iSet >= ENG_LIGHTING_MAX_LEVELS)
        iSet = ENG_LIGHTING_MAX_LEVELS - 1;
    else if (iSet < 0)
        iSet = 0;
    Lighting = s_ActiveLighting[ iSet ];
}

//=========================================================================

void ENG_StartDList( s32 Path )
{
    Path = 0;
    s_DListTaskStart = pDList;
}

//=========================================================================

void ENG_EndDList( s32 Path )
{
    DMAMAN_EndDList();
    DMAMAN_NewTask( Path, s_DListTaskStart );
}

//=========================================================================

void    ENG_BeginRenderMode( void )
{
    static s32 s_LastFrameCleared = -1;

    ASSERT( !s_InsideRenderMode );
    s_InsideRenderMode = TRUE;
    ENG_StartDList( PATH_VIF1 );

    // If this is the first BeginRenderMode() of this frame, reset the
    // states and clear the screen.
    if ( s_LastFrameCleared != s_Frame )
    {
        s_LastFrameCleared = s_Frame;
        PS2_ResetToDefaultStates();
        if ( s_ClearScreen )
        {
            PS2_ClearScreen(color(0,0,0,0));
        }
    }

    ENG_EnableRGBAChannels( TRUE, TRUE, TRUE, FALSE );
    if ( s_2DClipDirty )
        SetScissorRegion();
}

//=========================================================================

void    ENG_EndRenderMode( void )
{
    ASSERT( s_InsideRenderMode );
    s_InsideRenderMode = FALSE;
    ENG_EndDList( PATH_VIF1 );
}

//=========================================================================

xbool   ENG_GetRenderMode( void )
{
    return( s_InsideRenderMode );
}

//=========================================================================

void    ENG_FillScreenArea( s32 Area, color Color )
{
    ENG_SetRenderFlags( ENG_ZBUFFER_TEST_OFF |
                        ENG_ZBUFFER_FILL_OFF |
                        ENG_ALPHA_TEST_OFF   |
                        ENG_ALPHA_BLEND_OFF);

    DRAW_SetMode( DRAW_2D |
                  DRAW_FILL |
                  DRAW_NO_TEXTURE |
                  DRAW_ALPHA |
                  DRAW_NO_ZBUFFER |
                  DRAW_NO_CLIP |
                  DRAW_NO_LIGHT );

    switch( Area )
    {
    case ENG_AREA_SCREEN:
        {
            s32 Width, Height;
            ENG_GetResolution( Width, Height );
            DRAW_Rectangle( 0.0f, 0.0f, 1.0f, (f32)Width, (f32)Height, Color, Color, Color, Color );
        }
        break;
    case ENG_AREA_2D_CLIP:
        {
            s32 L, T, R, B;
            ENG_Get2DClipArea( L, T, R, B );
            DRAW_Rectangle( (f32)L, (f32)T, 1.0f, (f32)(R-L+1), (f32)(B-T+1), Color, Color, Color, Color );
        }
        break;
    case ENG_AREA_3D_VIEWPORT:
        {
            view*   pView;
            s32     L, T, R, B;

            pView = ENG_GetActiveView();
            pView->GetViewport( L, T, R, B ); 
            DRAW_Rectangle( (f32)L, (f32)T, 1.0f, (f32)(R-L), (f32)(B-T), Color, Color, Color, Color );
        }
        break;
    default:
        ASSERT( FALSE );
        break;
    }
}

//=========================================================================

void    ENG_FillZBufferArea( s32 Area, f32   Depth )
{
    sceDmaTag*  pDMA;
    sceGifTag*  pGIF;
    u32*        pVIF;
    u32*        pColor;
    s32*        pV;
    vector2     Verts[2];
    s32         i;

    switch( Area )
    {
    case ENG_AREA_SCREEN:
        {
            s32 Width, Height;
            ENG_GetResolution( Width, Height );
            Verts[0].Set( 0.0f, 0.0f );
            Verts[1].Set( (f32)Width, (f32)Height );
        }
        break;
    case ENG_AREA_2D_CLIP:
        {
            s32 L, T, R, B;
            ENG_Get2DClipArea( L, T, R, B );
            Verts[0].Set( (f32)L, (f32)T );
            Verts[1].Set( (f32)R, (f32)B );
        }
        break;
    case ENG_AREA_3D_VIEWPORT:
        {
            view*   pView;
            s32     L, T, R, B;
            pView = ENG_GetActiveView();
            pView->GetViewport( L, T, R, B ); 
            Verts[0].Set( (f32)L, (f32)T );
            Verts[1].Set( (f32)R, (f32)B );
        }
        break;
    }

    ENG_SetRenderFlags( ENG_ZBUFFER_TEST_OFF |
                        ENG_ZBUFFER_FILL_ON  |
                        ENG_ALPHA_TEST_OFF   |
                        ENG_ALPHA_BLEND_ON );
    ENG_SetBlendMode( ENG_BLEND_DEST );

    //---   build the dma tag
    pDMA = (sceDmaTag*)pDList;
    DMAHELP_BuildTagCont( pDMA, 6 * 16 );
    pDList += sizeof(sceDmaTag);

    //---   build the vif unpack command
    pVIF = (u32*)pDList;
    pVIF[0] = 0;
    pVIF[1] = 0;
    pVIF[2] = 0;
    pVIF[3] = SCE_VIF1_SET_DIRECT( 5, 0 );
    pDList += sizeof(u32) * 4;

    //---   build the gif command
    pGIF = (sceGifTag*)pDList;
    VIFHELP_BuildGifTag1( pGIF,
                          VIFHELP_GIFMODE_PACKED,
                          2,
                          2,
                          TRUE,
                          VIFHELP_GIFPRIMTYPE_SPRITE,
                          VIFHELP_GIFPRIMFLAGS_ALPHA,
                          TRUE );
    VIFHELP_BuildGifTag2( pGIF,
                          VIFHELP_GIFREG_RGBAQ, 
                          VIFHELP_GIFREG_XYZ2,
                          0,
                          0 );
    pDList += sizeof(sceGifTag);

    for ( i = 0; i < 2; i++ )
    {
        //---   build the color
        pColor = (u32*)pDList;
        pColor[0] = 0;
        pColor[1] = 0;
        pColor[2] = 0;
        pColor[3] = 128;
        pDList += sizeof(u32) * 4;

        //---   build the vert
        pV = (s32*)pDList;
        pV[0] = (s32)(Verts[i].X * 16.0f + 0.5f) + s_ScissorLeft;
        pV[1] = (s32)(Verts[i].Y * 16.0f + 0.5f) + s_ScissorTop;
        pV[2] = (s32)((1.0f - Depth) * (f32)(1<<24) + 0.5f) - 1;
        if ( pV[2] < 0 )
            pV[2] = 0;
        pV[3] = 1 << 4;
        pDList += sizeof(s32) * 4;
    }
}

//=========================================================================
s32 PS2_GetZBufferAddress( void )
{
    return aaBuff.zFBP;
}

//=========================================================================
s32 PS2_GetZBufferPSM( void )
{
    return aaBuff.zPSM;
}

//=========================================================================
s16 PS2_GetFrameBufferAddress( xbool bGetOppositeOffset )
{
    (void)bGetOppositeOffset;
    if (s_bGraphicsCheatActive && s_OddFrame)
        return aaBuff.drawSmall.frame1.FBP;
    return aaBuff.drawLarge.frame1.FBP;
}

//=========================================================================
s32 PS2_GetFrameBufferPSM( void )
{
    return aaBuff.drawLarge.frame1.PSM;
}

u64 PS2_GetFRAMESetting( void )
{
    if (s_bGraphicsCheatActive)
    {
        if (s_OddFrame)
            return( SCE_GS_SET_FRAME( (u32)PS2_GetFrameBufferAddress(), aaBuff.drawW/64, PS2_GetFrameBufferPSM(), 0x00FFF000 ) );
        else
            return( SCE_GS_SET_FRAME( (u32)PS2_GetFrameBufferAddress(), aaBuff.drawW/64, PS2_GetFrameBufferPSM(), 0x0000F0FF ) );
    }
    else
        return( SCE_GS_SET_FRAME( (u32)PS2_GetFrameBufferAddress(), aaBuff.drawW/64, PS2_GetFrameBufferPSM(), 0 ) );
}

//=========================================================================
s32 PS2_GetDisplayBufferAddress( void )
{
    return aaBuff.drawSmall.frame1.FBP;
}

//=========================================================================
s32 PS2_GetDisplayBufferPSM( void )
{
    return aaBuff.drawSmall.frame1.PSM;
}


//=========================================================================
void ENG_EnableRGBAChannels( xbool R, xbool G, xbool B, xbool A )
{
    u64*        pAD;
    u32*        pVIF;
    sceDmaTag*  pDMA;
    sceGifTag*  pGIF;
    s32         fbp;
    u32         Mask;

    ASSERT( ENG_GetRenderMode() );


    fbp = (s32)PS2_GetFrameBufferAddress( );

    //---   build the dma tag for this operation
    pDMA = (sceDmaTag*)pDList;
    DMAHELP_BuildTagCont( pDMA, 4*16 );
    pDList += sizeof(sceDmaTag);

    //---   set up the VIF command
    pVIF = (u32*)pDList;
    pVIF[0] = 0;
    pVIF[1] = 0;
    pVIF[2] = SCE_VIF1_SET_FLUSH( 0 );
    pVIF[3] = SCE_VIF1_SET_DIRECT( 3, 0 );
    pDList += sizeof(u32) * 4;

    //---   set up the GIF tag
    pGIF = (sceGifTag*)pDList;
    VIFHELP_BuildGifTag1( pGIF,
                          VIFHELP_GIFMODE_PACKED,
                          1,
                          2,
                          FALSE,
                          0,
                          0,
                          TRUE );
    VIFHELP_BuildGifTag2( pGIF, VIFHELP_GIFREG_AD, 0, 0, 0 );
    pDList += sizeof(sceGifTag);

    //---   set up the frame buffer with a new mask
    Mask = 0xffffffff;
    if ( A )    Mask &= ~0xff000000;
    if ( B )    Mask &= ~0x00ff0000;
    if ( G )    Mask &= ~0x0000ff00;
    if ( R )    Mask &= ~0x000000ff;

    pAD = (u64*)pDList;
    pAD[0] = 0;
    pAD[1] = SCE_GS_FINISH; // make sure any drawing operations are finished first
    pAD[2] = PS2_GetFRAMESetting();
    pAD[3] = SCE_GS_FRAME_1;
    pDList += sizeof(u64) * 4;
}

//==========================================================================

void    ENG_GetResolution( s32& Width, s32& Height )
{
    Width  = aaBuff.drawW;
    Height = aaBuff.drawH;
}

//=========================================================================

void    ENG_WaitForGraphicsSynch( void )
{
    // Wait for tasks in the current RunChains to finish    

    // grab some state track info
    s32 restoreState = ENG_GetRenderMode();

    // cap off the current BuildChains
    DMAHELP_BuildTagEnd( (sceDmaTag *)pDList, 0);
    pDList += sizeof( sceDmaTag );

    // and wait for them to finish
    while( !DMAMAN_AreTasksFinished() );

    // Now switch the BuildChains to be the new RunChains and execute
    // Writeback data from D-Cache to Memory 
    FlushCache(WRITEBACK_DCACHE);
    DMAMAN_ExecuteTasks();

    DMAHELP_BuildTagEnd( (sceDmaTag *)pDList, 0);
    pDList += sizeof( sceDmaTag );

    // and wait for them to finish as well
    while( !DMAMAN_AreTasksFinished() );

    // and start the render mode over again.
    if (restoreState)
    {
        s_InsideRenderMode = FALSE;
        ENG_BeginRenderMode();
    }
}

//=========================================================================

f32     ENG_GetFPS( void )
{
    return( 1 / s_FPSTimer.GetAvgTime() );
}

//=========================================================================

f64     ENG_GetRunTime( void )
{
    return( x_GetTime() - s_StartRunTime );
}

//=========================================================================

s32     ENG_GetPageFlipCount( void )
{
    return( s_Frame );
}

//=========================================================================

void ENG_GetPerfMetrics( s32& nCulled, s32& nClipped, s32& nTotal, f32& fXFOV, f32& fYFOV, f32& FPSTimer, f32& CPUTimer, f32& GFXTimer )
{
    PS2_GetClipMetrics( nCulled, nClipped, nTotal );
    s_View.GetClipXFOV( fXFOV );
    s_View.GetClipYFOV( fYFOV );
	FPSTimer = s_FPSTimer.GetAvgTime();
	CPUTimer = s_CPUTimer.GetAvgTime();
	GFXTimer = s_GSTimer.GetAvgTime();
}

//=========================================================================

void    PS2_PrepDListSize( s32 NBytes )
{
    ASSERT( NBytes >= MIN_DLIST_SIZE );
    s_DListSize = NBytes;
    s_RequestedDListSize = NBytes;
}

//=========================================================================

void ENG_PrintStats( void )
{
    //---   printf is much too slow on the USB to print this stuff up all the time
#ifdef TARGET_PS2_USB
    return;
#endif

    x_printf("-----------------------\n");
    x_printf("FRAME: %1d\n",s_Frame);
    x_printf("FPS:   %1.1f\n",ENG_GetFPS());
    x_printf("DLIST: %1d\n",s_DListSizeUsed);   
    x_printf("CPU:   %1.1f\n",1000.0f*s_CPUTimer.GetAvgTime());
    x_printf("GS:    %1.1f\n",1000.0f*s_GSTimer.GetAvgTime());
    x_printf("TOTAL: %1.1f\n",1000.0f*s_FPSTimer.GetAvgTime());
    x_printf("-----------------------\n");
    DMAMAN_PrintTaskStats();
}
//=========================================================================
static s32 matrix[16]=
{
    0, 1, 2, 3,
    2, 3, 0, 1,
    1, 0, 3, 2, 
    3, 2, 1, 0
//    3, 1, 0, 4, 0, 4, 2, 3, 4, 1, 2, 3, 3, 4, 2, 1
};
void PS2_ResetToDefaultStates()
{
    struct SResetStates
    {
        sceDmaTag   DMA;
        u32         VIF[4];
        sceGifTag   GIF;
        u64         Frame;
        u64         FrameAddr;
        u64         ZBuf;
        u64         ZBufAddr;
        u64         XYOffset;
        u64         XYOffsetAddr;
        u64         Scissor;
        u64         ScissorAddr;
        u64         PRModeCont;
        u64         PRModeContAddr;
        u64         ColClamp;
        u64         ColClampAddr;
        u64         DIMX;
        u64         DIMXAddr;
        u64         Dthe;
        u64         DtheAddr;
        u64         Test;
        u64         TestAddr;
        u64         Alpha;
        u64         AlphaAddr;
    };

    SResetStates* pPacket = (SResetStates*)pDList;
    pDList += sizeof(SResetStates);
    DMAHELP_BuildTagCont(&pPacket->DMA,sizeof(SResetStates)-sizeof(sceDmaTag));
    pPacket->VIF[0] = 0;
    pPacket->VIF[1] = 0;
    pPacket->VIF[2] = 0;
    pPacket->VIF[3] = SCE_VIF1_SET_DIRECT(11,0);
    VIFHELP_BuildGifTag1( &pPacket->GIF, VIFHELP_GIFMODE_PACKED, 1, 10, FALSE, 0, 0, TRUE );
    VIFHELP_BuildGifTag2( &pPacket->GIF, VIFHELP_GIFREG_AD, 0, 0, 0 );
    pPacket->Frame          = PS2_GetFRAMESetting();
    pPacket->FrameAddr      = SCE_GS_FRAME_1;
    pPacket->ZBuf           = SCE_GS_SET_ZBUF(aaBuff.zFBP, aaBuff.zPSM, 0);
    pPacket->ZBufAddr       = SCE_GS_ZBUF_1;
    pPacket->XYOffset       = SCE_GS_SET_XYOFFSET((2048-(aaBuff.drawW>>1))<<4, (2048-(aaBuff.drawH>>1))<<4);
    pPacket->XYOffsetAddr   = SCE_GS_XYOFFSET_1;
    pPacket->Scissor        = SCE_GS_SET_SCISSOR(0,aaBuff.drawW-1,0,aaBuff.drawH-1);
    pPacket->ScissorAddr    = SCE_GS_SCISSOR_1;
    pPacket->PRModeCont     = SCE_GS_SET_PRMODECONT(1);
    pPacket->PRModeContAddr = SCE_GS_PRMODECONT;
    pPacket->ColClamp       = SCE_GS_SET_COLCLAMP(1);
    pPacket->ColClampAddr   = SCE_GS_COLCLAMP;
    if (aaBuff.drawPSM == SCE_GS_PSMCT16 || aaBuff.drawPSM == SCE_GS_PSMCT16S)
        pPacket->Dthe           = SCE_GS_SET_DTHE( 1 );
    else
        pPacket->Dthe           = SCE_GS_SET_DTHE( 0 );

    pPacket->DtheAddr       = SCE_GS_DTHE;
    pPacket->DIMX           = SCE_GS_SET_DIMX( matrix[ 0 ],  matrix[ 1 ],  matrix[ 2 ],  matrix[ 3 ],
                                               matrix[ 4 ],  matrix[ 5 ],  matrix[ 6 ],  matrix[ 7 ],
                                               matrix[ 8 ],  matrix[ 9 ],  matrix[ 10 ], matrix[ 11 ],
                                               matrix[ 12 ], matrix[ 13 ], matrix[ 14 ], matrix[ 15 ] );
    pPacket->DIMXAddr       = SCE_GS_DIMX;
    pPacket->Test           = SCE_GS_SET_TEST(0,0x1,0,0,0,0,1,1);
    pPacket->TestAddr       = SCE_GS_TEST_1;
    pPacket->Alpha          = SCE_GS_SET_ALPHA(2,2,2,0,128);
    pPacket->AlphaAddr      = SCE_GS_ALPHA_1;
}

static const s32 kMaxStrips = 22;
void PS2_ClearScreen( color C, xbool bClearDisplay )
{
    const s32 kStripWidth = 32;

    s32 NumStrips =  0;
    if (bClearDisplay)
        NumStrips = aaBuff.dispW / kStripWidth;
    else
        NumStrips = aaBuff.drawW / kStripWidth;

    struct SStripRect
    {
        u64         XYZ0;
        u64         XYZ0Addr;
        u64         XYZ1;
        u64         XYZ1Addr;
    };

    struct SClearScreen
    {
        // This structure contains the necessary draw information to clear the
        // backbuffer and z-buffer. It is optimized to draw in vertical strips
        // that fit the pages in VRAM, avoiding page misses during the blit.
        sceDmaTag   DMA;
        u32         VIF[4];
        sceGifTag   GIF;
        u64         Frame;
        u64         FrameAddr;
        u64         XYOffset;
        u64         XYOffsetAddr;
        u64         Scissor;
        u64         ScissorAddr;
        u64         Prim;
        u64         PrimAddr;
        u64         RGBAQ;
        u64         RGBAQAddr;
        SStripRect  Strips[ kMaxStrips ];
    };


    // build the packet header info
    SClearScreen* pPacket = (SClearScreen*)pDList;
    pDList += sizeof(SClearScreen);
    x_memset( pPacket, 0, sizeof( SClearScreen ) );
    DMAHELP_BuildTagCont(&pPacket->DMA, sizeof(SClearScreen)-sizeof(sceDmaTag) );
    DMAHELP_BuildTagEnd( (sceDmaTag*)pDList, 0 );
    pPacket->VIF[0] = 0;
    pPacket->VIF[1] = 0;
    pPacket->VIF[2] = SCE_VIF1_SET_FLUSH( 0 );
    pPacket->VIF[3] = SCE_VIF1_SET_DIRECT(6+NumStrips*2,0);
    VIFHELP_BuildGifTag1( &pPacket->GIF, VIFHELP_GIFMODE_PACKED, 1, 5+NumStrips*2, FALSE, 0, 0, TRUE );
    VIFHELP_BuildGifTag2( &pPacket->GIF, VIFHELP_GIFREG_AD, 0, 0, 0 );
    if (bClearDisplay)
    {
        pPacket->Frame          = SCE_GS_SET_FRAME_1( aaBuff.dispFBP, aaBuff.dispW/64, aaBuff.dispPSM, 0 );
        pPacket->XYOffset       = SCE_GS_SET_XYOFFSET_1( (2048 - (aaBuff.dispW>>1))<<4, (2048 - (aaBuff.dispH>>1))<<4 );
        pPacket->Scissor        = SCE_GS_SET_SCISSOR_1( 0, aaBuff.dispW, 0, aaBuff.dispH );
    }
    else
    {
        pPacket->Frame          = PS2_GetFRAMESetting();
        pPacket->XYOffset       = SCE_GS_SET_XYOFFSET_1( (2048 - (aaBuff.drawW>>1))<<4, (2048 - (aaBuff.drawH>>1))<<4 );
        pPacket->Scissor        = SCE_GS_SET_SCISSOR_1( 0, aaBuff.drawW, 0, aaBuff.drawH );
    }
    pPacket->Prim           = SCE_GS_SET_PRIM( 0x6, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 );
    pPacket->RGBAQ          = SCE_GS_SET_RGBAQ( C.R>>1, C.G>>1, C.B>>1, 0, 0x3f800000 );

    pPacket->FrameAddr      = SCE_GS_FRAME_1;
    pPacket->PrimAddr       = SCE_GS_PRIM;
    pPacket->RGBAQAddr      = SCE_GS_RGBAQ;
    pPacket->XYOffsetAddr   = SCE_GS_XYOFFSET_1;
    pPacket->ScissorAddr    = SCE_GS_SCISSOR_1;

    // set up the strips
    s32 i;
    s32 x;
    s32 y;
    s32 width = kStripWidth<<4;
    s32 height;
    if (bClearDisplay)
    {
        x = (2048 - (aaBuff.dispW>>1))<<4;
        y = (2048 - (aaBuff.dispH>>1))<<4;
        height = aaBuff.dispH<<4;
    }
    else
    {
        x = (2048 - (aaBuff.drawW>>1))<<4;
        y = (2048 - (aaBuff.drawH>>1))<<4;
        height = aaBuff.drawH<<4;
    }
    for ( i = 0; i < NumStrips; i++ )
    {
        pPacket->Strips[i].XYZ0     = SCE_GS_SET_XYZ( x, y, 0 );
        pPacket->Strips[i].XYZ0Addr = SCE_GS_XYZ2;
        pPacket->Strips[i].XYZ1     = SCE_GS_SET_XYZ( x + width, y + height, 0 );
        pPacket->Strips[i].XYZ1Addr = SCE_GS_XYZ2;

        x += width;
    }
}

///////////////////////////////////////////////////////////////////////////
//
//  IRX DEFINES
//
//  The location of the IRX files depend on the target.  
//
///////////////////////////////////////////////////////////////////////////


#ifdef TARGET_PS2_DVD

    #define HOST_PREFIX "cdrom0:"
    #define SCE_PATH    ""
    #define IRX_PATH    "\\SYSTEM"

#else // !TARGET_PS2_DVD

    #ifdef TARGET_PS2_USB
        extern char HostPrefix[];
        #define HOST_PREFIX HostPrefix
    #else  // !TARGET_PS2_USB
        #define HOST_PREFIX "host0:"
    #endif  // TARGET_PS2_USB

    #define SCE_PATH "\\tnt\\3rdparty\\ps2\\sce"
    #define IRX_PATH "\\iop\\modules"

#endif  // TARGET_PS2_DVD

static const char* ScePath = SCE_PATH;

//=========================================================================

void PS2_Prep3rdPartyDirectory( const char* dir )
{
    ScePath = dir;
}

//=========================================================================

static xbool LoadSystemIRXFilesFromBinary( void )
{
//  Steps:
//  -Open bundled IRX file (COREIRX.bin)
//  -Get filesize, allocate load buffer, load entire file
//  -Calculate sizes of IRXs for DMA, as well as max size for
//      destination DMA buffer on IOP side
//  -Allocate buffer on IOP for DMA destination of IRX modules
//  -Then for each IRX:
//      -Setup DMA
//      -Wait for DMA to finish
//      -Call sceSifLoadModuleBuffer to initialize the IRX
//  -Cleanup

    // Structs used in bundled IRX file
    struct IRXBinHeader
    {
        s32 NFiles;
    };

    struct IRXBinFileInfo
    {
        char FName[32];
        u32  Offset;
    };

    s32     i;
    s32     Ret;
    s32     NFiles;
    s32     FileSize;
//    s32     MaxIRXSize;
    u32     dmaID;
    byte*   pIRXBin;
    void*   pIOPLoadBuffer;
    char    IRXBinFilename[255];
    X_FILE* pIRXBinFile;
    s32     IRXSizes[32];

    IRXBinFileInfo* pIRXInfo;
    sceSifDmaData   dmaData;


    // Make the filename for the bundled irx file, and try to open it
    x_sprintf( IRXBinFilename, "%s%s\\COREIRX.BIN", ScePath, IRX_PATH );

    pIRXBinFile = x_fopen( IRXBinFilename, "rb" );

    if( pIRXBinFile == NULL )
    {
        x_printf( "Failed to open %s\n", IRXBinFilename );
        return FALSE;
    }

    // Get the filesize to load in, and allocate space for the load buffer
    x_fseek( pIRXBinFile, 0, X_SEEK_END );
    FileSize = x_ftell( pIRXBinFile );
    x_fseek( pIRXBinFile, 0, X_SEEK_SET );

    pIRXBin = (byte*)x_malloc_top( FileSize );

    if( pIRXBin == NULL )
    {
        x_printf( "Failed to allocated %ld bytes for irx load buffer\n", FileSize );
        x_fclose( pIRXBinFile );
        return FALSE;
    }

    // Read in irx's
    x_fread( pIRXBin, FileSize, 1, pIRXBinFile );
    x_fclose( pIRXBinFile );
    pIRXBinFile = NULL;

    NFiles   = ((IRXBinHeader*)pIRXBin)->NFiles;
    pIRXInfo = (IRXBinFileInfo*)(pIRXBin + sizeof(IRXBinHeader));

    if( NFiles <= 0 || NFiles >= 31 )
    {
        x_printf( "Warning: IRX bundle file count error.\n" );
        x_free( pIRXBin );
        return FALSE;
    }

    // Calculate IRX sizes
    IRXSizes[NFiles-1] = FileSize - pIRXInfo[NFiles-1].Offset;

    for( i = 0; i < (NFiles-1); i++ )
        IRXSizes[i] = pIRXInfo[i+1].Offset - pIRXInfo[i].Offset;

    // Calculate the max IRX size for buffer in IOP
/*    MaxIRXSize = IRXSizes[0];
    for( i = 1; i < NFiles; i++ )
    {
        if( MaxIRXSize < IRXSizes[i] )
            MaxIRXSize = IRXSizes[i];
    }
*/
    // Allocate load buffer on IOP
    sceSifInitIopHeap();

//    pIOPLoadBuffer = sceSifAllocIopHeap( MaxIRXSize );
    pIOPLoadBuffer = sceSifAllocIopHeap( FileSize );

    if( pIOPLoadBuffer == NULL )
    {
//        x_printf( "Warning: Couldn't allocate IOP memory, %ld bytes.\n", MaxIRXSize );
        x_printf( "Warning: Couldn't allocate IOP memory, %ld bytes.\n", FileSize );
        x_free( pIRXBin );
        return FALSE;
    }
/*
    // Load the individual IRX's into IOP
    for( i = 0; i < NFiles; i++ )
    {
        x_printf( "Loading %s.irx\n", pIRXInfo[i].FName );

        // Send IRX module data to IOP
        dmaData.data = (unsigned int) (pIRXBin + pIRXInfo[i].Offset);
        dmaData.addr = (unsigned int) pIOPLoadBuffer;
        dmaData.size = IRXSizes[i];
        dmaData.mode = 0;

        dmaID = sceSifSetDma( &dmaData, 1 );

        while( (Ret = sceSifDmaStat( dmaID )) >= 0 )
        {
            // wait for dma to complete
        }

        while( (Ret = sceSifLoadModuleBuffer(pIOPLoadBuffer, 0, NULL)) < 0 )
        {
            x_printf( "Can't load module %s.irx [%08X (%ld)]\n", pIRXInfo[i].FName, Ret, Ret );
        }
    }
*/
    // Send IRX module data to IOP
    dmaData.data = (unsigned int) pIRXBin;
    dmaData.addr = (unsigned int) pIOPLoadBuffer;
    dmaData.size = FileSize;
    dmaData.mode = 0;

    dmaID = sceSifSetDma( &dmaData, 1 );

    // Load the individual IRX's into IOP
    for( i = 0; i < NFiles; i++ )
    {
        //x_printf( "Loading %s.irx\n", pIRXInfo[i].FName );

        while( (Ret = sceSifLoadModuleBuffer((void*)((u32)pIOPLoadBuffer + pIRXInfo[i].Offset), 0, NULL)) < 0 )
        {
            x_printf( "Can't load module %s.irx [%08X (%ld)]\n", pIRXInfo[i].FName, Ret, Ret );
        }
    }

    // Cleanup
    sceSifFreeIopHeap( pIOPLoadBuffer );

    x_free( pIRXBin );
    pIRXBin = NULL;

    return TRUE;
}

//=========================================================================

static
xbool LoadSystemIRXFiles( void )
{
    char    Sio2ManIrx[255];
    char    MTapManIrx[255];
    char    McManIrx[255];
    char    McServIrx[255];
    char    PadManIrx[255];
    char    CdvdStmIrx[255];
    char    USBDIrx[255];
    char    LG_AUDIrx[255];

    //---   set IRX file strings.  NOTE: file names must be capitalized for TARGET_PS2_DVD to work
    x_sprintf( Sio2ManIrx,  "%s%s%s\\SIO2MAN.IRX",  HOST_PREFIX, ScePath, IRX_PATH );
    x_sprintf( MTapManIrx,  "%s%s%s\\MTAPMAN.IRX",  HOST_PREFIX, ScePath, IRX_PATH );
    x_sprintf( McManIrx,    "%s%s%s\\MCMAN.IRX",    HOST_PREFIX, ScePath, IRX_PATH );
    x_sprintf( McServIrx,   "%s%s%s\\MCSERV.IRX",   HOST_PREFIX, ScePath, IRX_PATH );
    x_sprintf( PadManIrx,   "%s%s%s\\PADMAN.IRX",   HOST_PREFIX, ScePath, IRX_PATH );
    x_sprintf( CdvdStmIrx,  "%s%s%s\\CDVDSTM.IRX",  HOST_PREFIX, ScePath, IRX_PATH );
    x_sprintf( USBDIrx,     "%s%s%s\\USBD.IRX",     HOST_PREFIX, ScePath, IRX_PATH );
    x_sprintf( LG_AUDIrx,   "%s%s%s\\LGAUD.IRX",    HOST_PREFIX, ScePath, IRX_PATH );


#ifdef EXCEPTION_CONTEXT_DUMP
    x_sprintf( FinalPanicIrx, "%s%s%s\\PANICSYS.IRX", HOST_PREFIX, ScePath, IRX_PATH );
#endif

#ifndef TARGET_PS2_DVD
    // No need to call sceSifInitRpc(0); for a DVD version
    // if the target uses CDDVD.  The PS2CD_Boot function makes
    // the call before this point in the execution
    sceSifInitRpc(0);
#endif

    s32 Ret;

//    if( LoadSystemIRXFilesFromBinary() == FALSE )
    {
        x_printf("Loading Sio2man [%s]\n",Sio2ManIrx);
        while( (Ret=sceSifLoadModule(Sio2ManIrx, 0, NULL)) < 0)
        {
            x_printf("Can't load module %s [%08X (%ld)]\n", Sio2ManIrx,Ret,Ret);
        }

        x_printf("Loading MTapMan [%s]\n",MTapManIrx);
        while( (Ret=sceSifLoadModule(MTapManIrx, 0, NULL)) < 0)
        {
            x_printf("Can't load module mtapman [%08X (%ld)]\n",Ret,Ret);
        }

        x_printf("Loading MCMan [%s]\n",McManIrx);
        while( (Ret=sceSifLoadModule(McManIrx, 0, NULL)) < 0)
        {
            x_printf("Can't load module mcman [%08X (%ld)]\n",Ret,Ret);
        }

        x_printf("Loading MCServ [%s]\n",McServIrx);
        while( (Ret=sceSifLoadModule(McServIrx, 0, NULL)) < 0)
        {
            x_printf("Can't load module mcserv [%08X (%ld)]\n",Ret,Ret);
        }

        x_printf("Loading PadMan [%s]\n",PadManIrx);
        while( (Ret=sceSifLoadModule(PadManIrx, 0, NULL)) < 0)
        {
            x_printf("Can't load module padman [%08X (%ld)]\n",Ret,Ret);
        }

        x_printf("Loading CdvdStmIrx [%s]\n",CdvdStmIrx);
        while( (Ret=sceSifLoadModule(CdvdStmIrx, 0, NULL)) < 0)
        {
            x_printf("Can't load module CdvdStmIrx [%08X (%ld)]\n",Ret,Ret);
        }

        x_printf("Loading USBD [%s]\n",USBDIrx);
        while( (Ret=sceSifLoadModule(USBDIrx, 0, NULL)) < 0)
        {
            x_printf("Can't load module usbd [%08X (%ld)]\n",Ret,Ret);
        }

        x_printf("Loading Logitech Headset Audio Library [%s]\n", LG_AUDIrx);
        while( (Ret=sceSifLoadModule(LG_AUDIrx, 0, NULL)) < 0)
        {
            x_printf("Can't load module usbd [%08X (%ld)]\n",Ret,Ret);
        }
    }


    if (0 != sceMcInit())
    {
        x_printf("Could not init mc\n");
        return FALSE;
    }

    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//  EXCEPTION CONTEXT DUMP CODE
////////////////////////////////////////////////////////////////////////////
#ifdef EXCEPTION_CONTEXT_DUMP

//EXCEPTION crap
#define SCREEN_WIDTH    640
#define SCREEN_HEIGHT   224
#define OFFX        (((4096-SCREEN_WIDTH)/2)<<4)
#define OFFY        (((4096-SCREEN_HEIGHT)/2)<<4)
#define MAXWIDTH    (77)
#define MAXHEIGHT   (44)

#define UNCACHED         (0x20000000)

sceGsDBuff db;
sceExcepIOPExceptionData iop;

const char *ExceptionCode[]={
    "Interrupt",
    "TLB modification exception",
    "TLB exception (load or instruction fetch)",
    "TLB exception (store)",
    "Address error exception (load or instruction fetch)",
    "Address error exception (store)",
    "Bus error exception (data reference: load or store)",
    "Syscall exception",
    "Breakpint exception",
    "Reserved instruction exception",
    "Coprocessor Unusable exception",
    "Arithmetic overflow exception",
    "Trap exception"
};

//=========================================================================
void ExceptionInitGS(void)
{
    sceVif1Packet   packet;
    sceDmaEnv       env;
    sceDmaChan      *p1;
    u_long      giftagAD[2] = { SCE_GIF_SET_TAG(0, 1, 0, 0, 0, 1), 0x000000000000000eL };
    long128     buff[10];

    sceGsResetPath();
    sceDmaReset(1);

    sceVif1PkInit(&packet, (u_long128 *)((u_int)buff | UNCACHED) );

    sceDmaGetEnv(&env);
    env.notify = 1<<SCE_DMA_VIF1;
    sceDmaPutEnv(&env);

    p1 = sceDmaGetChan(SCE_DMA_VIF1);
    p1->chcr.TTE = 1;


    sceGsResetGraph(0, SCE_GS_INTERLACE, SCE_GS_NTSC, SCE_GS_FRAME);
    sceGsSetDefDBuff(&db, SCE_GS_PSMCT32, SCREEN_WIDTH, SCREEN_HEIGHT, SCE_GS_ZGEQUAL, SCE_GS_PSMZ24, SCE_GS_CLEAR);
    sceVif1PkReset(&packet);
    sceVif1PkCnt(&packet, 0);
    sceVif1PkOpenDirectCode(&packet, 0);
    sceVif1PkOpenGifTag(&packet, *(u_long128*)&giftagAD);

    sceVif1PkReserve(&packet, sceGsSetDefAlphaEnv((sceGsAlphaEnv *)packet.pCurrent,0) * 4);
    sceVif1PkCloseGifTag(&packet);
    sceVif1PkCloseDirectCode(&packet);
    sceVif1PkEnd(&packet, 0);
    sceVif1PkTerminate(&packet);

    // kick Gs initialize packet
    sceDmaSend(p1,(long128*)(((u_int)(packet.pBase)) & 0x8fffffff));
    // wait for Gs initialize packet end
    sceGsSyncPath(0,0);
//    while(!sceGsSyncV(0));  // display next in odd field when interlace
    // Waiting for the head of V-Blank 
    WaitSema(VSync_SemaID);
}

//=========================================================================
struct BigSpriteStruct
{
    sceGifTag   GifTag;
    u64         AD[ 12 ];
};

static BigSpriteStruct BigSprite;

void   EEExceptionHandler(u_int stat, u_int cause, u_int epc, u_int bva, u_int bpa, u_long128 *gpr)
{
//    int frame=0;

    ExceptionInitGS();

    sceExcepConsOpen(OFFX + (16<<4), OFFY + (15<<3), MAXWIDTH, MAXHEIGHT );

    db.clear0.rgbaq.R = 0x0;    // clear color for dbuf0
    db.clear0.rgbaq.G = 0x40;
    db.clear0.rgbaq.B = 0x80;
    pAAbuff->clearSmall.rgbaq.R = 0x0;
    pAAbuff->clearSmall.rgbaq.G = 0x40;
    pAAbuff->clearSmall.rgbaq.B = 0x80;
    pAAbuff->clearLarge.rgbaq.R = 0x0;
    pAAbuff->clearLarge.rgbaq.G = 0x40;
    pAAbuff->clearLarge.rgbaq.B = 0x80;

    db.clear1.rgbaq.R = 0x0;    // clear color for dbuf1
    db.clear1.rgbaq.G = 0x40;
    db.clear1.rgbaq.B = 0x80;
    scePrintf("*** EE Exception [%s] ***\n",ExceptionCode[(cause>>2)&31]);
    scePrintf("\n");

    scePrintf("stat=0x%08x cause=0x%08x epc=0x%08x bva=0x%08x bpa=0x%08x\n",stat,cause,epc,bva,bpa);
    scePrintf("\n");
    scePrintf("at  =0x%08x     v0-1=0x%08x,0x%08x \n",gpr[GPR_at],gpr[GPR_v0],gpr[GPR_v1]);
    scePrintf("\n");
    scePrintf("a0-3=0x%08x,0x%08x,0x%08x,0x%08x\n",gpr[GPR_a0],gpr[GPR_a1],gpr[GPR_a2],gpr[GPR_a3]);
    scePrintf("\n");
    scePrintf("t0-7=0x%08x,0x%08x,0x%08x,0x%08x,\n",gpr[GPR_t0],gpr[GPR_t1],gpr[GPR_t2],gpr[GPR_t3]);
    scePrintf("\n");
    scePrintf("     0x%08x,0x%08x,0x%08x,0x%08x\n",gpr[GPR_t4],gpr[GPR_t5],gpr[GPR_t6],gpr[GPR_t7]);
    scePrintf("\n");
    scePrintf("s0-7=0x%08x,0x%08x,0x%08x,0x%08x,\n",gpr[GPR_s0],gpr[GPR_s1],gpr[GPR_s2],gpr[GPR_s3]);
    scePrintf("\n");
    scePrintf("     0x%08x,0x%08x,0x%08x,0x%08x\n",gpr[GPR_s4],gpr[GPR_s5],gpr[GPR_s6],gpr[GPR_s7]);
    scePrintf("\n");
    scePrintf("t8-9=0x%08x,0x%08x     ",gpr[GPR_t8],gpr[GPR_t9]);
    scePrintf("\n");
    scePrintf("k0-1=0x%08x,0x%08x\n",gpr[GPR_k0],gpr[GPR_k1]);
    scePrintf("\n");
    scePrintf("gp=0x%08x sp=0x%08x fp=0x%08x ra=0x%08x\n",gpr[GPR_gp],gpr[GPR_sp],gpr[GPR_fp],gpr[GPR_ra]);

    //---   display the stack
    s32 i, j;
    sceExcepConsPrintf("\n-- STACK --\n");
    u32* pSP = (u32*)gpr[GPR_sp];
    for( i=0; i<8; i++ )
	{
        for( j=0; j<7; j++ )
		{
            sceExcepConsPrintf("0x%08x ", *pSP++);
		}
	}

    BigSpriteStruct *pSpriteStruct = &BigSprite;

    while(1)
    {
        VIFHELP_BuildGifTag1( &pSpriteStruct->GifTag, VIFHELP_GIFMODE_PACKED, 1, 6, FALSE, 0, 0, TRUE );
        VIFHELP_BuildGifTag2( &pSpriteStruct->GifTag, VIFHELP_GIFREG_AD, 0, 0, 0 );
        pSpriteStruct->AD[ 0 ] = 0;
        pSpriteStruct->AD[ 1 ] = SCE_GS_TEST_1;
        pSpriteStruct->AD[ 2 ] = SCE_GS_SET_FRAME_1( pAAbuff->drawFBP, (pAAbuff->drawW>>6)&0x3F, pAAbuff->drawPSM, 0 );
        pSpriteStruct->AD[ 3 ] = SCE_GS_FRAME_1;
        pSpriteStruct->AD[ 4 ] = SCE_GS_SET_PRIM( 6, 1, 0, 0, 0, 0, 0, 0, 0 );
        pSpriteStruct->AD[ 5 ] = SCE_GS_PRIM;
        pSpriteStruct->AD[ 6 ] = SCE_GS_SET_RGBAQ( 0x0, 0x00, 0x00, 0x7F, 0x3F800000 );
        pSpriteStruct->AD[ 7 ] = SCE_GS_RGBAQ;
        pSpriteStruct->AD[ 8 ] = SCE_GS_SET_XYZ2( 32768 - (pAAbuff->drawW<<3), 32768+(pAAbuff->drawW<<3), 1 );
        pSpriteStruct->AD[ 9 ] = SCE_GS_XYZ2;
        pSpriteStruct->AD[ 10 ] = SCE_GS_SET_XYZ2( 32768 + (pAAbuff->drawW<<3), 32768-(pAAbuff->drawW<<3), 1 );
        pSpriteStruct->AD[ 11 ] = SCE_GS_XYZ2;
        PutDownSampleSprite( &pSpriteStruct->GifTag );
        FlushCache(0);


        sceExcepConsLocate( 0, 0 );

        sceExcepConsPrintf("*** EE Exception [%s] ***\n",ExceptionCode[(cause>>2)&31]);
		sceExcepConsPrintf("\n");

        sceExcepConsPrintf("stat=0x%08X cause=0x%08X epc=0x%08X bva=0x%08X bpa=0x%08X\n",stat,cause,epc,bva,bpa);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("at  =0x%08X     v0-1=0x%08X,0x%08X \n",gpr[GPR_at],gpr[GPR_v0],gpr[GPR_v1]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("a0-3=0x%08X,0x%08X,0x%08X,0x%08X\n",gpr[GPR_a0],gpr[GPR_a1],gpr[GPR_a2],gpr[GPR_a3]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("t0-7=0x%08X,0x%08X,0x%08X,0x%08X,\n",gpr[GPR_t0],gpr[GPR_t1],gpr[GPR_t2],gpr[GPR_t3]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("     0x%08X,0x%08X,0x%08X,0x%08X\n",gpr[GPR_t4],gpr[GPR_t5],gpr[GPR_t6],gpr[GPR_t7]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("s0-7=0x%08X,0x%08X,0x%08X,0x%08X,\n",gpr[GPR_s0],gpr[GPR_s1],gpr[GPR_s2],gpr[GPR_s3]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("     0x%08X,0x%08X,0x%08X,0x%08X\n",gpr[GPR_s4],gpr[GPR_s5],gpr[GPR_s6],gpr[GPR_s7]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("t8-9=0x%08X,0x%08X     ",gpr[GPR_t8],gpr[GPR_t9]);
        sceExcepConsPrintf("k0-1=0x%08X,0x%08X\n",gpr[GPR_k0],gpr[GPR_k1]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("gp=0x%08X sp=0x%08X fp=0x%08X ra=0x%08X\n",gpr[GPR_gp],gpr[GPR_sp],gpr[GPR_fp],gpr[GPR_ra]);

        //---   display the stack
        sceExcepConsPrintf("\n-- STACK --\n");
        u32* pSP = (u32*)gpr[GPR_sp];
        for( i=0; i<8; i++ )
		{
			sceExcepConsPrintf("\n");
            for( j=0; j<7; j++ )
			{
                sceExcepConsPrintf("0x%08X ", *pSP++);
			}
		}

        iFlushCache( 0 );
        sceGsSyncPath( 0, 0 );

        // Waiting for the head of V-Blank
        WaitSema(VSync_SemaID);
        PutDrawBufferSmall( pAAbuff );
        PutDownSampleSprite( &pShrinkSprite->GIFtag );
        sceGsSyncPath(0,0);
        PutDispBuffer( pAAbuff, !s_OddFrame );
        PutDrawBufferLarge( pAAbuff );
        sceGsSyncPath(0,0);      
    }
}

//=========================================================================
void IOPExceptionHandler(void *p,void *d)
{
//    int frame=0;

    ExceptionInitGS();

    db.clear0.rgbaq.R = 0x00;
    db.clear0.rgbaq.G = 0x80;
    db.clear0.rgbaq.B = 0x00;
    pAAbuff->clearSmall.rgbaq.R = 0x0;
    pAAbuff->clearSmall.rgbaq.G = 0x80;
    pAAbuff->clearSmall.rgbaq.B = 0x0;
    pAAbuff->clearLarge.rgbaq.R = 0x0;
    pAAbuff->clearLarge.rgbaq.G = 0x80;
    pAAbuff->clearLarge.rgbaq.B = 0x0;

    db.clear1.rgbaq.R = 0x0;
    db.clear1.rgbaq.G = 0x80;
    db.clear1.rgbaq.B = 0x0;

    sceExcepConsOpen(OFFX + (16<<4), OFFY + (16<<3),MAXWIDTH ,MAXHEIGHT );

    BigSpriteStruct *pSpriteStruct = &BigSprite;

    while(1)
    {
        // Screen Clear with a sprite...
        VIFHELP_BuildGifTag1( &pSpriteStruct->GifTag, VIFHELP_GIFMODE_PACKED, 1, 6, FALSE, 0, 0, TRUE );
        VIFHELP_BuildGifTag2( &pSpriteStruct->GifTag, VIFHELP_GIFREG_AD, 0, 0, 0 );
        pSpriteStruct->AD[ 0 ] = 0;
        pSpriteStruct->AD[ 1 ] = SCE_GS_TEST_1;
        pSpriteStruct->AD[ 2 ] = SCE_GS_SET_FRAME_1( pAAbuff->drawFBP, (pAAbuff->drawW>>6)&0x3F, pAAbuff->drawPSM, 0 );
        pSpriteStruct->AD[ 3 ] = SCE_GS_FRAME_1;
        pSpriteStruct->AD[ 4 ] = SCE_GS_SET_PRIM( 6, 1, 0, 0, 0, 0, 0, 0, 0 );
        pSpriteStruct->AD[ 5 ] = SCE_GS_PRIM;
        pSpriteStruct->AD[ 6 ] = SCE_GS_SET_RGBAQ( 0x0, 0x00, 0x00, 0x7F, 0x3F800000 );
        pSpriteStruct->AD[ 7 ] = SCE_GS_RGBAQ;
        pSpriteStruct->AD[ 8 ] = SCE_GS_SET_XYZ2( 32768 - (pAAbuff->drawW<<3), 32768+(pAAbuff->drawW<<3), 1 );
        pSpriteStruct->AD[ 9 ] = SCE_GS_XYZ2;
        pSpriteStruct->AD[ 10 ] = SCE_GS_SET_XYZ2( 32768 + (pAAbuff->drawW<<3), 32768-(pAAbuff->drawW<<3), 1 );
        pSpriteStruct->AD[ 11 ] = SCE_GS_XYZ2;
        PutDownSampleSprite( &pSpriteStruct->GifTag );
        FlushCache(0);

        sceExcepConsLocate( 0, 0 );
        sceExcepConsPrintf("*** IOP Exception [%s] ***\n",ExceptionCode[(iop.reg[IOP_CAUSE]>>2)&31]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("Module [%s] Version [%02x.%02x] Offset [0x%08x]\n",iop.module ,(iop.version)>>8 ,(iop.version)&0xf,iop.offset); 
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("stat=0x%08x cause=0x%08x epc=0x%08x\n",iop.reg[IOP_SR] ,iop.reg[IOP_CAUSE], iop.reg[IOP_EPC]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("at  =0x%08x     v0-1=0x%08x,0x%08x \n",iop.reg[GPR_at],iop.reg[GPR_v0], iop.reg[GPR_v1]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("a0-3=0x%08x,0x%08x,0x%08x,0x%08x\n",iop.reg[GPR_a0], iop.reg[GPR_a1], iop.reg[GPR_a2], iop.reg[GPR_a3]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("t0-7=0x%08x,0x%08x,0x%08x,0x%08x,\n",iop.reg[GPR_t0], iop.reg[GPR_t1], iop.reg[GPR_t2], iop.reg[GPR_t3]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("     0x%08x,0x%08x,0x%08x,0x%08x\n",iop.reg[GPR_t4], iop.reg[GPR_t5], iop.reg[GPR_t6], iop.reg[GPR_t7]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("s0-7=0x%08x,0x%08x,0x%08x,0x%08x,\n",iop.reg[GPR_s0], iop.reg[GPR_s1], iop.reg[GPR_s2], iop.reg[GPR_s3]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("     0x%08x,0x%08x,0x%08x,0x%08x\n",iop.reg[GPR_s4], iop.reg[GPR_s5], iop.reg[GPR_s6], iop.reg[GPR_s7]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("t8-9=0x%08x,0x%08x     ",iop.reg[GPR_t8], iop.reg[GPR_t9]);
        sceExcepConsPrintf("k0-1=0x%08x,0x%08x\n",iop.reg[GPR_k0], iop.reg[GPR_k1]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("gp=0x%08x sp=0x%08x fp=0x%08x ra=0x%08x\n",iop.reg[GPR_gp], iop.reg[GPR_sp], iop.reg[GPR_fp], iop.reg[GPR_ra]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("hi=0x%08x lo=0x%08x sr=0x%08x epc =0x%08x\n",iop.reg[IOP_HI], iop.reg[IOP_LO], iop.reg[IOP_SR], iop.reg[IOP_EPC]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("cause=0x%08x tar=0x%08x badadr=0x%08x\n", iop.reg[IOP_CAUSE], iop.reg[IOP_TAR], iop.reg[IOP_BADVADDR]);
		sceExcepConsPrintf("\n");
        sceExcepConsPrintf("dcic=0x%08x bpc=0x%08x bpcm=0x%08x bda=0x%08x bpam=0x%08x\n",iop.reg[IOP_DCIC], iop.reg[IOP_BPC], iop.reg[IOP_BPCM], iop.reg[IOP_BDA], iop.reg[IOP_BDAM]);

        iFlushCache( 0 );
        sceGsSyncPath( 0, 0 );

        // Waiting for the head of V-Blank
        WaitSema(VSync_SemaID);
        PutDrawBufferSmall( pAAbuff );
        PutDownSampleSprite( &pShrinkSprite->GIFtag );
        sceGsSyncPath(0,0);
        PutDispBuffer( pAAbuff, !s_OddFrame );
        PutDrawBufferLarge( pAAbuff );
        sceGsSyncPath(0,0);      
    }
}

#endif //EXCEPTION_CONTEXT_DUMP


//=========================================================================

static void PS2_Print( const char* pString )
{
#ifdef _MSC_VER
    pString = NULL;     // This is here to surpress a warning.
#else
    printf( pString );
#endif
}

//==========================================================================

xbool QuagInit( void );
s32   QuagMain( s32 argc, char* argv[] );


int main( int argc, char* argv[] )
{
    xbool InitDone;
#ifdef __MWERKS__
    mwInit();
#endif

    // Call the application init function to allow application specific changes
    InitDone = QuagInit();

    //---   if the initialization has not been completed, init x_files now
    if( !InitDone )
        x_Init();

    PS2_InitialLoadScreen_Init();
#ifdef TARGET_PS2_DVD
    // Before anything happens, we need to load the latest system modules
    // if we are going to be using the DVD
    PS2CD_Boot();
    PS2_InitialLoadScreen_Pump();
#endif


    x_SetPrintHandlers( (print_fnptr)PS2_Print, (print_at_fnptr)TEXT_PrintStringAt );
    PS2_InitialLoadScreen_Pump();

#if defined( TARGET_PS2_DEV )
    PS2DEV_Interface();
    PS2_InitialLoadScreen_Pump();

#elif defined( TARGET_PS2_DVD )
    // If we are using the DVD, we need to initialize the file system.
    // This is done after the X-Files initialization because some functions
    // require the use of x-functions
    PS2CD_Init();           // Init the cd/dvd subsystem
    PS2CD_Interface();      // Interface the cd/dvd functions to the x_files
    PS2_CDUtilInit();
    PS2_InitialLoadScreen_Pump();

#elif defined( TARGET_PS2_USB )
    PS2USB_Init(argc,argv);
    PS2USB_Interface();
    PS2_InitialLoadScreen_Pump();
#endif

    LoadSystemIRXFiles();
    PS2_InitialLoadScreen_Pump();


#ifdef ENABLE_SN_PROFILER
    static u_long128 profdata[2048] __attribute__((aligned(128))); // quadword aligned, can be 2K
    // to 64K bytes
    sceSifInitRpc(0);
    // Load the SNProfil module
    char SNProjfilIrx[255];
    x_sprintf( SNProjfilIrx, "%s%s/iop/modules/SNProfil.irx", HOST_PREFIX, ScePath );

    if(sceSifLoadModule(SNProjfilIrx, 0, NULL) < 0)
    {
        x_printf("Can't load SNProfil module\n");
    }
    if(snProfInit(_4KHZ, profdata, sizeof(profdata)) != 0)
        x_printf("Profiler init failed\n"); // see SN_PRF in LIBSN.H
#endif

#ifdef EXCEPTION_CONTEXT_DUMP
    sceExcepSetDebugEEHandler(EEExceptionHandler);
    sceExcepSetDebugIOPHandler(FinalPanicIrx,IOPExceptionHandler, &iop);
#endif

#ifdef TARGET_PS2_DEMO
    sceCdMmode( SCECdCD );
#else
    sceCdMmode( SCECdDVD );
#endif
    PS2_InitialLoadScreen_Pump();

    SPRHELP_Initialize();
    PS2_InitialLoadScreen_Pump();

#ifndef __MWERKS__
    // Initialize the SN DLL System.
    if( snInitDllSystem(0) )
    {
        x_printf( "SN DLL System failed to initialize" );
        ASSERT( 0 );
    }
#endif
    PS2_InitialLoadScreen_Pump();

    PS2_InitialLoadScreen_Kill();
    QuagMain( argc, argv );
    x_Kill();

#if defined( TARGET_PS2_DVD )
    PS2_CDUtilKill();
    PS2CD_Kill();
#endif

    return( 0 );
}

void PS2_InitNonBlockingVSync( void )
{
    struct SemaParam sp;
    sp.initCount = 0;
    sp.maxCount = 1; 
    VSync_SemaID = CreateSema(&sp);
    VSync_HandleID = AddIntcHandler(INTC_VBLANK_S, VBlankStartHandler, 0 );
    EnableIntc(INTC_VBLANK_S);
    s_bUseNonBlockingVSync = TRUE;
}

void PS2_KillNonBlockingVSync( void )
{
    if (s_bUseNonBlockingVSync)
    {
        s_bUseNonBlockingVSync = FALSE;
	    DisableIntc(INTC_VBLANK_S);
        RemoveIntcHandler( INTC_VBLANK_S, VSync_HandleID );
        DeleteSema( VSync_SemaID );
    }
}

xbool PS2_IsNonBlockingVSync( void )
{
    return s_bUseNonBlockingVSync;
}


//=========================================================================
//=========================================================================
//=========================================================================

u8 ps2_load_texture[] __attribute__((aligned(16))) = 
{
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    0x00, 0x40, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
    0x80, 0x00, 0x80, 0x00, 0x80, 0x00, 0x80, 0x00,    0xFF, 0xFF, 0x77, 0x00, 0xFF, 0x16, 0x01, 0x00,
    0xFE, 0xFF, 0xFF, 0xCF, 0xFF, 0xFF, 0xFF, 0xCF,    0xFF, 0xFF, 0xFF, 0xCF, 0xFF, 0x8D, 0xFF, 0xCF,
    0xFF, 0xFE, 0xFF, 0xC0, 0xFF, 0xFF, 0xFF, 0x54,    0xFF, 0xFF, 0xFF, 0x54, 0xFF, 0xFF, 0xFF, 0xCF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0x7C, 0xFF, 0xFF, 0xFF, 0xA8,
    0xFF, 0xCF, 0xFF, 0xFF, 0xFF, 0x90, 0xFF, 0xFF,    0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0x7A, 0xFF, 0xFF,
    0xFF, 0x73, 0x6E, 0xFF, 0xFF, 0x71, 0xFF, 0xFF,    0x6E, 0x70, 0xFF, 0xFF, 0x5F, 0x74, 0xFF, 0xFF,
    0xD4, 0xBD, 0xFF, 0x59, 0xD4, 0x8F, 0xFF, 0xCA,    0xD4, 0x5F, 0xFF, 0xBD, 0xD4, 0x04, 0xFF, 0x2B,
    0xFF, 0xCF, 0xFF, 0x54, 0xFF, 0xCF, 0xFF, 0xAE,    0xFF, 0xCF, 0xFF, 0xA7, 0xFF, 0xCF, 0xFF, 0xC1,
    0xFF, 0x1E, 0xFF, 0xCF, 0xFF, 0x1F, 0xFF, 0xCF,    0xFF, 0xD0, 0xFF, 0xCF, 0xFF, 0xCF, 0xFF, 0xCF,
    0xFF, 0xFF, 0xFF, 0xBE, 0xFF, 0xFF, 0xFF, 0xA9,    0xFF, 0xFF, 0xFF, 0xA7, 0xFF, 0xFF, 0xFF, 0x1F,
    0xFF, 0xBB, 0xFF, 0xFF, 0xFF, 0xAA, 0xFF, 0xFF,    0xFF, 0x19, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x68,
    0xFF, 0xFF, 0xFF, 0x75, 0xFF, 0xFF, 0xFF, 0x70,    0xFF, 0xFF, 0x62, 0x70, 0xFF, 0x7D, 0x72, 0x70,
    0xFF, 0x6F, 0xD4, 0xC6, 0xFF, 0xFF, 0xD4, 0xC0,    0xFF, 0xFF, 0xD4, 0x97, 0xFF, 0xFF, 0xD4, 0x0F,
    0xD4, 0xD9, 0xFF, 0xAE, 0x74, 0x81, 0xFF, 0x54,    0x64, 0xFF, 0xFF, 0xCF, 0xFF, 0xFF, 0xFF, 0xCF,
    0xFF, 0x6A, 0xFF, 0xFF, 0xFF, 0xA0, 0xFF, 0xFF,    0xFF, 0xD3, 0xFF, 0x7C, 0xFF, 0xC1, 0xFF, 0xC0,
    0xFF, 0xCF, 0xFF, 0x90, 0xFF, 0xCF, 0xFF, 0xC8,    0xFF, 0xCF, 0xFF, 0xA8, 0xFF, 0xCF, 0xFF, 0xFF,
    0xFF, 0xCF, 0xFF, 0xCF, 0xFF, 0xCF, 0xFF, 0xCF,    0xFF, 0xCF, 0xFF, 0xCF, 0xFF, 0xCF, 0xFE, 0xCF,
    0xFE, 0xFF, 0xAE, 0x5B, 0xFF, 0xFF, 0xA8, 0x5B,    0xFF, 0xFF, 0xA9, 0x5B, 0xFF, 0x1D, 0xA9, 0x5B,
    0xFF, 0xFE, 0xA9, 0x8E, 0xFF, 0xFF, 0xAA, 0x79,    0xFF, 0xFF, 0xA9, 0x01, 0x63, 0xFF, 0xA9, 0x5B,
    0xAA, 0xFF, 0xFF, 0xFF, 0xA8, 0xFF, 0xFF, 0x7D,    0xCE, 0xFF, 0xFF, 0xC1, 0x79, 0xFF, 0xFF, 0xC7,
    0xFF, 0x5B, 0xFF, 0xFF, 0xFF, 0x79, 0xFF, 0xFF,    0xFF, 0x91, 0xFF, 0xFF, 0xFF, 0x2B, 0xFF, 0xFF,
    0x7E, 0x4C, 0xB9, 0x8A, 0xA6, 0x21, 0xAA, 0xFF,    0xBA, 0x3F, 0x72, 0xFF, 0xBE, 0x2A, 0xFF, 0xFF,
    0xC5, 0x8B, 0xFF, 0x07, 0xCA, 0x71, 0xFF, 0x6C,    0xC7, 0x14, 0xFF, 0xB1, 0xBF, 0x2C, 0xFF, 0xB8,
    0x06, 0x5B, 0xA9, 0x01, 0xAB, 0x5B, 0xA9, 0x81,    0xA8, 0x5B, 0xAA, 0x70, 0xA9, 0x5B, 0xA9, 0x73,
    0xAA, 0xB6, 0xA9, 0x5B, 0xAA, 0x90, 0xCC, 0x5B,    0xAA, 0x79, 0x91, 0x5B, 0xAA, 0x01, 0x84, 0x5B,
    0x5C, 0xFF, 0xFF, 0xCC, 0xFF, 0xFF, 0xFF, 0x7C,    0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0x79, 0xCA,
    0xFF, 0x7F, 0xD1, 0xFF, 0xFF, 0xAA, 0xAE, 0xFF,    0xFF, 0xB8, 0xAE, 0xFF, 0xFF, 0xD3, 0x95, 0x00,
    0x64, 0xFF, 0x62, 0x4F, 0xFF, 0xFF, 0x85, 0x4C,    0xFF, 0x7C, 0xC3, 0x3E, 0xFF, 0xC1, 0xBB, 0x3F,
    0xFF, 0x63, 0xC0, 0xA8, 0xFF, 0xFF, 0xA5, 0x5B,    0xFF, 0xFF, 0xCA, 0x01, 0xFF, 0xFF, 0xC7, 0x23,
    0xC0, 0x8E, 0xFF, 0x71, 0xBC, 0xBF, 0xFF, 0x73,    0x1F, 0x73, 0x6F, 0x5B, 0x99, 0xFF, 0x8E, 0x5B,
    0x69, 0x4E, 0xA8, 0xFF, 0xFF, 0x4A, 0xAA, 0xFF,    0xFF, 0x00, 0xA9, 0x6C, 0xFF, 0x70, 0xAA, 0xA7,
    0xA9, 0x5B, 0xA9, 0x6E, 0xAA, 0x5B, 0xA9, 0xB7,    0xA9, 0x5B, 0xA9, 0x8E, 0xA9, 0x5B, 0xAA, 0xFF,
    0xA9, 0x5B, 0xA9, 0x5B, 0xAA, 0x5B, 0xA8, 0x5B,    0xAA, 0x5B, 0xD3, 0x5B, 0xA9, 0x5B, 0xFE, 0x5B,
    0xFF, 0xFE, 0x3C, 0xB3, 0xFF, 0xFF, 0x3C, 0x46,    0xFF, 0xFF, 0x3C, 0x06, 0xB1, 0xFF, 0x3D, 0x00,
    0xFE, 0xFF, 0x93, 0x03, 0xFF, 0xFF, 0x0F, 0x03,    0xFF, 0xFF, 0x51, 0x03, 0xFF, 0x8E, 0x3D, 0x00,
    0xFF, 0x56, 0x6F, 0xFF, 0xFF, 0x2D, 0xC2, 0xFF,    0xFF, 0xB4, 0xCF, 0xFF, 0xFF, 0xAC, 0x6C, 0x09,
    0x51, 0xFE, 0xFF, 0x1F, 0x23, 0xFF, 0xFF, 0x78,    0x98, 0xFF, 0xFF, 0x44, 0x82, 0xFF, 0xFF, 0x2A,
    0x16, 0x01, 0xBC, 0x76, 0xA4, 0x5B, 0x7B, 0x73,    0x08, 0x75, 0xFF, 0x16, 0x0D, 0x75, 0xFF, 0x3E,
    0x23, 0x75, 0x21, 0x01, 0x40, 0x75, 0x3D, 0xA5,    0x29, 0x75, 0x01, 0x86, 0x0C, 0x75, 0x59, 0xFF,
    0x3D, 0xB6, 0x3C, 0x03, 0x3C, 0x8F, 0x3B, 0x03,    0x3C, 0x11, 0x3C, 0x03, 0x3C, 0x13, 0x4C, 0x03,
    0xB7, 0x01, 0x3C, 0x03, 0x8F, 0x03, 0x3C, 0x03,    0x14, 0x03, 0x3C, 0x00, 0x51, 0x03, 0x3C, 0x01,
    0x93, 0x67, 0xDE, 0xFF, 0xFF, 0x16, 0x73, 0xFF,    0xFF, 0x3C, 0x7A, 0xFF, 0xFF, 0x16, 0xC9, 0x72,
    0x28, 0x7F, 0xFF, 0xA9, 0x6E, 0xBF, 0xFF, 0x73,    0xB7, 0x71, 0xFF, 0x7A, 0xBF, 0xFF, 0x72, 0xA7,
    0xFF, 0x63, 0x0F, 0x4F, 0x61, 0xFF, 0x07, 0x68,    0xA6, 0xFF, 0xA4, 0x00, 0xAC, 0xFF, 0x08, 0x75,
    0x63, 0x64, 0x6C, 0x75, 0xFF, 0xC6, 0x1A, 0x75,    0xFF, 0x2C, 0x40, 0x75, 0xFF, 0x23, 0x2A, 0x75,
    0x6C, 0x75, 0x07, 0x6F, 0xD2, 0x75, 0x3A, 0xFF,    0xD9, 0x03, 0x3C, 0x6C, 0x64, 0x73, 0x3C, 0xA7,
    0x10, 0x2D, 0xFF, 0x12, 0x2C, 0x31, 0xFF, 0x1D,    0x3A, 0x9D, 0x6C, 0x5C, 0x2B, 0xC3, 0xA7, 0x03,
    0x3C, 0x03, 0x4E, 0x03, 0x3C, 0x03, 0x8A, 0x03,    0x3C, 0x03, 0x54, 0x00, 0x3C, 0x03, 0xFF, 0x06,
    0x3C, 0x03, 0x3C, 0x34, 0x3C, 0x03, 0x3C, 0x86,    0x3C, 0x03, 0x3C, 0x92, 0x3C, 0x03, 0x3A, 0xFF,
    0xFF, 0xFE, 0x05, 0x34, 0xFF, 0xFF, 0x05, 0x2C,    0xFF, 0xFF, 0x05, 0x75, 0x96, 0xFF, 0x06, 0x75,
    0xFE, 0xFF, 0xD3, 0x75, 0xFF, 0xFF, 0x34, 0x75,    0xFF, 0x61, 0x08, 0x75, 0xFF, 0xDE, 0x06, 0x75,
    0xFF, 0x03, 0x90, 0xFF, 0xFF, 0x43, 0xCA, 0xFF,    0xFF, 0x57, 0x7D, 0xFF, 0xFF, 0xCA, 0x4D, 0xAC,
    0xA4, 0x64, 0xFF, 0xD3, 0x30, 0xFF, 0xFF, 0x08,    0xB1, 0xFF, 0xFF, 0x4D, 0xD2, 0xFF, 0xFF, 0x5C,
    0x72, 0x76, 0xD3, 0x75, 0x6B, 0x75, 0xC5, 0x75,    0x72, 0x75, 0x64, 0x73, 0x67, 0x75, 0xFF, 0xB6,
    0x29, 0x75, 0x5B, 0x31, 0x09, 0x75, 0x0E, 0x7E,    0x66, 0x75, 0x3B, 0xC5, 0x01, 0x75, 0x03, 0xFE,
    0x02, 0x9B, 0x05, 0x75, 0x05, 0x8F, 0x04, 0x75,    0x05, 0x11, 0xA4, 0x75, 0x05, 0x11, 0x25, 0x75,
    0xB6, 0x72, 0x05, 0x75, 0x8F, 0x75, 0x05, 0x75,    0x10, 0x75, 0x05, 0x75, 0x9D, 0x75, 0x05, 0x75,
    0xC0, 0x75, 0xDE, 0xFF, 0xB1, 0x01, 0x73, 0xFF,    0xFF, 0x06, 0x7A, 0xFF, 0xFF, 0x4B, 0xA7, 0x72,
    0x4D, 0x06, 0xFF, 0xDE, 0x3B, 0xD1, 0xFF, 0x73,    0x09, 0x90, 0xFF, 0x7A, 0x7B, 0xFF, 0x72, 0xA7,
    0xFF, 0x63, 0x01, 0x00, 0x89, 0xFF, 0x72, 0x76,    0xD9, 0xFF, 0x6B, 0x75, 0x5C, 0xFF, 0x72, 0x75,
    0x63, 0x57, 0x4D, 0x75, 0xFF, 0xC8, 0x4E, 0x75,    0xFF, 0x06, 0x78, 0x75, 0xFF, 0x3F, 0x5C, 0x75,
    0x3F, 0x75, 0x12, 0x89, 0x71, 0x75, 0x31, 0xFF,    0x5A, 0x75, 0x75, 0x6E, 0x9A, 0x76, 0x05, 0xA7,
    0x5B, 0x5B, 0xFF, 0x14, 0x5C, 0x4C, 0xFF, 0x35,    0x06, 0x04, 0x6C, 0x5B, 0x2C, 0xDE, 0xA7, 0x75,
    0x05, 0x75, 0x48, 0x75, 0x05, 0x75, 0x87, 0x75,    0x05, 0x75, 0x91, 0x76, 0x05, 0x75, 0xFF, 0x77,
    0x05, 0x75, 0x05, 0x34, 0x05, 0x75, 0x05, 0x85,    0x05, 0x75, 0x06, 0x92, 0x05, 0x75, 0x8B, 0xFF,
    0xFE, 0xFF, 0x0F, 0x75, 0xFF, 0xFF, 0x43, 0x75,    0xFF, 0x09, 0x6B, 0x75, 0xFF, 0xCC, 0x75, 0x75,
    0xFF, 0xFE, 0x75, 0x13, 0xFF, 0xFF, 0x75, 0x1E,    0x63, 0xFF, 0x75, 0x5B, 0x5A, 0xFF, 0x75, 0x75,
    0x72, 0xA0, 0xFF, 0x47, 0x2C, 0xFF, 0xFF, 0x08,    0x13, 0xFF, 0x7D, 0x00, 0xA6, 0xFF, 0xD9, 0x75,
    0x79, 0x5B, 0x19, 0xFF, 0xFF, 0x0D, 0x29, 0xFF,    0xFF, 0x13, 0x8B, 0x8E, 0xFF, 0xAD, 0x00, 0x86,
    0x75, 0x3E, 0x75, 0x06, 0x75, 0x21, 0x75, 0x2A,    0x75, 0x3C, 0x76, 0x0F, 0x76, 0x13, 0x00, 0xA8,
    0x72, 0x75, 0x4D, 0x5B, 0x72, 0x5B, 0x77, 0x75,    0x03, 0x08, 0xC9, 0x75, 0x75, 0x4B, 0x11, 0x76,
    0xA0, 0x72, 0x76, 0x4B, 0x8F, 0x75, 0x03, 0x2A,    0x11, 0x76, 0x03, 0x7B, 0x11, 0x06, 0x03, 0x72,
    0x72, 0xB4, 0x76, 0x21, 0x75, 0x91, 0x75, 0x3C,    0x75, 0x11, 0x75, 0x4B, 0x75, 0x11, 0x75, 0x3D,
    0x75, 0x09, 0xFF, 0xDE, 0x75, 0x2F, 0xFF, 0x73,    0x72, 0xB2, 0xFF, 0x7A, 0x19, 0xCC, 0x72, 0xA7,
    0x29, 0x75, 0xDE, 0xFE, 0x09, 0x75, 0x73, 0xFF,    0xC4, 0x75, 0x7A, 0xFF, 0x6E, 0x00, 0xA7, 0x72,
    0x63, 0xC9, 0x5B, 0xC5, 0xFF, 0x07, 0x75, 0x86,    0xFF, 0x43, 0x75, 0x70, 0xFF, 0x5B, 0x74, 0x75,
    0x92, 0x63, 0x73, 0x75, 0x98, 0xFF, 0x01, 0x75,    0x41, 0xFF, 0x74, 0x76, 0x25, 0x5C, 0x75, 0x72,
    0x75, 0x75, 0xAC, 0x13, 0x75, 0x5B, 0xFF, 0x35,    0x75, 0x1C, 0x6C, 0x5B, 0x75, 0x07, 0xA7, 0x75,
    0x72, 0x75, 0x14, 0xA8, 0x14, 0x75, 0x35, 0x03,    0x30, 0x75, 0x5B, 0x79, 0x87, 0x75, 0x75, 0xA7,
    0x75, 0x4B, 0x03, 0x34, 0x76, 0x4B, 0x03, 0x99,    0x03, 0x4B, 0x00, 0x95, 0x03, 0x4B, 0x77, 0xFF,
    0x03, 0x76, 0x36, 0x4B, 0x03, 0x4C, 0x83, 0x4B,    0x03, 0x3B, 0x93, 0x4B, 0x03, 0x4B, 0xFF, 0x3A,
    0xFE, 0xFF, 0x14, 0x75, 0xFF, 0xFF, 0x2E, 0x75,    0xFF, 0x1A, 0x66, 0x75, 0xFF, 0x90, 0x75, 0x75,
    0xFF, 0xFE, 0x75, 0x27, 0xFF, 0xFF, 0x75, 0x11,    0x71, 0xFF, 0x75, 0x72, 0xA7, 0xFF, 0x75, 0x75,
    0x5B, 0xB2, 0xFF, 0x44, 0x48, 0xFF, 0xFF, 0x76,    0x14, 0xFF, 0x85, 0x75, 0xA8, 0xFF, 0x8F, 0x75,
    0x01, 0x80, 0x17, 0xFF, 0xFF, 0x13, 0x1A, 0x64,    0xFF, 0x0F, 0x67, 0xC8, 0xFF, 0xD1, 0x75, 0x9B,
    0x75, 0x73, 0x75, 0x5B, 0x75, 0x01, 0x75, 0x2E,    0x72, 0x05, 0x75, 0x17, 0x8D, 0x4B, 0x5B, 0xAC,
    0x15, 0x00, 0x0E, 0x17, 0x12, 0x7B, 0x4A, 0x72,    0x06, 0x4B, 0x9A, 0x75, 0x5B, 0x09, 0xD2, 0x75,
    0x11, 0x72, 0x06, 0x00, 0x8F, 0x75, 0x78, 0x24,    0x11, 0x76, 0x78, 0x3A, 0x11, 0x04, 0x78, 0x08,
    0x72, 0x98, 0x74, 0x4D, 0x75, 0xD2, 0x66, 0x78,    0x75, 0x11, 0x00, 0x01, 0x75, 0x11, 0x75, 0x5B,
    0x75, 0x00, 0xFF, 0xA9, 0x75, 0x4F, 0xFF, 0x73,    0x75, 0xA1, 0xFF, 0x7A, 0x67, 0xC7, 0x72, 0xA7,
    0x2C, 0x72, 0xDE, 0x65, 0x08, 0x75, 0x73, 0xFF,    0xAE, 0x75, 0x7A, 0xFF, 0xAF, 0x75, 0xA7, 0x72,
    0x63, 0xAE, 0x75, 0xC6, 0xFF, 0x27, 0x75, 0x01,    0xFF, 0x1E, 0x75, 0x76, 0x64, 0x5B, 0x70, 0x75,
    0xC9, 0x63, 0xB1, 0x75, 0x57, 0xFF, 0x87, 0x75,    0x43, 0xFF, 0x73, 0x70, 0x06, 0x1D, 0x75, 0xB3,
    0x75, 0x75, 0xA5, 0x13, 0x75, 0x72, 0x69, 0x35,    0x75, 0x9F, 0x7C, 0x5B, 0x75, 0x0F, 0xC9, 0x76,
    0x75, 0x75, 0x13, 0xD2, 0x76, 0x75, 0x35, 0x59,    0x4F, 0x75, 0x5B, 0x65, 0x12, 0x75, 0x75, 0xA7,
    0x75, 0x5B, 0x78, 0x7C, 0x06, 0x72, 0x78, 0x99,    0x78, 0x72, 0x06, 0x97, 0x78, 0x72, 0x09, 0xFF,
    0x78, 0x78, 0x1D, 0x72, 0x78, 0x4D, 0x82, 0x72,    0x78, 0x04, 0x94, 0x72, 0x78, 0x01, 0xFF, 0x0A,
    0xFF, 0xFE, 0x75, 0x2D, 0xFF, 0xFF, 0x75, 0x06,    0x84, 0xFF, 0x75, 0x76, 0x94, 0xFF, 0x75, 0x75,
    0xFE, 0xFF, 0x25, 0x75, 0xFF, 0xFF, 0x08, 0x75,    0xFF, 0x8E, 0x00, 0x75, 0xFF, 0x58, 0x75, 0x75,
    0x98, 0x76, 0x1B, 0xFF, 0xFF, 0x74, 0x5B, 0x7E,    0xFF, 0x44, 0x75, 0x91, 0xFF, 0x1A, 0x75, 0x26,
    0x03, 0xCC, 0xFF, 0x0E, 0xA4, 0xFE, 0x6E, 0x72,    0x36, 0xFF, 0xC9, 0x75, 0x98, 0xFF, 0x16, 0x6B,
    0xC5, 0x14, 0x5B, 0x17, 0xC4, 0x0D, 0x0E, 0x32,    0x85, 0x96, 0x25, 0x73, 0x04, 0xD1, 0x97, 0x5B,
    0x66, 0xFF, 0x29, 0x5C, 0x4F, 0xFF, 0x00, 0x76,    0x16, 0x86, 0x75, 0x2F, 0x59, 0xAA, 0x75, 0xB5,
    0x72, 0xD4, 0x92, 0x31, 0x75, 0xCF, 0x12, 0xAF,    0x76, 0x13, 0x7B, 0xD2, 0x04, 0x11, 0x3E, 0xFF,
    0xC5, 0x72, 0x2D, 0xFE, 0xD2, 0x75, 0x10, 0xB1,    0x12, 0x76, 0xCF, 0xC5, 0x11, 0x04, 0xCE, 0x8B,
    0x5B, 0x2A, 0xA9, 0x99, 0x30, 0x00, 0x73, 0xFF,    0x15, 0x75, 0x7A, 0xFF, 0xAA, 0x75, 0xA7, 0x72,
    0x74, 0x00, 0x04, 0xDE, 0x76, 0x08, 0xFF, 0x73,    0x75, 0x24, 0xFF, 0x7A, 0x75, 0x94, 0x72, 0xA7,
    0x94, 0x63, 0x99, 0x75, 0x23, 0xFF, 0x71, 0x71,    0x15, 0xFF, 0x75, 0x95, 0x6B, 0xD2, 0x75, 0xD2,
    0x63, 0xB0, 0x75, 0x71, 0xFF, 0x34, 0x75, 0x75,    0xFF, 0x77, 0x71, 0x75, 0x83, 0x76, 0xCD, 0x75,
    0x75, 0x75, 0x13, 0x2A, 0x03, 0x75, 0x1D, 0xD0,    0xA4, 0x75, 0x5B, 0x71, 0x34, 0x75, 0x76, 0xA8,
    0x75, 0x75, 0xD3, 0x13, 0x75, 0x76, 0x60, 0x4A,    0x75, 0x06, 0x79, 0x5B, 0x75, 0x2D, 0xCA, 0x76,
    0xAD, 0x7B, 0xCF, 0xFF, 0xAE, 0x4A, 0xC2, 0xFF,    0xAE, 0x84, 0x98, 0xFF, 0xAE, 0x98, 0xFF, 0xFF,
    0x04, 0xFF, 0xAE, 0xFF, 0x20, 0xFF, 0xAE, 0xFF,    0x13, 0xFF, 0xAE, 0xFF, 0xCF, 0xFF, 0xAE, 0xFE,
    0xFF, 0xFE, 0x75, 0x2C, 0xFF, 0xFF, 0x75, 0x03,    0x96, 0xFF, 0x75, 0x75, 0x84, 0xFF, 0x75, 0x75,
    0xFE, 0xFF, 0x35, 0x75, 0xFF, 0x64, 0x7B, 0x75,    0xFF, 0xCA, 0x76, 0x75, 0xFF, 0x7F, 0x75, 0x75,
    0x91, 0x75, 0x1E, 0xFF, 0xFF, 0x00, 0x5B, 0x29,    0xFF, 0x2C, 0x75, 0x92, 0xFF, 0x9D, 0x76, 0x0D,
    0x76, 0xC9, 0xFF, 0x12, 0x04, 0xFC, 0x04, 0x72,    0x2F, 0xFF, 0xAE, 0x75, 0x29, 0xFF, 0x15, 0x5B,
    0x94, 0x24, 0x03, 0x12, 0x9A, 0x27, 0xA4, 0x2A,    0xBF, 0xAE, 0x33, 0xA3, 0x1A, 0x1C, 0x88, 0x57,
    0x8C, 0xFF, 0x31, 0x20, 0x2B, 0xFF, 0x16, 0x29,    0xA2, 0x79, 0x00, 0x21, 0x1F, 0xA5, 0x75, 0x11,
    0x72, 0xD6, 0xA5, 0x31, 0x75, 0xCF, 0xBE, 0xAF,    0x76, 0x13, 0xB7, 0x92, 0x04, 0x11, 0x37, 0xFF,
    0xD4, 0x72, 0x1B, 0xFF, 0x90, 0x75, 0x87, 0xFE,    0x13, 0x76, 0xBE, 0xCA, 0x11, 0x04, 0xCD, 0x2C,
    0x72, 0x45, 0xDE, 0x95, 0x10, 0x04, 0x73, 0xFF,    0x27, 0x76, 0x7A, 0xFF, 0x8F, 0x75, 0xA7, 0x72,
    0x0C, 0x03, 0x59, 0xDE, 0x5B, 0x7B, 0xFF, 0x73,    0x75, 0x1E, 0xFF, 0x7A, 0x75, 0x98, 0x72, 0xC9,
    0xD3, 0x63, 0x06, 0x6A, 0x37, 0xFF, 0x00, 0x76,    0x7B, 0xFF, 0x75, 0xCA, 0x6A, 0xD1, 0x75, 0xA0,
    0x63, 0xB2, 0x75, 0x5B, 0xFF, 0x33, 0x66, 0x74,    0xFF, 0x06, 0xA0, 0x75, 0x95, 0x76, 0xC6, 0x75,
    0x75, 0x75, 0x13, 0x1A, 0x76, 0x75, 0x36, 0xAE,    0x04, 0x75, 0x5B, 0x5B, 0x30, 0x75, 0x76, 0xAA,
    0x75, 0x75, 0x86, 0x13, 0x75, 0x75, 0x93, 0x1E,    0x75, 0x76, 0x6C, 0x5B, 0x75, 0x2D, 0xCA, 0x03,
    0xCD, 0x09, 0xAB, 0xFF, 0xCC, 0x22, 0xAA, 0xFF,    0xCC, 0xD3, 0x9C, 0xFF, 0xCC, 0x98, 0xFF, 0xFF,
    0x8B, 0xFF, 0xCC, 0xFF, 0x35, 0xFF, 0xCC, 0xFF,    0xB2, 0xFF, 0xCC, 0xFF, 0xBF, 0xFF, 0xCC, 0xFE,
    0xFE, 0xFF, 0x45, 0x01, 0xFF, 0x15, 0x72, 0x01,    0xFF, 0xCD, 0x75, 0x01, 0xFF, 0x13, 0x75, 0x76,
    0xFF, 0xFE, 0x75, 0x1E, 0x79, 0xFF, 0x75, 0x5B,    0xC7, 0xFF, 0x75, 0x75, 0x11, 0xFF, 0x75, 0x76,
    0x75, 0xAD, 0xFF, 0x12, 0x5B, 0x0D, 0xB1, 0x72,    0x2D, 0xFF, 0x93, 0x75, 0x13, 0xFF, 0x24, 0x72,
    0x5A, 0x75, 0x14, 0xFF, 0x7C, 0x5B, 0x5E, 0x88,    0xFF, 0x9E, 0x75, 0x92, 0xFF, 0x12, 0x5B, 0x25,
    0x37, 0xFF, 0x59, 0xBE, 0x12, 0xFF, 0x4D, 0xBC,    0xCE, 0xFF, 0x3E, 0x1F, 0xA3, 0xD2, 0x4D, 0xA8,
    0xFF, 0x9D, 0x30, 0x5A, 0xFF, 0x0F, 0x27, 0xAD,    0xFE, 0xD0, 0x76, 0xD9, 0xCC, 0x87, 0x01, 0xC0,
    0xBA, 0x72, 0x31, 0xFF, 0x8E, 0x75, 0xAF, 0xFF,    0x13, 0x76, 0x92, 0xA1, 0x11, 0x04, 0xFF, 0xAE,
    0x72, 0xC9, 0xFF, 0x31, 0x75, 0x90, 0xFF, 0xAF,    0x76, 0x12, 0x96, 0x92, 0x04, 0x11, 0x98, 0xFF,
    0x36, 0x76, 0x94, 0xDE, 0x08, 0x06, 0xFF, 0x73,    0x00, 0x31, 0xFF, 0x7A, 0x75, 0xB2, 0x72, 0xA7,
    0x76, 0x0F, 0xDE, 0x93, 0x04, 0x0F, 0x73, 0xFF,    0x35, 0x72, 0x7A, 0xFF, 0xB1, 0x75, 0xC9, 0x72,
    0x63, 0x2C, 0x73, 0xD9, 0xFF, 0x32, 0xB3, 0xD4,    0xFF, 0x6D, 0x8E, 0x94, 0xCF, 0x01, 0x71, 0x71,
    0x4F, 0x63, 0x66, 0x19, 0x32, 0xFF, 0x71, 0x91,    0x74, 0xFF, 0x00, 0x73, 0x75, 0xAD, 0x74, 0x78,
    0x75, 0x75, 0xB5, 0x13, 0x75, 0x75, 0xCE, 0x23,    0x75, 0x00, 0x56, 0x5B, 0x75, 0x45, 0xAB, 0x03,
    0x75, 0x75, 0x14, 0xB7, 0x75, 0x75, 0x22, 0xAC,    0x03, 0x75, 0x5B, 0x09, 0xB4, 0x75, 0x03, 0xCD,
    0xA4, 0xFD, 0xFF, 0xFF, 0x24, 0x04, 0xFF, 0xFF,    0x60, 0x2B, 0xFF, 0xFF, 0x99, 0xB3, 0xFF, 0xFE,
    0xFF, 0x08, 0xFF, 0x08, 0xFF, 0x9D, 0xFF, 0x63,    0xFF, 0x94, 0xFF, 0xFF, 0xFF, 0xB2, 0xFE, 0xFF,
    0xFE, 0xFF, 0x1A, 0x4F, 0xFF, 0xB3, 0x5B, 0x4E,    0xFF, 0xD0, 0x75, 0x4E, 0xFF, 0x10, 0x75, 0x7B,
    0xFF, 0xFE, 0x75, 0xA0, 0x73, 0xFF, 0x75, 0x72,    0xCA, 0xFF, 0x75, 0x6A, 0x15, 0xFF, 0x75, 0x04,
    0x75, 0xD2, 0xFF, 0x9D, 0x5B, 0xB1, 0xB1, 0x72,    0x36, 0xFF, 0xD2, 0x75, 0x14, 0xFF, 0x24, 0x00,
    0xA9, 0x03, 0x14, 0xFF, 0x75, 0x00, 0x5E, 0x1D,    0xFF, 0x15, 0x75, 0xD0, 0xFF, 0x0E, 0x5B, 0x0F,
    0x37, 0xFF, 0x58, 0x7B, 0x12, 0xFF, 0x7C, 0x6E,    0xAD, 0xFF, 0x73, 0xFC, 0xA2, 0x83, 0x00, 0xFF,
    0xFF, 0xA4, 0xA4, 0xC5, 0xFF, 0x36, 0xB5, 0xAD,    0xFF, 0x84, 0xAF, 0x95, 0xD1, 0xAD, 0xD0, 0x89,
    0xD4, 0x72, 0x31, 0xFF, 0xCF, 0x75, 0xAF, 0xFF,    0x13, 0x76, 0x92, 0x07, 0x11, 0x04, 0xFF, 0xAC,
    0x72, 0x9C, 0xFF, 0x31, 0x75, 0x54, 0xFF, 0xAF,    0x76, 0x11, 0x8A, 0x92, 0x04, 0x11, 0x92, 0xFF,
    0x24, 0x76, 0x93, 0xDE, 0xA0, 0x78, 0xFF, 0x73,    0x72, 0x32, 0xFF, 0x7A, 0x75, 0xB2, 0x72, 0xA7,
    0x76, 0x10, 0xDE, 0x93, 0x78, 0x9E, 0x73, 0xFF,    0x32, 0x72, 0x7A, 0xFF, 0xB2, 0x75, 0xA7, 0x72,
    0x63, 0xB4, 0x71, 0xD4, 0xFF, 0x1B, 0x92, 0xD4,    0xFF, 0x75, 0x59, 0xC1, 0xAE, 0x73, 0x71, 0x06,
    0x2B, 0x63, 0x07, 0x92, 0x32, 0xFF, 0xAF, 0xAF,    0x6D, 0xFF, 0x78, 0x6C, 0x75, 0xAD, 0x03, 0xB7,
    0x75, 0x75, 0xB7, 0xA0, 0x75, 0x75, 0xAC, 0x0D,    0x75, 0x00, 0x77, 0x5B, 0x75, 0x45, 0xCC, 0x00,
    0x75, 0x00, 0x13, 0xB7, 0x75, 0x75, 0x22, 0xAC,    0x03, 0x75, 0x5B, 0xA3, 0x45, 0x75, 0x03, 0xAC,
    0x18, 0xC6, 0xFF, 0xFF, 0x0D, 0xBF, 0xFF, 0xFF,    0x96, 0x1F, 0xFF, 0xFF, 0x83, 0x1F, 0xFF, 0xFE,
    0xFF, 0xA2, 0xFF, 0xC0, 0xFF, 0x0F, 0xFF, 0x1F,    0xFF, 0x96, 0xFF, 0x93, 0xFF, 0x5A, 0xFE, 0x65,
    0xFF, 0xFE, 0x3F, 0x06, 0x99, 0xFF, 0x2E, 0x75,    0x95, 0xFF, 0x29, 0x5B, 0x25, 0xFF, 0x11, 0x1E,
    0xFE, 0xFE, 0x08, 0x0E, 0xFF, 0xCC, 0x5D, 0x95,    0xFF, 0x59, 0x72, 0x9E, 0xFF, 0x44, 0xA1, 0x35,
    0x82, 0x5B, 0xB6, 0xFF, 0x98, 0x75, 0x5B, 0x62,    0xFF, 0x75, 0x75, 0xCA, 0xFF, 0x2C, 0x75, 0xB6,
    0x72, 0xB5, 0xFF, 0x44, 0x03, 0xAA, 0x06, 0x6D,    0x09, 0x61, 0xAC, 0x75, 0x4A, 0xFF, 0x16, 0x75,
    0x01, 0x03, 0xFF, 0xFF, 0xFF, 0x7B, 0xFF, 0xFF,    0xFF, 0x4D, 0xFF, 0xFF, 0x62, 0x77, 0xFF, 0xFF,
    0x75, 0xC1, 0x61, 0xFF, 0x4F, 0x1D, 0xFF, 0xFF,    0xA3, 0xFF, 0xFF, 0xFF, 0xC3, 0xFF, 0xFF, 0xFF,
    0x72, 0xB6, 0xFF, 0x31, 0x75, 0x8F, 0xFF, 0xAF,    0x76, 0x11, 0xA1, 0x92, 0x04, 0x11, 0xAD, 0xFF,
    0xB7, 0x72, 0x31, 0xFF, 0x8F, 0x75, 0xAF, 0xFF,    0x11, 0x76, 0x92, 0x8E, 0x11, 0x04, 0xFF, 0x84,
    0x76, 0x48, 0xDE, 0x87, 0x04, 0x19, 0x73, 0xFF,    0x34, 0x5D, 0x7A, 0xFF, 0x85, 0x75, 0xA7, 0x72,
    0x0F, 0x72, 0x94, 0xDE, 0x9E, 0x12, 0xFF, 0x73,    0x72, 0x26, 0xFF, 0x7A, 0x75, 0xD1, 0x72, 0xA7,
    0xB4, 0x63, 0xBA, 0xD4, 0x31, 0xFF, 0xD4, 0xC3,    0x5C, 0xFF, 0xC0, 0xA4, 0x9D, 0xAD, 0x75, 0x82,
    0x63, 0xB4, 0xD6, 0xD9, 0xFF, 0x33, 0xB2, 0xD4,    0xFF, 0x5C, 0x7D, 0xD4, 0xAE, 0xC6, 0xA2, 0x1F,
    0x75, 0x04, 0x12, 0xB7, 0x75, 0x72, 0x0D, 0xCE,    0x00, 0x75, 0x72, 0x9D, 0x45, 0x75, 0x00, 0x8E,
    0x00, 0x75, 0xB7, 0x12, 0x75, 0x75, 0xCE, 0x0F,    0x75, 0x00, 0xA2, 0x72, 0x75, 0x45, 0xAD, 0x72,
    0x0B, 0x11, 0x6E, 0x1C, 0x19, 0x34, 0xFF, 0x21,    0x75, 0x71, 0xFF, 0x4E, 0x75, 0x0E, 0xFE, 0x71,
    0x15, 0x3C, 0x8B, 0xA7, 0x12, 0x2F, 0xB1, 0x95,    0x92, 0x25, 0xC4, 0xFF, 0xBA, 0x0E, 0xC4, 0xFF,
    0xFF, 0xFE, 0x9B, 0x00, 0xD2, 0xFF, 0x8A, 0x75,    0x84, 0xFF, 0x0E, 0x5B, 0x32, 0xFF, 0x0C, 0x32,
    0xFE, 0x69, 0x8B, 0x10, 0xFF, 0xA6, 0x76, 0xAB,    0xFF, 0x9C, 0x5B, 0x0F, 0xFF, 0x43, 0x25, 0x2E,
    0x89, 0x72, 0x30, 0xFF, 0x90, 0x75, 0x5B, 0xFF,    0xFF, 0x72, 0x75, 0xD0, 0xFF, 0x2C, 0x75, 0x85,
    0x5B, 0x0F, 0xFF, 0x31, 0x76, 0xA6, 0x7C, 0x08,    0x77, 0x63, 0x5A, 0x00, 0x2F, 0xFF, 0xA1, 0x75,
    0xAD, 0x75, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF,    0xFF, 0x45, 0xFF, 0xFF, 0xFF, 0x10, 0xFF, 0xFF,
    0x5B, 0xB2, 0xFF, 0xFF, 0x2E, 0x1F, 0xFF, 0xFF,    0x15, 0x6C, 0xFF, 0xFF, 0x93, 0xFF, 0xFF, 0xFF,
    0x72, 0xB6, 0xFF, 0x31, 0x75, 0x8F, 0xFF, 0x85,    0x76, 0x11, 0x86, 0xD2, 0x04, 0x11, 0x92, 0xFF,
    0xB6, 0x72, 0x31, 0xFF, 0x8F, 0x75, 0xAF, 0x5B,    0x11, 0x76, 0x92, 0xC2, 0x11, 0x04, 0xFF, 0x15,
    0x03, 0x4F, 0xDE, 0x08, 0x19, 0x74, 0x73, 0xFF,    0x37, 0x76, 0x7A, 0xFF, 0x97, 0x75, 0xA7, 0x72,
    0x24, 0x66, 0x96, 0xDE, 0xA0, 0x1B, 0xFF, 0x73,    0x72, 0x16, 0xFF, 0x7A, 0x75, 0xCC, 0x72, 0xA7,
    0xB4, 0x63, 0xCD, 0xC6, 0x32, 0xFF, 0xD4, 0xD4,    0x70, 0xFF, 0xBE, 0xBE, 0xD0, 0xAD, 0xB5, 0xD4,
    0x63, 0xB4, 0xD4, 0xD4, 0xFF, 0x32, 0x82, 0xD4,    0xFF, 0x00, 0x6C, 0xD4, 0xAE, 0x10, 0x6E, 0xD4,
    0x75, 0x8A, 0x12, 0xB7, 0x75, 0x70, 0x9D, 0xAD,    0x00, 0x75, 0x72, 0x7F, 0x45, 0x75, 0x5E, 0xD0,
    0x73, 0x75, 0xB7, 0x12, 0x75, 0x75, 0xCE, 0x11,    0x75, 0x00, 0x9F, 0x72, 0x75, 0x45, 0xAE, 0x72,
    0x5B, 0x0F, 0xC3, 0x5C, 0x30, 0x9D, 0x6F, 0x01,    0x50, 0x17, 0xFF, 0x2C, 0x50, 0x4B, 0xFE, 0x2C,
    0x13, 0x04, 0x43, 0x08, 0x24, 0x73, 0x7B, 0xC3,    0x83, 0x66, 0x71, 0x7D, 0x9E, 0x5B, 0xAE, 0xFF,
    0xFE, 0x9D, 0x5B, 0x5F, 0xFF, 0xAE, 0x75, 0xD6,    0xFF, 0x13, 0x5E, 0x58, 0xFF, 0x0D, 0x45, 0x30,
    0x6C, 0xFE, 0x10, 0x5B, 0xA5, 0xFF, 0xD9, 0x76,    0x13, 0xFF, 0x9C, 0x78, 0x44, 0xFF, 0x2C, 0x20,
    0x03, 0x11, 0xFF, 0x86, 0x75, 0x8E, 0xFF, 0x34,    0x5B, 0x59, 0xB1, 0x9D, 0x46, 0xFF, 0xCF, 0x5B,
    0x14, 0x04, 0x15, 0xFF, 0xC8, 0x76, 0x34, 0xFF,    0x7D, 0x72, 0x01, 0xFE, 0xFF, 0x11, 0x75, 0xAA,
    0x75, 0x43, 0xFF, 0xFF, 0x76, 0x1C, 0xFF, 0xFF,    0x06, 0x7B, 0xFF, 0xFF, 0x3E, 0xBF, 0xFF, 0xFF,
    0x01, 0x75, 0xFF, 0xB2, 0x8E, 0x75, 0xFF, 0xFF,    0x5A, 0x75, 0xFF, 0xFF, 0x61, 0x5C, 0xFF, 0xFF,
    0xB6, 0x72, 0x31, 0x09, 0x8F, 0x75, 0xB1, 0x73,    0x11, 0x76, 0xCC, 0x4C, 0x11, 0x04, 0x7D, 0x1C,
    0x72, 0xB7, 0xA0, 0x43, 0x75, 0x8F, 0x1F, 0x74,    0x76, 0x11, 0x97, 0x9D, 0x04, 0x11, 0x08, 0x57,
    0x2F, 0x2B, 0x7C, 0xDE, 0x5B, 0xA4, 0xFF, 0x73,    0x75, 0xCF, 0xFF, 0x7A, 0x75, 0x82, 0x72, 0xA7,
    0x00, 0x66, 0xDE, 0xFF, 0x4F, 0x75, 0x73, 0xFF,    0x08, 0x75, 0x7A, 0xFF, 0xA5, 0x5C, 0xA7, 0x72,
    0x63, 0xB4, 0x9C, 0xD4, 0xFF, 0x1B, 0xBB, 0xD4,    0xFF, 0x6D, 0xD4, 0xD4, 0xAE, 0x75, 0xD4, 0xD4,
    0xB4, 0x63, 0xD4, 0x75, 0x1B, 0xFF, 0xD4, 0x70,    0x74, 0xFF, 0xD4, 0x77, 0x6E, 0xAD, 0xD4, 0x91,
    0xD2, 0x75, 0xB7, 0x0E, 0x71, 0x75, 0xAE, 0xA1,    0x75, 0x00, 0xB5, 0x00, 0x75, 0x45, 0xD2, 0x72,
    0x75, 0xBC, 0x11, 0xB7, 0x75, 0x19, 0x12, 0xAE,    0x00, 0x5B, 0x72, 0x8A, 0x45, 0x75, 0x72, 0x96,
    0x11, 0x6D, 0x75, 0x2A, 0x2D, 0x75, 0x76, 0x08,    0x3E, 0x01, 0x73, 0xA5, 0x7B, 0x76, 0x4D, 0x5C,
    0x5B, 0x0D, 0x09, 0x75, 0x74, 0x1D, 0xCF, 0x75,    0x75, 0x73, 0xD3, 0x75, 0x75, 0x01, 0xFF, 0x5B,
    0xFE, 0x88, 0x66, 0xB2, 0xFF, 0x92, 0x75, 0xD4,    0xFF, 0x0F, 0x75, 0x86, 0xFF, 0xA1, 0x45, 0x34,
    0x75, 0xFE, 0x0C, 0x00, 0xDE, 0xFF, 0xBD, 0x76,    0x15, 0xFF, 0xB5, 0x7B, 0x31, 0xFF, 0x44, 0x32,
    0x74, 0x0E, 0xFF, 0xC9, 0x75, 0x93, 0xFF, 0x06,    0x5B, 0x83, 0x6E, 0x29, 0x1D, 0xFF, 0xC5, 0x03,
    0x13, 0x7A, 0xA3, 0xFF, 0xAB, 0x03, 0x4D, 0xFF,    0x09, 0x00, 0x75, 0xFF, 0xFF, 0x07, 0x75, 0xB4,
    0x75, 0x5E, 0xFF, 0xFF, 0x75, 0x21, 0xFF, 0xFF,    0x5B, 0x07, 0xFF, 0xFF, 0x11, 0x5F, 0xFF, 0xFF,
    0x4C, 0x76, 0xFF, 0xBD, 0x73, 0x75, 0xFF, 0x19,    0xC5, 0x75, 0xFF, 0xFF, 0x93, 0x76, 0xFF, 0xFF,
    0xB7, 0x72, 0x31, 0x47, 0x8F, 0x75, 0x2A, 0x3A,    0x11, 0x76, 0xB9, 0x2F, 0x11, 0x05, 0xBB, 0x5B,
    0x72, 0xB6, 0xBF, 0x3E, 0x75, 0x8F, 0x95, 0x33,    0x76, 0x11, 0x73, 0x24, 0x04, 0x11, 0x21, 0x24,
    0x09, 0x29, 0xFD, 0xDE, 0x5D, 0x04, 0xFF, 0x73,    0x75, 0xC3, 0xFF, 0x7A, 0x00, 0x71, 0x72, 0xA7,
    0xA4, 0x76, 0xDE, 0xFF, 0x46, 0x75, 0x73, 0xFF,    0x58, 0x01, 0x7A, 0xFF, 0xDE, 0x07, 0xA7, 0x72,
    0x63, 0xB4, 0x71, 0xC1, 0xFF, 0x1B, 0x2C, 0xD4,    0xFF, 0x6D, 0xBF, 0xD4, 0xAD, 0x75, 0xD4, 0xD4,
    0xB4, 0x63, 0xD4, 0x75, 0x1B, 0xFF, 0xD4, 0x75,    0x6D, 0xFF, 0xD4, 0x70, 0x75, 0xAD, 0xD4, 0x74,
    0xC7, 0x75, 0xB7, 0x23, 0x73, 0x75, 0xAE, 0xA2,    0x76, 0x00, 0x59, 0x00, 0x75, 0x45, 0x95, 0x76,
    0x75, 0xD4, 0x10, 0xB7, 0x75, 0x85, 0x13, 0x8E,    0x00, 0x71, 0x72, 0x88, 0x45, 0x75, 0x5B, 0x97,
    0x0F, 0x3C, 0x75, 0xB7, 0x39, 0x3D, 0x75, 0xA0,    0x16, 0x30, 0x00, 0xCF, 0x66, 0x03, 0x19, 0x59,
    0x76, 0x78, 0x44, 0x03, 0x76, 0x72, 0x59, 0x75,    0x75, 0x8D, 0xC9, 0x75, 0x75, 0x45, 0x61, 0x66,
    0x98, 0xFE, 0x83, 0x75, 0x60, 0xFF, 0xD4, 0x5B,    0x24, 0xFF, 0x0B, 0x9D, 0xA4, 0xFD, 0x23, 0x12,
    0xFE, 0xCC, 0x03, 0x92, 0xFF, 0x5F, 0x5D, 0x82,    0xFF, 0x2C, 0x18, 0x8E, 0xFF, 0x74, 0x4A, 0x14,
    0x34, 0x23, 0xC5, 0xFF, 0x82, 0x5B, 0xB4, 0xFF,    0x95, 0x75, 0x34, 0xFF, 0xFF, 0x76, 0x1D, 0xFF,
    0xA2, 0x43, 0xFF, 0x61, 0x00, 0xB6, 0xFF, 0xC6,    0x03, 0xDE, 0xFF, 0x9A, 0x7B, 0x62, 0x62, 0x19,
    0x00, 0x29, 0xFF, 0x50, 0x77, 0x72, 0xFF, 0x67,    0x3D, 0x76, 0xFF, 0xC5, 0x75, 0x75, 0xFF, 0x96,
    0x5C, 0x75, 0x82, 0xFF, 0x75, 0x75, 0xBF, 0xFF,    0x75, 0x67, 0x6C, 0xFF, 0x75, 0x0C, 0xFF, 0xFF,
    0x72, 0xB7, 0x1C, 0x75, 0x75, 0x8F, 0x19, 0x75,    0x75, 0x11, 0x66, 0x75, 0x75, 0x11, 0x76, 0x75,
    0xB6, 0x72, 0xB7, 0x75, 0x8F, 0x75, 0x2D, 0x75,    0x11, 0x75, 0x2E, 0x75, 0x11, 0x75, 0x20, 0x00,
    0x0A, 0x08, 0xDE, 0xFF, 0xD1, 0xD3, 0x73, 0xFF,    0x8E, 0x18, 0x7A, 0xFF, 0xFF, 0x76, 0xA7, 0x72,
    0x75, 0xBD, 0xFF, 0xDE, 0x01, 0x97, 0xFF, 0x73,    0x09, 0xFF, 0xFF, 0x7A, 0x3B, 0xFF, 0x72, 0xA7,
    0xB4, 0x63, 0xCD, 0x75, 0x1B, 0xFF, 0xD4, 0x75,    0x6D, 0xFF, 0xD4, 0x75, 0x75, 0xAE, 0xD4, 0x00,
    0x63, 0xB4, 0x75, 0x78, 0xFF, 0x1B, 0x75, 0x1F,    0xFF, 0x6D, 0x6D, 0xD4, 0xAD, 0x75, 0x7D, 0xD4,
    0x75, 0xD4, 0x37, 0xB7, 0x75, 0xD4, 0x07, 0x54,    0x00, 0x95, 0x00, 0xD3, 0x45, 0x71, 0x75, 0x99,
    0xD4, 0x75, 0xB7, 0x36, 0xCA, 0x75, 0x8E, 0x7B,    0x71, 0x00, 0xB0, 0x73, 0x75, 0x45, 0x98, 0x73,
    0x03, 0x8C, 0x17, 0x45, 0x03, 0x4D, 0x22, 0x5B,    0x4E, 0x06, 0x60, 0x75, 0x8A, 0xC5, 0x60, 0x75,
    0x03, 0xC4, 0x5B, 0x74, 0x76, 0x1F, 0x75, 0x31,    0x3E, 0x8E, 0x75, 0xB4, 0x46, 0x09, 0x00, 0xCC,
    0x93, 0xFE, 0xD3, 0x75, 0x29, 0xFF, 0xC9, 0x5B,    0x32, 0xFF, 0x92, 0x1E, 0x04, 0x6F, 0x11, 0x13,
    0xFE, 0xC7, 0x76, 0xCD, 0xFF, 0x9D, 0x55, 0xB6,    0xFF, 0x43, 0x13, 0xAA, 0xFF, 0x00, 0x25, 0xA1,
    0x20, 0x35, 0xB2, 0xFF, 0x8A, 0x5B, 0xC6, 0xFF,    0xAE, 0x75, 0x00, 0xFF, 0xFF, 0x72, 0x21, 0xFF,
    0x11, 0x2C, 0xFF, 0xFF, 0x72, 0x11, 0xFF, 0xA4,    0x76, 0xA5, 0xFF, 0xBF, 0x78, 0x65, 0xFF, 0xA4,
    0x75, 0x2E, 0xFF, 0x2C, 0x5B, 0x1A, 0xFF, 0x32,    0x07, 0x5C, 0xFF, 0xA4, 0x3E, 0x75, 0xFF, 0xBE,
    0x7B, 0x75, 0x73, 0x13, 0x6B, 0x75, 0xAE, 0xFF,    0x75, 0x75, 0xA6, 0xFF, 0x75, 0x5C, 0x62, 0xFF,
    0x72, 0xB6, 0x66, 0x75, 0x75, 0x8F, 0x00, 0x75,    0x75, 0x11, 0x75, 0x75, 0x75, 0x11, 0x75, 0x75,
    0xB7, 0x72, 0x72, 0x75, 0x8F, 0x75, 0x5B, 0x75,    0x11, 0x75, 0x5B, 0x75, 0x11, 0x75, 0x5B, 0x76,
    0x5F, 0x06, 0xDE, 0xFF, 0x1F, 0x4E, 0x73, 0xFF,    0x70, 0x4D, 0x7A, 0xFF, 0xFF, 0x5B, 0xA7, 0x72,
    0x5B, 0x97, 0xFF, 0xDE, 0x08, 0x1F, 0xFF, 0x73,    0x3C, 0x6E, 0xFF, 0x7A, 0x08, 0xFF, 0x72, 0xA7,
    0xB4, 0x63, 0x84, 0x75, 0x1B, 0xFF, 0xD4, 0x75,    0x6D, 0xFF, 0xD4, 0x75, 0x75, 0xAD, 0xD4, 0x75,
    0x63, 0xB4, 0x75, 0x71, 0xFF, 0x1B, 0x75, 0xB2,    0xFF, 0x6D, 0x75, 0xBD, 0xAE, 0x75, 0x71, 0xD4,
    0x75, 0xD4, 0x4A, 0xB7, 0x75, 0xD4, 0x08, 0x54,    0x00, 0xC4, 0x00, 0x97, 0x45, 0x75, 0x75, 0x9A,
    0xD4, 0x5D, 0xB7, 0x2F, 0xBC, 0x75, 0xCF, 0x4F,    0x07, 0x00, 0x83, 0x31, 0x01, 0x45, 0x98, 0x33,
    0x96, 0x4C, 0x04, 0x46, 0x60, 0x16, 0x1C, 0x02,    0x6B, 0x93, 0xB1, 0x75, 0x4E, 0xAA, 0x91, 0x75,
    0x5B, 0x62, 0x12, 0x03, 0x2C, 0x65, 0x72, 0x2F,    0x35, 0xD9, 0x75, 0x0D, 0x06, 0x57, 0x76, 0xCA,
    0xFE, 0xCF, 0x75, 0xAA, 0xFF, 0x11, 0x5B, 0x61,    0xFF, 0x0D, 0x33, 0xAC, 0x7D, 0x72, 0xA0, 0xB4,
    0xA6, 0xFE, 0xCA, 0x75, 0x14, 0xFF, 0x77, 0x76,    0x2D, 0xFF, 0xCA, 0x44, 0x5B, 0x36, 0x11, 0x1C,
    0x2D, 0x12, 0xFF, 0xFF, 0x72, 0x11, 0xFF, 0xFF,    0x75, 0xD0, 0xFF, 0xFF, 0x5B, 0x2B, 0xFF, 0x7D,
    0x2F, 0x2D, 0xFF, 0xFF, 0xA1, 0x74, 0xFF, 0xFF,    0xCA, 0x75, 0x60, 0xFF, 0x73, 0x72, 0xC5, 0xFF,
    0x68, 0x05, 0x72, 0x18, 0x3F, 0x00, 0x4C, 0x1F,    0x9D, 0x75, 0x07, 0x01, 0x67, 0x75, 0x86, 0xFF,
    0x75, 0xBF, 0xC2, 0x75, 0x75, 0xB1, 0x6F, 0x67,    0x75, 0x06, 0xFF, 0x0E, 0x76, 0x3D, 0xFF, 0x2A,
    0xB7, 0x72, 0x72, 0x4C, 0x8F, 0x75, 0x5B, 0x3B,    0x11, 0x76, 0x72, 0x4E, 0x11, 0x78, 0x72, 0x78,
    0x72, 0xB6, 0x72, 0x3D, 0x75, 0x8F, 0x03, 0x50,    0x75, 0x11, 0x75, 0x2A, 0x75, 0x11, 0x75, 0x4F,
    0x03, 0x2C, 0xFF, 0xDE, 0x66, 0x25, 0xFF, 0x73,    0x32, 0x88, 0xFF, 0x7A, 0x4B, 0xC7, 0x72, 0xC9,
    0x70, 0x00, 0xDE, 0x61, 0x91, 0x75, 0x73, 0xFF,    0xA7, 0x75, 0x7A, 0xFF, 0xFD, 0x73, 0xC9, 0x72,
    0x63, 0xB4, 0x75, 0x03, 0xFF, 0x1B, 0x75, 0xC5,    0xFF, 0x6D, 0x75, 0xD4, 0xAD, 0x75, 0x75, 0xD4,
    0xB4, 0x63, 0x74, 0x75, 0x1B, 0xFF, 0x6C, 0x75,    0x6D, 0xFF, 0xCE, 0x75, 0x75, 0xAE, 0xD4, 0x00,
    0xD4, 0x5C, 0xB7, 0xBE, 0xD4, 0x75, 0x90, 0xBE,    0xD5, 0x00, 0x95, 0xBE, 0xB5, 0x45, 0x83, 0xBE,
    0x73, 0xD4, 0x06, 0xB7, 0x75, 0xD4, 0xB7, 0x90,    0x00, 0xB8, 0x22, 0x95, 0x45, 0x9E, 0x37, 0xBB,
    0x9D, 0xFF, 0x32, 0x5B, 0x06, 0xFF, 0x8B, 0x2F,    0xC5, 0x96, 0x6A, 0xA1, 0x81, 0x99, 0x75, 0xCA,
    0xFF, 0xBE, 0x72, 0x49, 0xFF, 0xBA, 0x2D, 0x09,    0x92, 0x83, 0xA0, 0x03, 0x85, 0xFF, 0xA7, 0x75,
    0xFE, 0x93, 0x75, 0xCF, 0xFF, 0x0E, 0x72, 0xFF,    0xFF, 0xA2, 0x30, 0xD1, 0x8C, 0x00, 0x9D, 0x29,
    0x38, 0xFE, 0xA7, 0x76, 0x13, 0xFF, 0x7C, 0x78,    0x33, 0xFF, 0xA8, 0x46, 0x5B, 0xB1, 0x57, 0x2A,
    0x2C, 0x08, 0xFF, 0xFF, 0x03, 0x25, 0xFF, 0xFF,    0x75, 0x97, 0xFF, 0xFF, 0x5B, 0x99, 0xFF, 0xFF,
    0x0C, 0x2E, 0xFF, 0xFF, 0x14, 0x04, 0xFF, 0xFF,    0xAC, 0x76, 0x62, 0xFF, 0x07, 0x00, 0xA5, 0xFF,
    0x91, 0x21, 0x00, 0x19, 0x01, 0x00, 0x04, 0x93,    0x4B, 0x76, 0x3E, 0xAE, 0x18, 0x75, 0x72, 0xFF,
    0x5B, 0xA0, 0xA8, 0x75, 0x75, 0xBC, 0x95, 0x75,    0x75, 0x7F, 0xFF, 0x67, 0x75, 0x17, 0xFF, 0x4E,
    0xB7, 0x72, 0x0F, 0x72, 0x8F, 0x75, 0x1D, 0x70,    0x11, 0x76, 0xB7, 0x35, 0x11, 0x04, 0xB7, 0x3D,
    0x72, 0xB7, 0x0E, 0x2B, 0x75, 0x8F, 0x09, 0x5B,    0x75, 0x11, 0x72, 0x06, 0x75, 0x11, 0x03, 0x78,
    0x75, 0x76, 0xFF, 0xDE, 0x76, 0x3F, 0xFF, 0x73,    0x73, 0x78, 0xFF, 0x7A, 0x37, 0xC6, 0x72, 0xC9,
    0x4C, 0x06, 0xDE, 0x04, 0x67, 0x03, 0x73, 0xFF,    0xD9, 0x75, 0x7A, 0xFF, 0x1B, 0x76, 0xA7, 0x72,
    0x63, 0xB4, 0x75, 0x98, 0xFF, 0x1B, 0x75, 0xD4,    0xFF, 0x6D, 0x75, 0xD4, 0xAE, 0x75, 0x75, 0xD4,
    0xB4, 0x63, 0x70, 0x75, 0x1B, 0xFF, 0x9B, 0x75,    0x6D, 0xFF, 0xBB, 0x75, 0x75, 0xAD, 0xD4, 0x7D,
    0xD4, 0x76, 0xB7, 0x73, 0xD4, 0x75, 0x90, 0x73,    0xD4, 0x00, 0xD2, 0x73, 0x2A, 0x45, 0xD2, 0x73,
    0x70, 0xD4, 0x10, 0xB7, 0x75, 0xD4, 0x22, 0xAB,    0x00, 0xCA, 0x1E, 0x6E, 0x45, 0x73, 0x1E, 0x81,
    0x9E, 0xFF, 0x49, 0x5B, 0x83, 0xFF, 0x09, 0x30,    0xA7, 0x96, 0x03, 0xA1, 0xFD, 0x99, 0x75, 0xA8,
    0xFF, 0x73, 0x5B, 0x49, 0xFF, 0x66, 0x2F, 0x09,    0x95, 0x69, 0x13, 0x03, 0x99, 0xFF, 0xC8, 0x75,
    0xD3, 0xFE, 0x95, 0x6B, 0x37, 0xFF, 0xFF, 0xA0,    0x19, 0x61, 0x98, 0x4A, 0x03, 0xCA, 0x9A, 0x86,
    0xFE, 0x1D, 0x6A, 0xC6, 0xFF, 0x43, 0x09, 0xC5,    0xFF, 0x76, 0x31, 0xC6, 0x97, 0x75, 0x84, 0x83,
    0x7B, 0x27, 0xFF, 0x64, 0x34, 0x10, 0xFF, 0xFF,    0xB1, 0x72, 0xFF, 0xFF, 0x92, 0x75, 0xFF, 0xFF,
    0x33, 0x03, 0xFF, 0xFF, 0x19, 0x43, 0xFF, 0xFF,    0x03, 0x23, 0xFF, 0xFF, 0x6A, 0xA7, 0xFF, 0xFF,
    0x35, 0xFF, 0x4D, 0x00, 0x4F, 0xFF, 0x7A, 0x75,    0x5C, 0x61, 0xC4, 0x75, 0x75, 0xCA, 0x7C, 0x5D,
    0xFF, 0xAB, 0x75, 0x19, 0x86, 0x70, 0x75, 0x2A,    0xBF, 0xAF, 0x00, 0xB7, 0x8B, 0x09, 0x09, 0xCA,
    0x72, 0x1C, 0xC2, 0x31, 0x75, 0x91, 0xAD, 0x85,    0x76, 0x11, 0x06, 0x93, 0x04, 0x11, 0x0E, 0xFF,
    0x9E, 0x72, 0x1A, 0xFF, 0x8F, 0x75, 0xB4, 0xFD,    0x11, 0x76, 0xC0, 0xAD, 0x11, 0x04, 0xC0, 0x90,
    0x01, 0x07, 0xDE, 0x5A, 0x36, 0x35, 0x73, 0x65,    0x11, 0x5B, 0x7A, 0xFF, 0xD2, 0x75, 0xA7, 0x72,
    0x4F, 0x75, 0x98, 0xDE, 0x5B, 0x00, 0xFF, 0x73,    0x75, 0x2A, 0xFF, 0x7A, 0x75, 0x14, 0x72, 0xA7,
    0xB4, 0x63, 0xBF, 0x75, 0x1B, 0xFF, 0xD4, 0x00,    0x6D, 0xFF, 0xD4, 0x06, 0x75, 0xAE, 0xD4, 0xC2,
    0x63, 0xB4, 0x75, 0xD4, 0xFF, 0x1B, 0x75, 0xD4,    0xFF, 0x6D, 0x72, 0xAC, 0xAD, 0x75, 0x7B, 0xB3,
    0x75, 0xD4, 0xFF, 0xB7, 0x75, 0xD9, 0xFF, 0xA9,    0x00, 0x68, 0xFF, 0x64, 0x45, 0x03, 0xFF, 0xFF,
    0xD4, 0x75, 0xB7, 0xFF, 0xD4, 0x75, 0xDE, 0xFF,    0xB2, 0x00, 0x61, 0xFF, 0x71, 0x45, 0xFF, 0xFF,
    0xFF, 0xFF, 0x5B, 0x49, 0xFF, 0xFF, 0x30, 0x09,    0x96, 0xFF, 0xA1, 0x03, 0x99, 0xFF, 0xA9, 0x75,
    0xFF, 0xFF, 0x49, 0x5B, 0xFF, 0xFF, 0x09, 0x30,    0xFF, 0x96, 0x03, 0xA1, 0xFF, 0x99, 0x75, 0xA9,
    0x29, 0xFE, 0xC4, 0x5B, 0x2F, 0xFF, 0x83, 0x0D,    0x05, 0x63, 0xC6, 0x1D, 0x76, 0x5A, 0x95, 0x73,
    0xFE, 0x9F, 0x5D, 0x5C, 0xFF, 0x45, 0x08, 0x81,    0xFF, 0x72, 0x37, 0x5C, 0x91, 0x75, 0x98, 0x73,
    0x06, 0x0D, 0xFF, 0x79, 0x45, 0x22, 0xFF, 0xFF,    0xB4, 0x5B, 0xFF, 0xFF, 0xAC, 0x75, 0xFF, 0xFF,
    0x24, 0x5B, 0xFE, 0xFF, 0x17, 0x44, 0xFF, 0xFF,    0x00, 0xA0, 0xFF, 0xFF, 0x76, 0xA5, 0xFF, 0xFF,
    0x5C, 0xFF, 0x44, 0x72, 0x50, 0xFF, 0x18, 0x76,    0x22, 0xFF, 0xD1, 0x75, 0x67, 0x65, 0x99, 0x75,
    0xFF, 0xC1, 0x75, 0x72, 0xFF, 0x82, 0x75, 0x2A,    0x92, 0x8B, 0x75, 0xA4, 0xC5, 0x29, 0x67, 0xAA,
    0x72, 0x98, 0x87, 0x31, 0x75, 0xD2, 0xA6, 0xAF,    0x76, 0x11, 0xC4, 0x92, 0x04, 0x11, 0x06, 0xFF,
    0xA1, 0x72, 0x31, 0xFF, 0x8F, 0x75, 0x86, 0xFF,    0x11, 0x76, 0xA6, 0x6E, 0x11, 0x04, 0x9C, 0xC5,
    0x6A, 0x15, 0xDE, 0xA8, 0x04, 0x43, 0x73, 0x80,    0x46, 0x5D, 0x7A, 0xFF, 0xB4, 0x75, 0xA7, 0x72,
    0x4D, 0x75, 0xCD, 0xDE, 0xA3, 0x5B, 0xFD, 0x73,    0x00, 0x30, 0xFF, 0x7A, 0x75, 0x15, 0x72, 0xA7,
    0xB4, 0x63, 0xD4, 0x75, 0x1B, 0xFF, 0xD4, 0x71,    0x6D, 0xFF, 0xD4, 0xB0, 0x75, 0xAD, 0xC1, 0xD4,
    0x63, 0xB4, 0x75, 0xD5, 0xFF, 0x1B, 0x75, 0xCC,    0xFF, 0x6D, 0x7D, 0x01, 0xAE, 0x75, 0x9A, 0x04,
    0x75, 0xBE, 0xFF, 0xB7, 0x75, 0xD4, 0xFF, 0xA9,    0x00, 0x98, 0xFF, 0x64, 0x45, 0x71, 0xFF, 0xFF,
    0xD4, 0x75, 0xB7, 0xFF, 0xC0, 0x75, 0xA9, 0xFF,    0x04, 0x00, 0x64, 0xFF, 0x00, 0x45, 0xFF, 0xFF,
    0xFF, 0xFF, 0x5B, 0x49, 0xFF, 0xFF, 0x30, 0x09,    0x96, 0xFF, 0xA1, 0x03, 0x99, 0xFF, 0xA9, 0x75,
    0xFF, 0xFF, 0x49, 0x5B, 0xFF, 0xFF, 0x09, 0x30,    0xFF, 0x96, 0x03, 0xA1, 0xFF, 0x99, 0x75, 0xA9,
    0xFE, 0x11, 0x5B, 0x5D, 0xFF, 0x9F, 0x22, 0x5D,    0x71, 0x72, 0x3B, 0x5D, 0xA7, 0x75, 0x4C, 0x5D,
    0xA1, 0xFE, 0x4C, 0x75, 0x2F, 0xFF, 0x3F, 0x76,    0x5B, 0x1A, 0x4C, 0x5D, 0x75, 0x54, 0x4C, 0x5D,
    0x3B, 0x6B, 0x5B, 0xFF, 0xB7, 0x14, 0xFF, 0x6F,    0x66, 0x0F, 0xFF, 0x8B, 0x75, 0xD1, 0xFF, 0x85,
    0x5B, 0x5D, 0xFF, 0x89, 0x30, 0x76, 0xFF, 0xFF,    0x14, 0x75, 0xFF, 0xFF, 0xA8, 0x75, 0xFF, 0xFF,
    0xFF, 0xFF, 0x0D, 0x75, 0xFF, 0x64, 0x66, 0x6A,    0xFF, 0xC5, 0x75, 0x46, 0xFF, 0xB2, 0x75, 0x12,
    0xA3, 0xCF, 0x5B, 0x34, 0xBF, 0xD9, 0x0D, 0x10,    0xA1, 0xB2, 0x25, 0x72, 0x2D, 0xFF, 0x98, 0x75,
    0xC0, 0x72, 0x31, 0xFF, 0x92, 0x75, 0xAF, 0xFF,    0x12, 0x76, 0x92, 0xFF, 0x11, 0x04, 0xFF, 0x96,
    0x72, 0xD6, 0xFF, 0x31, 0x75, 0xCF, 0xFF, 0xAF,    0x76, 0x13, 0xFE, 0x92, 0x04, 0x11, 0xAB, 0xFF,
    0xB4, 0x75, 0xAE, 0xDE, 0x45, 0x00, 0x11, 0x73,    0x06, 0x08, 0xFF, 0x7A, 0x76, 0x0E, 0x72, 0xC9,
    0x75, 0x98, 0xDE, 0x92, 0x5B, 0x35, 0x73, 0xB1,    0x37, 0x19, 0x7A, 0xFF, 0x12, 0x5D, 0xA7, 0x72,
    0x63, 0xB4, 0x75, 0xD6, 0xFF, 0x1B, 0x70, 0x9E,    0xFF, 0x6D, 0xB0, 0x5C, 0xAD, 0x75, 0xD4, 0x75,
    0xB4, 0x63, 0xD9, 0x75, 0x1B, 0xFF, 0x66, 0x03,    0x6D, 0xFF, 0x01, 0x72, 0x75, 0xAD, 0x70, 0xC5,
    0x82, 0x73, 0xB7, 0xC4, 0xD4, 0x76, 0xAA, 0xC4,    0xC0, 0x00, 0x62, 0xC4, 0x06, 0x45, 0xFF, 0xC4,
    0x72, 0x70, 0xFF, 0x0F, 0x75, 0xB4, 0xFF, 0xC0,    0x00, 0xD4, 0xFF, 0xC4, 0x45, 0x5A, 0xFF, 0xC4,
    0xFF, 0xFF, 0x49, 0x5B, 0xFF, 0xFF, 0x09, 0x30,    0xFF, 0x96, 0x03, 0xA1, 0xFF, 0x99, 0x75, 0xA9,
    0xFF, 0xC4, 0x5B, 0x49, 0xFF, 0xC3, 0x30, 0x09,    0x96, 0xC9, 0xA1, 0x03, 0x99, 0x6F, 0xA9, 0x75,
    0xFE, 0x9D, 0x76, 0x75, 0xFF, 0x08, 0x78, 0x75,    0x09, 0x00, 0x19, 0x75, 0xCC, 0x75, 0x19, 0x75,
    0x13, 0xFF, 0x19, 0x75, 0x35, 0xFF, 0x19, 0x75,    0x5B, 0x84, 0x19, 0x75, 0x75, 0x94, 0x19, 0x75,
    0x19, 0x03, 0xA0, 0xA7, 0x78, 0xA3, 0xFF, 0xBE,    0x76, 0x22, 0xFF, 0xBD, 0x75, 0xD3, 0xFF, 0xC1,
    0x5B, 0x75, 0xFF, 0xD3, 0x22, 0x75, 0xFF, 0x70,    0x12, 0x75, 0xFF, 0xB3, 0xAD, 0x75, 0xFF, 0xD2,
    0xFF, 0xFF, 0x29, 0x75, 0x61, 0xFF, 0x03, 0x72,    0x62, 0x2C, 0x75, 0x31, 0xFF, 0xCA, 0x75, 0x08,
    0xFF, 0xDE, 0x6A, 0x09, 0x98, 0xD9, 0x09, 0x43,    0xA6, 0xD3, 0x2E, 0x5B, 0x75, 0xFF, 0x59, 0x75,
    0xD4, 0x72, 0x31, 0xFF, 0x8F, 0x75, 0xAF, 0xFF,    0x13, 0x76, 0x92, 0xFF, 0x11, 0x04, 0xFF, 0x98,
    0x72, 0xC0, 0xFF, 0x31, 0x75, 0xAE, 0xFF, 0xAF,    0x76, 0x13, 0xFF, 0x92, 0x04, 0x11, 0xD2, 0xFF,
    0x85, 0x75, 0xD0, 0xDE, 0x31, 0x03, 0x2C, 0x73,    0x7B, 0xA3, 0xFF, 0x7A, 0x03, 0x24, 0x72, 0xA7,
    0x75, 0x60, 0xDE, 0x93, 0x72, 0x36, 0x73, 0x83,    0x13, 0x18, 0x7A, 0xFF, 0x0F, 0x00, 0xC9, 0x72,
    0x63, 0xB4, 0x75, 0xD4, 0xFF, 0x1B, 0x5C, 0x8A,    0xFF, 0x6D, 0x9D, 0x70, 0xAD, 0x75, 0xD5, 0x75,
    0xB4, 0x63, 0x1F, 0x75, 0x1B, 0xFF, 0x75, 0x75,    0x6D, 0xFF, 0x03, 0x7D, 0x75, 0xAE, 0x03, 0xD2,
    0x70, 0x08, 0xB7, 0x98, 0xC7, 0x5C, 0xDE, 0x98,    0xD4, 0x03, 0x6F, 0x98, 0xB0, 0x45, 0x61, 0x98,
    0x71, 0x03, 0x62, 0x9F, 0x75, 0x03, 0x62, 0xBA,    0x00, 0xC3, 0x62, 0xC2, 0x45, 0xB8, 0x62, 0xD3,
    0x62, 0xFF, 0x49, 0x5B, 0x62, 0xFF, 0x09, 0x30,    0x61, 0x96, 0x03, 0xA1, 0xFE, 0x99, 0x75, 0xA9,
    0xFF, 0x98, 0x5B, 0x49, 0xFF, 0x95, 0x30, 0x09,    0x96, 0xC1, 0xA1, 0x03, 0x99, 0x65, 0xA8, 0x75,
    0x1E, 0xFF, 0x75, 0x78, 0x09, 0x64, 0x75, 0x9C,    0x6A, 0xCA, 0x75, 0x23, 0x75, 0x1E, 0x75, 0x24,
    0xFF, 0x43, 0x75, 0x24, 0xFF, 0x03, 0x75, 0x24,    0x95, 0x75, 0x75, 0x24, 0x9A, 0x76, 0x75, 0x24,
    0x76, 0x23, 0x91, 0xBB, 0x04, 0x0D, 0x86, 0xC3,    0x30, 0x77, 0x08, 0x78, 0x2B, 0x76, 0x67, 0x3F,
    0x75, 0x75, 0xA6, 0x3E, 0x75, 0x00, 0xC0, 0x29,    0x75, 0x2C, 0xC0, 0x2E, 0x75, 0x14, 0xC6, 0x0D,
    0xFF, 0x20, 0x75, 0xD2, 0xFF, 0x8A, 0x5B, 0x24,    0xFC, 0x90, 0x1D, 0x13, 0xA5, 0xFF, 0x08, 0x80,
    0x79, 0xFF, 0x9B, 0x75, 0x99, 0xFF, 0x44, 0x5B,    0x97, 0xFF, 0x74, 0x25, 0xFF, 0x83, 0x76, 0x12,
    0x72, 0xAB, 0xFF, 0x31, 0x75, 0xAC, 0xFF, 0xAF,    0x76, 0x13, 0xFF, 0x92, 0x04, 0x11, 0x98, 0xFF,
    0xC7, 0x72, 0x31, 0xFF, 0xAD, 0x75, 0xAF, 0xFF,    0x13, 0x76, 0x92, 0xFF, 0x11, 0x04, 0xFF, 0x93,
    0x75, 0x84, 0xA9, 0x92, 0x03, 0x48, 0x73, 0x87,    0xA4, 0x09, 0x7A, 0xFF, 0x24, 0x03, 0xA7, 0x72,
    0x60, 0x75, 0x94, 0xDE, 0x36, 0x00, 0x82, 0x73,    0x18, 0x07, 0xFF, 0x7A, 0x00, 0x25, 0x72, 0xA7,
    0xB4, 0x63, 0xD4, 0x75, 0x1B, 0xFF, 0x82, 0x75,    0x6D, 0xFF, 0x71, 0x00, 0x75, 0xAE, 0x75, 0x04,
    0x63, 0x2B, 0x75, 0xBD, 0xFF, 0x32, 0x75, 0xC8,    0xFF, 0x6D, 0x70, 0x70, 0xAD, 0x75, 0x86, 0x75,
    0x82, 0x75, 0x78, 0x9F, 0x71, 0x03, 0x78, 0xB9,    0x03, 0x03, 0x78, 0xAC, 0x45, 0xC3, 0x05, 0x14,
    0x75, 0xD4, 0x9F, 0x11, 0x7D, 0x95, 0xB8, 0x67,    0x0B, 0x7D, 0xCE, 0x03, 0xD4, 0x2D, 0x7C, 0x5C,
    0xFF, 0x2F, 0x5B, 0x49, 0xFF, 0x12, 0x30, 0x09,    0x96, 0x5A, 0xA1, 0x03, 0x99, 0x79, 0xA8, 0x75,
    0x76, 0xFF, 0x49, 0x5B, 0x01, 0xFF, 0x09, 0x2F,    0x5A, 0x96, 0x03, 0x14, 0x79, 0x99, 0x75, 0xC9,
    0x2F, 0xFF, 0x5B, 0x13, 0x06, 0x79, 0x5B, 0x3A,    0x76, 0xC7, 0x5B, 0x50, 0x75, 0xA0, 0x5B, 0x50,
    0xFF, 0x2C, 0x76, 0x50, 0xFF, 0x5B, 0x5B, 0x50,    0x91, 0x75, 0x5B, 0x50, 0x2B, 0x72, 0x5B, 0x50,
    0x76, 0x4D, 0x01, 0xC3, 0x74, 0x3A, 0x19, 0xBF,    0x44, 0x0F, 0x30, 0x15, 0x9B, 0x5B, 0x3E, 0x2C,
    0x5B, 0x75, 0xBA, 0x00, 0x5B, 0x5B, 0xD9, 0x5B,    0x76, 0x20, 0x76, 0x5C, 0x75, 0x07, 0x71, 0x5C,
    0xFF, 0x44, 0x75, 0xD1, 0xFF, 0x9D, 0x5B, 0x0E,    0xFF, 0xCA, 0x0C, 0x10, 0xD2, 0x64, 0x13, 0x72,
    0x35, 0xFF, 0x99, 0x75, 0x83, 0xFF, 0xB7, 0x5B,    0x93, 0xFF, 0x7A, 0x25, 0xFF, 0x2C, 0x03, 0x12,
    0x72, 0xAB, 0xFF, 0x31, 0x75, 0xAC, 0xFF, 0xAF,    0x76, 0x13, 0xFF, 0x92, 0x04, 0x11, 0x97, 0xFF,
    0xDE, 0x72, 0x31, 0xFF, 0xAC, 0x75, 0xAF, 0xFF,    0x13, 0x76, 0x92, 0xFF, 0x11, 0x04, 0xFF, 0xAE,
    0x75, 0x2A, 0xA9, 0x90, 0x5D, 0x46, 0x73, 0x2E,    0x18, 0x8C, 0x7A, 0xFF, 0x25, 0x76, 0xA7, 0x72,
    0x98, 0x75, 0x93, 0xDE, 0x34, 0x72, 0x83, 0x73,    0xA4, 0xA0, 0xFF, 0x7A, 0x5D, 0x10, 0x72, 0xA7,
    0xB4, 0x63, 0xD4, 0x75, 0x1B, 0xFF, 0x8F, 0x75,    0x6D, 0xFF, 0x71, 0x01, 0x75, 0x8E, 0x75, 0x04,
    0x63, 0x8A, 0x75, 0xBE, 0xFF, 0x32, 0x75, 0xC3,    0xFF, 0x6D, 0x5C, 0x00, 0xAD, 0x76, 0x9B, 0x03,
    0xBC, 0x75, 0x40, 0x10, 0x07, 0x03, 0x3E, 0xB8,    0x73, 0x00, 0x3E, 0xAC, 0x45, 0xD9, 0x3E, 0x14,
    0x75, 0xD4, 0x9F, 0x10, 0x01, 0x8E, 0xB9, 0x5B,    0x12, 0x71, 0xAC, 0x76, 0xB9, 0x2D, 0x16, 0x01,
    0xFF, 0x2E, 0x5B, 0x35, 0xFF, 0x12, 0x1A, 0x09,    0x96, 0x5A, 0xA1, 0x03, 0x99, 0x79, 0xCA, 0x75,
    0x3A, 0xFF, 0x49, 0x72, 0x16, 0xFF, 0x09, 0x20,    0x5A, 0x95, 0x03, 0x12, 0x79, 0x99, 0x75, 0xC8,
    0xFF, 0x10, 0x23, 0x58, 0x01, 0x5B, 0x0F, 0x8A,    0xCA, 0x75, 0x73, 0x58, 0xA1, 0x5B, 0x6A, 0x84,
    0x30, 0xFF, 0x5D, 0x33, 0x5B, 0x4F, 0x5D, 0x15,    0x75, 0x91, 0x5D, 0xC5, 0x5B, 0x10, 0x6A, 0x82,
    0x73, 0x75, 0xA7, 0x18, 0x11, 0x00, 0xB9, 0x03,    0xB7, 0x15, 0x11, 0x75, 0x5B, 0x0F, 0x2F, 0x03,
    0x75, 0xC5, 0x6B, 0x94, 0x5B, 0xA0, 0x75, 0xD4,    0x32, 0x2E, 0x75, 0x87, 0x17, 0x5B, 0x72, 0x33,
    0x45, 0x9E, 0x91, 0x75, 0x07, 0x65, 0x9D, 0x5B,    0xC8, 0x89, 0x10, 0x32, 0x03, 0x1F, 0x72, 0x08,
    0xFF, 0x09, 0x75, 0xA0, 0xFF, 0x44, 0x5B, 0x43,    0xFF, 0x9C, 0x24, 0x06, 0x8A, 0x1F, 0x13, 0x76,
    0xA9, 0x72, 0x31, 0x1A, 0xAC, 0x75, 0xAF, 0x91,    0x13, 0x76, 0x92, 0xBF, 0x11, 0x04, 0xFF, 0x0F,
    0x72, 0xC1, 0xFF, 0x31, 0x75, 0xAE, 0xFF, 0x86,    0x76, 0x13, 0x6F, 0xA6, 0x04, 0x11, 0xC6, 0x1E,
    0x9F, 0x75, 0xAE, 0xDE, 0x2B, 0x72, 0xA0, 0x73,    0x76, 0x2B, 0xFF, 0x7A, 0x75, 0xA0, 0x72, 0xC9,
    0x75, 0x2D, 0xDE, 0xA6, 0x5B, 0x14, 0x73, 0x79,    0x22, 0x72, 0x7A, 0xFF, 0x11, 0x75, 0xA7, 0x72,
    0x63, 0x9A, 0x75, 0x8B, 0xFF, 0x35, 0x76, 0x78,    0xFF, 0x04, 0x01, 0x76, 0x90, 0x76, 0x94, 0x75,
    0x89, 0x63, 0xD4, 0x75, 0x32, 0xFF, 0xBE, 0x76,    0x06, 0xFF, 0x04, 0x77, 0x76, 0x94, 0x72, 0x07,
    0x75, 0x73, 0x9D, 0x24, 0x76, 0x76, 0xD5, 0x72,    0x70, 0x78, 0xAC, 0x75, 0xC8, 0x2E, 0x14, 0x66,
    0xBB, 0x75, 0x0F, 0x59, 0x09, 0x75, 0x72, 0xD4,    0x01, 0x74, 0x75, 0xAB, 0x45, 0x72, 0x5B, 0x16,
    0x2E, 0xFF, 0x32, 0x06, 0x12, 0x62, 0x7B, 0x33,    0x5A, 0xA5, 0x03, 0xB2, 0x79, 0x1E, 0x75, 0xAE,
    0xFF, 0x31, 0x00, 0x2F, 0xFF, 0x16, 0x2E, 0x6A,    0x93, 0xA7, 0x0F, 0x75, 0x83, 0x06, 0xCA, 0x76,
    0xFF, 0x18, 0xB7, 0xFF, 0x16, 0x5D, 0x16, 0xFF,    0xAC, 0x75, 0xAD, 0xFF, 0x13, 0x72, 0xC0, 0xFD,
    0x36, 0xFF, 0x1F, 0x31, 0x5B, 0x99, 0x1F, 0x9D,    0x75, 0x95, 0x1F, 0x5A, 0x5B, 0x25, 0xC0, 0x62,
    0xAB, 0x75, 0xAE, 0x24, 0xA2, 0x03, 0xD4, 0x5B,    0x34, 0x09, 0xB6, 0x75, 0x66, 0x4A, 0x45, 0x75,
    0x75, 0xA7, 0x78, 0x85, 0x5B, 0x0C, 0x76, 0xD4,    0x0E, 0x2C, 0x75, 0x95, 0x14, 0x03, 0x5B, 0x11,
    0x1E, 0xBA, 0x97, 0x75, 0x12, 0xBF, 0x22, 0x00,    0x91, 0xBE, 0x07, 0x2E, 0x60, 0xB2, 0x00, 0xA1,
    0xFF, 0x5B, 0x75, 0x08, 0xFF, 0x4D, 0x5B, 0x2A,    0xFF, 0x09, 0xB7, 0x66, 0x92, 0x99, 0x07, 0x75,
    0xC8, 0x72, 0x31, 0xBF, 0xCE, 0x75, 0x85, 0xA5,    0x13, 0x76, 0x93, 0x57, 0x11, 0x04, 0xFF, 0x7B,
    0x72, 0xB9, 0xFF, 0x30, 0x75, 0x8E, 0xFF, 0xB4,    0x76, 0x13, 0xD3, 0xBF, 0x04, 0x11, 0xDE, 0xBE,
    0x19, 0x76, 0xA8, 0xDE, 0x30, 0x06, 0x5D, 0x73,    0x5B, 0x2B, 0xFF, 0x7A, 0x75, 0xB6, 0x72, 0xC9,
    0x75, 0x3F, 0xDE, 0xA9, 0x5B, 0x03, 0x73, 0x61,    0x31, 0x75, 0x7A, 0xFF, 0x14, 0x75, 0xA7, 0x72,
    0x63, 0x97, 0x75, 0x5B, 0xFF, 0x22, 0x70, 0x00,    0xFF, 0x08, 0x89, 0x75, 0x92, 0x00, 0xBE, 0x75,
    0x86, 0x63, 0x1F, 0x75, 0x34, 0xFF, 0xC6, 0x75,    0x06, 0xFF, 0x04, 0x03, 0x76, 0xD3, 0x00, 0x66,
    0x75, 0x75, 0xB7, 0x36, 0x75, 0x03, 0xD4, 0x5B,    0x5C, 0x09, 0xAC, 0x75, 0x94, 0x32, 0x15, 0x72,
    0xB3, 0x75, 0x0F, 0x86, 0x70, 0x75, 0x72, 0xC4,    0x74, 0x75, 0x75, 0xCC, 0x2D, 0x76, 0x5B, 0x16,
    0x2E, 0x7B, 0x30, 0x7B, 0x13, 0xD2, 0x05, 0x36,    0xA6, 0xA7, 0x76, 0x82, 0x79, 0xA4, 0x75, 0x93,
    0xFF, 0x9D, 0x76, 0x20, 0xFF, 0x13, 0x30, 0x5B,    0x8F, 0x95, 0x5F, 0x75, 0x88, 0x5A, 0xDE, 0x76,
    0x8B, 0xFC, 0xFF, 0x30, 0x76, 0xC9, 0xFF, 0x86,    0x75, 0x9C, 0xFF, 0xD1, 0x03, 0x2C, 0xFD, 0xFF,
    0xFF, 0x5D, 0x2E, 0xFF, 0x93, 0x75, 0x35, 0xFF,    0x9A, 0x76, 0xDE, 0xFF, 0x36, 0x04, 0x61, 0xFF,
    0x76, 0xD2, 0x2D, 0x9E, 0x76, 0x85, 0x01, 0xCE,    0x77, 0x32, 0x75, 0xAE, 0x2E, 0x09, 0x75, 0xD3,
    0x38, 0x76, 0x59, 0x9D, 0x1A, 0x75, 0xB9, 0x4A,    0x45, 0x80, 0xC9, 0x01, 0x75, 0x2C, 0x09, 0x75,
    0x9F, 0x75, 0x76, 0x66, 0x2C, 0x75, 0x04, 0x75,    0x04, 0x67, 0x2D, 0x75, 0x77, 0xA3, 0x1D, 0x75,
    0x00, 0x4F, 0x4B, 0x5B, 0x19, 0x29, 0x7B, 0x4F,    0x3E, 0x2F, 0x5D, 0x19, 0x02, 0x04, 0x75, 0xCC,
    0x72, 0x93, 0x06, 0x10, 0x75, 0xD2, 0x73, 0x36,    0x76, 0x11, 0x15, 0x37, 0x04, 0x11, 0x3B, 0x1E,
    0xD4, 0x72, 0x2B, 0x22, 0xCF, 0x75, 0x5B, 0x08,    0x13, 0x75, 0x78, 0x72, 0x11, 0x75, 0x77, 0x72,
    0x00, 0x75, 0xDE, 0x79, 0x17, 0x75, 0x73, 0xFF,    0x37, 0x75, 0x7A, 0xFF, 0xD3, 0x03, 0xA7, 0x72,
    0x09, 0x77, 0xD2, 0xDE, 0x00, 0x4D, 0xFF, 0x73,    0x75, 0xA3, 0xFF, 0x7A, 0x75, 0xC5, 0x72, 0xA7,
    0x90, 0x63, 0x75, 0x75, 0x0E, 0xFF, 0x75, 0x75,    0x25, 0xFF, 0x75, 0x75, 0x5B, 0x65, 0x75, 0x75,
    0x63, 0xA5, 0x75, 0x75, 0xFF, 0x13, 0x75, 0x75,    0xFF, 0x2A, 0x75, 0x75, 0xB3, 0x03, 0x75, 0x75,
    0x75, 0x75, 0x2D, 0xC7, 0x6B, 0x75, 0x5B, 0x79,    0xA1, 0x75, 0x75, 0xD1, 0x23, 0x75, 0x76, 0x87,
    0x75, 0x75, 0x98, 0x31, 0x75, 0x72, 0x95, 0xA3,    0x75, 0x43, 0xCB, 0x00, 0x75, 0xA2, 0x14, 0x75,
    0xBA, 0x76, 0x13, 0x5E, 0xC1, 0x03, 0x24, 0x75,    0x15, 0x29, 0x94, 0x75, 0x2F, 0x4C, 0x83, 0x72,
    0x7B, 0x33, 0x0F, 0x2A, 0x4D, 0x4E, 0x72, 0x15,    0x6A, 0x4B, 0x75, 0xA5, 0xCA, 0x7B, 0x72, 0x6E,
    0x06, 0x6C, 0xFF, 0x34, 0x76, 0x5A, 0xFF, 0x9A,    0x76, 0x13, 0xFF, 0x94, 0x06, 0x2D, 0xFF, 0xFF,
    0xFE, 0x5B, 0x2D, 0xFF, 0xCE, 0x75, 0x58, 0xFF,    0x2B, 0x03, 0xAD, 0xFF, 0x20, 0x7A, 0xFF, 0xFF,
    0x76, 0x97, 0x2A, 0x13, 0x75, 0x98, 0x04, 0xAB,    0x75, 0x36, 0x76, 0x8A, 0x2C, 0x08, 0x75, 0xA6,
    0x8F, 0x03, 0xB7, 0x06, 0xB3, 0x75, 0x5A, 0x4C,    0x2E, 0x66, 0xC6, 0x75, 0x78, 0x2E, 0x9D, 0x76,
    0x4A, 0x75, 0x5B, 0x75, 0x13, 0x75, 0x0F, 0x75,    0x44, 0x75, 0x41, 0x75, 0x3D, 0x00, 0x82, 0x72,
    0x75, 0x01, 0x13, 0x08, 0x5B, 0x01, 0x5B, 0x4F,    0x9D, 0x01, 0x75, 0x9B, 0x3D, 0x03, 0x75, 0xC9,
    0x72, 0x7E, 0x4E, 0x5B, 0x75, 0x91, 0x21, 0x01,    0x76, 0x11, 0x3F, 0x66, 0x78, 0x11, 0xA3, 0x66,
    0xBB, 0x72, 0x3D, 0x5B, 0xD1, 0x75, 0x4D, 0x00,    0x12, 0x75, 0x4F, 0x75, 0x11, 0x75, 0x4F, 0x75,
    0x01, 0x75, 0xDE, 0xFF, 0x2C, 0x75, 0x73, 0xFF,    0x18, 0x75, 0x7A, 0xFF, 0xCC, 0x5C, 0xA7, 0x72,
    0x72, 0x2B, 0x1A, 0xDE, 0x75, 0x15, 0xFF, 0x73,    0x75, 0x60, 0xFF, 0x7A, 0x75, 0x8E, 0x72, 0xA7,
    0xDE, 0x63, 0x75, 0x00, 0x15, 0xFF, 0x75, 0x75,    0x1A, 0xFF, 0x75, 0x75, 0x66, 0xFF, 0x75, 0x75,
    0x63, 0xAD, 0x75, 0x75, 0xFF, 0x87, 0x75, 0x75,    0xFF, 0x31, 0x75, 0x75, 0x8B, 0x08, 0x75, 0x75,
    0x75, 0x75, 0x2A, 0xCA, 0x5B, 0x75, 0x75, 0xFF,    0x22, 0x75, 0x75, 0x88, 0x15, 0x75, 0x75, 0x90,
    0x75, 0x03, 0x8E, 0x07, 0x75, 0x7B, 0x9C, 0x30,    0x75, 0x2A, 0xAB, 0x67, 0x75, 0x7E, 0x57, 0x75,
    0x07, 0x75, 0x34, 0x75, 0x03, 0x03, 0x13, 0x75,    0x13, 0x6B, 0xCE, 0x03, 0x4C, 0x13, 0x0D, 0x09,
    0x5B, 0x33, 0x03, 0x20, 0x2C, 0x0E, 0x75, 0x8A,    0x2E, 0x56, 0x75, 0xA9, 0x68, 0x72, 0x66, 0xFE,
    0x76, 0x70, 0x37, 0xFF, 0xAA, 0x67, 0x97, 0xFF,    0x15, 0x70, 0xD3, 0xFF, 0x31, 0x0F, 0xFF, 0xFF,
    0x66, 0x87, 0xFF, 0x0E, 0x75, 0xD2, 0xFF, 0xAE,    0x00, 0x0F, 0xFF, 0x0F, 0x07, 0xA3, 0xFF, 0xFF,
    0xB2, 0x70, 0x14, 0xC7, 0x97, 0x67, 0xCD, 0x97,    0x24, 0x70, 0x7B, 0x81, 0x14, 0x09, 0xCA, 0x3A,
    0x72, 0x7B, 0x89, 0x26, 0x75, 0xCC, 0x23, 0x93,    0x5B, 0x14, 0x2E, 0x83, 0xB7, 0x0E, 0x73, 0xFF,
    0x75, 0x75, 0x75, 0x71, 0x75, 0x75, 0x75, 0xD9,    0x75, 0x76, 0x03, 0x99, 0x75, 0x00, 0x5E, 0xFF,
    0x75, 0x11, 0x3F, 0x5C, 0x75, 0x73, 0x05, 0x74,    0x75, 0x72, 0x8E, 0x4D, 0x75, 0x76, 0x99, 0x4E,
    0x13, 0x70, 0x75, 0x67, 0x54, 0x67, 0x75, 0x67,    0x11, 0x67, 0x75, 0x01, 0x11, 0x67, 0x75, 0x00,
    0x72, 0xB7, 0x75, 0x67, 0x75, 0x8F, 0x75, 0x67,    0x75, 0x11, 0x75, 0x67, 0x75, 0x16, 0x75, 0x67,
    0x75, 0x88, 0xFF, 0xDE, 0x75, 0xBF, 0xFF, 0x73,    0x73, 0x7D, 0xFF, 0x7A, 0x9E, 0xFF, 0x72, 0xA7,
    0x29, 0x19, 0xDE, 0xFF, 0x75, 0x4E, 0x73, 0xFF,    0xC2, 0x3B, 0x7A, 0xFF, 0x09, 0x73, 0xA7, 0x72,
    0x63, 0xFF, 0x68, 0x76, 0xFF, 0x92, 0x75, 0x75,    0xFF, 0xAE, 0x75, 0x75, 0xFF, 0x67, 0x75, 0x75,
    0xAF, 0x63, 0x75, 0x3B, 0xAE, 0xFF, 0x75, 0x15,    0xA4, 0xFF, 0x75, 0x68, 0x4F, 0xFF, 0x75, 0x72,
    0x75, 0x3A, 0x97, 0xC0, 0x75, 0x03, 0xFF, 0x74,    0x75, 0x95, 0x7D, 0x30, 0x75, 0xCC, 0xC4, 0x4C,
    0x68, 0x76, 0x8B, 0xFF, 0x2E, 0x72, 0x3F, 0xFF,    0x16, 0x73, 0x04, 0xFF, 0x92, 0xA3, 0x00, 0x09,
    0x75, 0x75, 0x75, 0x93, 0x75, 0x75, 0x75, 0xAE,    0x75, 0x76, 0x68, 0xFF, 0x72, 0x03, 0x2D, 0xFF,
    0x01, 0x74, 0x16, 0x68, 0x5B, 0x5C, 0xD0, 0x8B,    0x76, 0x00, 0x99, 0x3B, 0x75, 0x76, 0xFF, 0x06,
    0x9C, 0x2B, 0x42, 0xFF, 0xAE, 0x2A, 0xD2, 0xFF,    0x13, 0x43, 0x86, 0xFF, 0x1E, 0x4B, 0xFF, 0xFF,
    0x5B, 0x97, 0xFF, 0xA1, 0x75, 0x60, 0xFF, 0xDE,    0x6B, 0x32, 0xFF, 0x76, 0x11, 0x4C, 0xFF, 0xFF,
    0x9B, 0x43, 0x11, 0x03, 0xD1, 0x2A, 0x8E, 0xBD,    0x13, 0x2B, 0x9D, 0x2B, 0x0F, 0x29, 0x57, 0x5C,
    0x72, 0x73, 0xC5, 0x2D, 0x75, 0xCA, 0x5C, 0x83,    0x72, 0xA2, 0x21, 0x96, 0x10, 0xAF, 0x11, 0xFF,
    0x68, 0x5B, 0x75, 0xAA, 0x75, 0x72, 0x00, 0xC9,    0x75, 0x76, 0x66, 0x62, 0x75, 0x09, 0x4F, 0xFF,
    0x75, 0x3D, 0x34, 0x30, 0x75, 0x4D, 0x0F, 0x3A,    0x75, 0x19, 0xC1, 0x53, 0x75, 0x03, 0x63, 0x6E,
    0x0E, 0x2B, 0x75, 0x2A, 0x8F, 0x2A, 0x75, 0x4F,    0x11, 0x2A, 0x75, 0x4D, 0x11, 0x2A, 0x75, 0x4B,
    0x72, 0xB6, 0x75, 0x2A, 0x75, 0x8F, 0x75, 0x2A,    0x75, 0x10, 0x75, 0x2A, 0x75, 0x3E, 0x76, 0x2A,
    0x72, 0xB9, 0xFF, 0xDE, 0x68, 0x9B, 0xFF, 0x73,    0x52, 0xFF, 0xFF, 0x7A, 0x3C, 0xFF, 0x72, 0xA7,
    0x73, 0x3D, 0xDE, 0xFF, 0x91, 0x37, 0x73, 0xFF,    0xCD, 0x6C, 0x7A, 0xFF, 0xFE, 0x86, 0xA7, 0x72,
    0x63, 0xFF, 0x12, 0x6D, 0xFF, 0x6C, 0x5C, 0x6B,    0xFF, 0xC0, 0x75, 0x72, 0xFF, 0xB3, 0x75, 0x00,
    0x6C, 0x63, 0x75, 0x72, 0xD9, 0xFF, 0x75, 0x3B,    0xA3, 0xFF, 0x75, 0x4E, 0x4E, 0xFF, 0x75, 0x08,
    0x75, 0x06, 0x01, 0xD1, 0x75, 0x7F, 0xFF, 0xA5,    0x75, 0xBE, 0xFE, 0x7D, 0x67, 0x01, 0x38, 0x36,
    0x07, 0x75, 0xD3, 0xFF, 0x3F, 0x19, 0x08, 0xFF,    0x77, 0x2A, 0x3F, 0xFF, 0xC4, 0x3A, 0x72, 0xFF,
    0x00, 0x72, 0x75, 0xBE, 0x75, 0x72, 0x01, 0x01,    0x75, 0x03, 0xA3, 0xFF, 0x75, 0x04, 0x29, 0xFE,
    0x75, 0x3A, 0x7B, 0x1B, 0x75, 0x32, 0xC5, 0x3A,    0x75, 0x8B, 0x73, 0x09, 0x75, 0x76, 0xFF, 0x9B,
    0x37, 0xC0, 0xFF, 0xBA, 0x37, 0xBB, 0xFF, 0xA5,    0x1E, 0xBD, 0xFF, 0x61, 0x0D, 0xBD, 0xFF, 0xFF,
    0x92, 0xBD, 0x76, 0xFF, 0xB2, 0xBD, 0x5A, 0xFF,    0x05, 0xBD, 0x7D, 0xFF, 0x36, 0xBD, 0xFF, 0xFF,
    0x1E, 0xFD, 0xFF, 0xBD, 0x37, 0xC8, 0x2B, 0xBB,    0x37, 0xBA, 0xBA, 0x1F, 0x36, 0xBD, 0x89, 0x63,
    0x7C, 0xBD, 0x7B, 0xFF, 0x5A, 0xBD, 0x5F, 0xFF,    0x06, 0xBD, 0x54, 0xFF, 0x0E, 0xBD, 0xFF, 0x8B,
    0x3F, 0xD9, 0xC3, 0xBF, 0x3F, 0xBD, 0x79, 0xBF,    0x21, 0x5A, 0xFF, 0x85, 0x3E, 0xD4, 0xFF, 0xFD,
    0x7D, 0xD4, 0x2B, 0xFF, 0x34, 0xD4, 0x75, 0xFF,    0x3E, 0xD4, 0x76, 0xFF, 0x21, 0xC8, 0xA7, 0xFF,
    0x37, 0xA0, 0x37, 0xBD, 0x37, 0xB9, 0x22, 0xBD,    0x37, 0xBD, 0x27, 0xBD, 0x37, 0xBD, 0x04, 0xBD,
    0xB6, 0xBD, 0x37, 0xBD, 0x90, 0xBD, 0x37, 0xBD,    0x81, 0xBD, 0x37, 0xBB, 0x4A, 0xBD, 0x37, 0xBF,
    0xB4, 0xAC, 0xCB, 0xFF, 0xFF, 0x9F, 0x7D, 0xFF,    0xFF, 0xFD, 0x78, 0xFF, 0xFF, 0xFF, 0xA7, 0x71,
    0x71, 0xFF, 0xFF, 0xBC, 0x19, 0xFF, 0xFF, 0xBD,    0xAE, 0xFF, 0xFF, 0xBB, 0xBB, 0xFF, 0x72, 0xC1,
    0xFF, 0x6F, 0x3E, 0xA4, 0xFF, 0xFF, 0x21, 0xD9,    0x7E, 0xFF, 0x3F, 0xBD, 0xBA, 0xFF, 0x3F, 0xC5,
    0x63, 0xFF, 0x58, 0x92, 0xFF, 0xFF, 0x7D, 0xD4,    0xFF, 0xFF, 0x35, 0xD4, 0xFF, 0xFF, 0x3E, 0xD4,
    0xB6, 0xD2, 0x69, 0xFF, 0xBC, 0xC6, 0xC5, 0xFF,    0x86, 0xBD, 0xA6, 0xFF, 0xFF, 0xC2, 0x80, 0xFF,
    0x3E, 0x9E, 0xFF, 0xFF, 0x3E, 0xFF, 0xFF, 0xFF,    0x30, 0xFF, 0xFF, 0x61, 0x71, 0xFF, 0xFF, 0x9A,
    0x3F, 0xBD, 0xAF, 0xBF, 0x3F, 0xBF, 0xFF, 0xBF,    0x21, 0xA7, 0xFF, 0xB3, 0x3E, 0xD4, 0xFE, 0xFF,
    0x8D, 0xD4, 0x4F, 0xFF, 0x4F, 0xD4, 0x01, 0xFF,    0x3E, 0xD4, 0xA1, 0xFF, 0x21, 0xA9, 0xBF, 0xFE,
    0x9D, 0x73, 0xFF, 0x5C, 0x9D, 0x73, 0xFF, 0x6C,    0x9D, 0x68, 0xFF, 0xFF, 0x9F, 0x68, 0xFF, 0xFF,
    0xCB, 0x68, 0x59, 0xFF, 0xB1, 0x73, 0xC5, 0xFF,    0x11, 0x73, 0x63, 0xFF, 0x9E, 0x73, 0xFF, 0xFF,
    0x9D, 0xFF, 0xFF, 0x68, 0x9D, 0x7C, 0xFF, 0x73,    0x9D, 0x5C, 0xB2, 0x70, 0x9E, 0x73, 0xB8, 0x61,
    0x6F, 0x68, 0x11, 0xFF, 0xC6, 0x68, 0x87, 0xFF,    0x2C, 0x68, 0xC8, 0xFF, 0x9F, 0x68, 0x62, 0xFF,
    0xA4, 0x62, 0x7C, 0x59, 0x09, 0x9B, 0xFF, 0x63,    0x00, 0xD4, 0xFF, 0xFF, 0x71, 0xD4, 0xFF, 0xFF,
    0xD1, 0xD4, 0x76, 0xFF, 0x77, 0xD4, 0x85, 0xFF,    0x71, 0xD4, 0xC0, 0xFF, 0x03, 0xD4, 0xA5, 0xFF,
    0x9D, 0x69, 0x9D, 0x68, 0x9D, 0x68, 0x9D, 0x73,    0x9D, 0x68, 0xB5, 0x73, 0x9D, 0x68, 0x84, 0x73,
    0xB7, 0x68, 0x9D, 0x68, 0xDE, 0x68, 0x9D, 0x73,    0xA1, 0x68, 0x9D, 0x6E, 0x9E, 0x68, 0x9D, 0xFC,
    0xFF, 0xFF, 0xA7, 0xFF, 0xFF, 0xFF, 0xA3, 0xFF,    0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x5A, 0x64,
    0xCB, 0xFF, 0xFF, 0x06, 0xBD, 0xFF, 0xFF, 0x04,    0xA5, 0xFF, 0xFF, 0x04, 0x78, 0xFF, 0x5B, 0x03,
    0xFF, 0xFD, 0x5B, 0xFF, 0xFF, 0xFF, 0x8B, 0x62,    0xFF, 0xFF, 0x18, 0x13, 0x86, 0xFF, 0x7B, 0xD4,
    0x63, 0xFF, 0xD6, 0xD4, 0xFF, 0xFF, 0x92, 0xD4,    0xFF, 0xFF, 0x09, 0xD4, 0xFF, 0xFF, 0x71, 0xD4,
    0xB8, 0xD4, 0xFF, 0xFF, 0x99, 0xD4, 0x65, 0xFF,    0xFF, 0x9D, 0xA5, 0xFF, 0xFF, 0x64, 0x1F, 0xFF,
    0x72, 0xFF, 0xFF, 0xFF, 0x71, 0xFF, 0xFF, 0xFF,    0x04, 0xFF, 0xFF, 0xFF, 0x95, 0xFF, 0xFF, 0xFF,
    0x09, 0x79, 0xFF, 0xD4, 0xA3, 0xD4, 0xFF, 0x65,    0x06, 0xD4, 0xFF, 0xFF, 0x70, 0xD4, 0xFE, 0xFF,
    0x87, 0xD4, 0x5B, 0xFF, 0x72, 0xD4, 0x83, 0xFF,    0x70, 0xD4, 0xBB, 0xFF, 0x03, 0xD4, 0x95, 0xFE,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xF9, 0xD8, 0xFF, 0xFF, 0xF3, 0xFF,    0xFF, 0xFF, 0xF3, 0xFF, 0xFF, 0xFF, 0xF3, 0xFF,
    0xFF, 0xFF, 0xF3, 0xE4, 0xFF, 0xFF, 0xFF, 0xD4,    0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4,
    0xFF, 0xFF, 0xFC, 0xD4, 0xFF, 0xF5, 0x0E, 0xD4,    0xFF, 0xDB, 0xED, 0xD4, 0xFF, 0xD4, 0xED, 0xD4,
    0xFF, 0xFF, 0xED, 0xD4, 0xFF, 0xFF, 0x0E, 0xD4,    0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4,
    0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0x80, 0xD4,    0xFF, 0xFF, 0xA3, 0xC8, 0xFF, 0xFF, 0xA3, 0xFF,
    0xFF, 0x25, 0xF2, 0x2C, 0xFF, 0xFF, 0xF2, 0xD4,    0xFF, 0xFF, 0x6E, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4,
    0xFF, 0x17, 0x15, 0xD4, 0xFF, 0xD4, 0x14, 0xD4,    0xFF, 0xD4, 0x14, 0xD4, 0xFF, 0xD4, 0x14, 0xD9,
    0xFF, 0xFF, 0x13, 0xD4, 0x16, 0xFF, 0xF6, 0xD4,    0x16, 0xFF, 0xFF, 0xD4, 0x15, 0xFF, 0xFF, 0xD4,
    0xFF, 0xD4, 0xFA, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4,    0xFF, 0xD4, 0xFF, 0xD4, 0xFA, 0xD4, 0xF6, 0xD4,
    0x12, 0xFF, 0x14, 0xF6, 0x12, 0xFF, 0x14, 0xFF,    0x12, 0xFF, 0x15, 0xFF, 0x13, 0x32, 0x15, 0xCF,
    0xF4, 0xD7, 0x6F, 0x80, 0xFF, 0xD4, 0xFF, 0xBC,    0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4,
    0x8D, 0xD4, 0xFF, 0x6F, 0x07, 0xFF, 0xFF, 0xFF,    0x08, 0xFF, 0xFF, 0xFF, 0x08, 0xFF, 0xFC, 0xFF,
    0x0D, 0xD4, 0xFF, 0xFF, 0xEC, 0xD4, 0xFF, 0xFF,    0xEC, 0xBC, 0xFF, 0xFF, 0xEC, 0xFF, 0xFF, 0xFF,
    0xEC, 0xD4, 0xFF, 0xFF, 0x19, 0xD4, 0xFF, 0xFF,    0xF9, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xED, 0xDD, 0xFF, 0xFF, 0xD4, 0xFF,    0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF,
    0xFF, 0xFF, 0xD4, 0xDD, 0xFF, 0xFF, 0xFF, 0xD4,    0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4,
    0xFF, 0xFC, 0xBC, 0xD4, 0xFF, 0xD8, 0xD4, 0xD4,    0xFF, 0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4,
    0xFF, 0xFF, 0xD4, 0xD4, 0xFF, 0xFF, 0xD4, 0xD4,    0xFC, 0xFF, 0xBC, 0xD4, 0xED, 0xFF, 0x0E, 0xD4,
    0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xD7, 0xD4,    0xFF, 0xFF, 0xD4, 0xC8, 0xFF, 0xFF, 0xD4, 0xFF,
    0xFF, 0xBC, 0xD4, 0xD7, 0xFF, 0xFC, 0xD4, 0xD4,    0xFF, 0xFF, 0xEB, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4,
    0xFF, 0xD3, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4,    0xFF, 0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4,
    0x17, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4,    0xD4, 0xFF, 0x5A, 0xD4, 0xD4, 0xFF, 0xFA, 0xD4,
    0xFF, 0xD4, 0x13, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4,    0xFF, 0xD4, 0xFF, 0xD4, 0x12, 0xD4, 0x98, 0xD4,
    0xD4, 0x1C, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,    0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0x39, 0xD4, 0xA6,
    0xA6, 0xD4, 0xF2, 0xBC, 0xFF, 0xD4, 0xFF, 0xD4,    0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xBB, 0xFF, 0xD4,
    0xDC, 0xD4, 0xFF, 0xFF, 0xD4, 0x17, 0xFC, 0xFF,    0xD4, 0xFF, 0xD0, 0xFF, 0xD4, 0xFF, 0xD4, 0xF8,
    0xD4, 0xD4, 0xFF, 0xFF, 0xD4, 0xD4, 0xFF, 0xFF,    0xD4, 0xDD, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF,
    0xD4, 0xD4, 0xFF, 0xFF, 0xD4, 0xD4, 0xFF, 0xFF,    0xD4, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xED, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4,    0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4,
    0xFF, 0xFF, 0xBC, 0xF3, 0xFF, 0xFF, 0xD4, 0xFF,    0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xF3, 0xD4, 0xFF,
    0xE1, 0xFF, 0xD4, 0xFC, 0xD4, 0xFF, 0xD4, 0xFF,    0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xE4, 0xD4, 0xFF,
    0xFF, 0xD4, 0xD4, 0xFF, 0xFF, 0xD4, 0xBC, 0xDB,    0xFF, 0xD4, 0xE9, 0xD4, 0xFF, 0xBC, 0xE4, 0xD4,
    0xFF, 0xD4, 0xD4, 0xD4, 0xFF, 0xDD, 0xD4, 0xD4,    0xFF, 0xFF, 0xD4, 0xC9, 0xEC, 0xFF, 0xFF, 0xC9,
    0xD4, 0xFF, 0xD4, 0xD4, 0xB4, 0xFF, 0xD4, 0xD4,    0xFF, 0xEC, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xF2,
    0xE6, 0xFF, 0xD4, 0xF1, 0xD4, 0xFF, 0xD4, 0xFF,    0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,
    0xFF, 0xD7, 0xD9, 0xCF, 0xFF, 0xD4, 0xEA, 0xD4,    0xFF, 0xD4, 0x93, 0xD4, 0xFF, 0xD4, 0xD7, 0xD4,
    0xD4, 0xA6, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,    0xD4, 0xFF, 0xD4, 0x15, 0xD9, 0xD4, 0xD4, 0xD4,
    0xE5, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4,    0xFF, 0xD4, 0xFF, 0xD4, 0xE2, 0x98, 0xBB, 0xD4,
    0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF,    0xD4, 0xFF, 0xD4, 0xDA, 0xC8, 0xD3, 0xD4, 0xD4,
    0xD4, 0xD4, 0xFF, 0xD4, 0xEA, 0xD4, 0xFF, 0xD4,    0xFF, 0xD4, 0xFF, 0xD8, 0x07, 0xB0, 0xC9, 0xFC,
    0xE8, 0xFF, 0xFF, 0xFF, 0xBC, 0xFF, 0xFF, 0xFF,    0xE1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xD8, 0xFF, 0xFF, 0xFF, 0x86, 0xFF, 0xFF, 0xFF,    0x19, 0xFF, 0xFF, 0xFF, 0x25, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0x2D, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4,    0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4,
    0xFF, 0xFF, 0xD4, 0xFC, 0xFF, 0xFF, 0xD4, 0xFF,    0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0x2D, 0xD4, 0xFF,
    0xD4, 0xFF, 0x2D, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,    0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xBC, 0xD4, 0xFF,
    0xFF, 0xD4, 0xDB, 0xFF, 0xFF, 0xD4, 0xFC, 0xE4,    0xFF, 0xD4, 0xFF, 0xD4, 0xF5, 0xE9, 0xFF, 0xD4,
    0xFF, 0xD4, 0xD4, 0xD4, 0xFF, 0xDD, 0xD4, 0xD4,    0xFC, 0xFF, 0xD4, 0x2C, 0xBC, 0xFF, 0xFF, 0xE0,
    0xD4, 0xFF, 0xD4, 0xD4, 0xE4, 0xFC, 0xD4, 0xD4,    0xFF, 0xBC, 0xD4, 0xD4, 0xFF, 0xD4, 0xBC, 0x2B,
    0xDC, 0xFF, 0xBB, 0x17, 0xD4, 0xFF, 0xD4, 0xFF,    0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,
    0xFF, 0xD4, 0xEA, 0xEA, 0xFF, 0xD4, 0xFF, 0xD4,    0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFB, 0xD4,
    0xD4, 0xA6, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,    0xD4, 0xFB, 0xD4, 0xB3, 0xA6, 0xD4, 0xD4, 0xD4,
    0x5A, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4,    0xFF, 0xD4, 0xFB, 0xD4, 0x5A, 0xEE, 0xD4, 0xD4,
    0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xF8,    0xD4, 0x07, 0xD4, 0xD4, 0xE7, 0xDF, 0xE0, 0xD4,
    0xD4, 0xD4, 0xFF, 0xD4, 0xDC, 0xD4, 0xFF, 0xD4,    0xFF, 0xD4, 0x2C, 0x2C, 0x1E, 0xF2, 0xD4, 0xFF,
    0xFF, 0xF9, 0xFF, 0xFF, 0xFC, 0xEC, 0xFF, 0xFF,    0xF9, 0xEC, 0xFF, 0xFF, 0xFF, 0xEC, 0xFF, 0xFF,
    0xFC, 0xEC, 0xFF, 0xFF, 0xFF, 0xED, 0xFF, 0xFF,    0xFF, 0x19, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF,    0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xDB, 0xBC, 0xFF,
    0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4,    0xFF, 0xFF, 0xFF, 0xD4, 0xED, 0xFF, 0xFF, 0xE9,
    0xFF, 0xD4, 0xFF, 0xF9, 0xFF, 0xD4, 0xFF, 0xD4,    0xF9, 0xD4, 0xFF, 0xD4, 0xD4, 0xFF, 0xFF, 0xD4,
    0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xE1, 0xFF,    0xD4, 0xF3, 0xD4, 0xFF, 0xF5, 0xD4, 0xD4, 0xFF,
    0xD4, 0xE8, 0xD4, 0xD4, 0xE4, 0xD4, 0xD8, 0xD4,    0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0x99, 0xC9,
    0xFF, 0xD4, 0xD4, 0xD4, 0xEC, 0x19, 0xD4, 0xD4,    0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF, 0xEB, 0xD4,
    0xFF, 0xD4, 0xFB, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4,    0xFF, 0xD4, 0xFF, 0xD4, 0x76, 0xDC, 0xFF, 0xD4,
    0xD4, 0xFF, 0x38, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,    0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xEB, 0xD4, 0x7D,
    0xCF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4,    0x15, 0xD4, 0xEA, 0xFF, 0xD4, 0xFF, 0xD4, 0xD4,
    0xD4, 0x16, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,    0xD4, 0xE6, 0xD7, 0xD7, 0x16, 0xD4, 0xD4, 0xD4,
    0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0x2C, 0xC9,    0xEB, 0xC8, 0xD4, 0xFF, 0xDA, 0xFF, 0xD4, 0xFF,
    0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0x99,    0xD4, 0xBB, 0xFF, 0xD4, 0xF8, 0xD4, 0xFF, 0xD4,
    0x19, 0xD4, 0xFF, 0xFF, 0xD4, 0xD4, 0xFF, 0xFF,    0xD4, 0xFC, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF,
    0xD4, 0xD0, 0xFF, 0xFF, 0xD4, 0xD4, 0xFF, 0xFF,    0x2D, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF,    0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xD4, 0xDD, 0xFF,
    0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4,    0xFF, 0xFF, 0xFF, 0xD4, 0xE1, 0xFF, 0xFF, 0xED,
    0xFF, 0xD4, 0xFF, 0xE1, 0xFF, 0xD4, 0xFF, 0xD4,    0xF3, 0xD4, 0xFF, 0xD4, 0xD4, 0xF5, 0xFF, 0xD4,
    0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xDB, 0xFF,    0xD4, 0xF3, 0xD4, 0xFF, 0xFF, 0xD4, 0xD4, 0xFF,
    0xD4, 0xD4, 0xD4, 0xD4, 0xED, 0xD4, 0xD4, 0xD4,    0xFF, 0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4,
    0xFC, 0xBC, 0xD4, 0xD4, 0xBC, 0xFF, 0xD4, 0xD4,    0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xF9, 0xCC, 0xD4,
    0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4,    0xFF, 0xD4, 0xFF, 0xD4, 0x08, 0xDF, 0xFF, 0xBB,
    0xD4, 0xFF, 0xD9, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,    0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xE3, 0xD4, 0x54,
    0xEA, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD7,    0xEF, 0xD9, 0xDC, 0xFF, 0xD4, 0xFF, 0xD4, 0xC8,
    0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,    0xD4, 0xDC, 0xD3, 0xD4, 0x7D, 0xD4, 0xD4, 0xD4,
    0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0x99, 0xC9,    0xC8, 0xD0, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,
    0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xC9, 0x99,    0xD4, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4,
    0xEC, 0xD4, 0xFF, 0xFF, 0xD4, 0xD4, 0xFF, 0xFF,    0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF,
    0xD4, 0x0A, 0xFF, 0xFF, 0xD4, 0x86, 0xFF, 0xFF,    0x19, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4,    0xF5, 0xFF, 0xFF, 0xD4, 0xD4, 0xFF, 0xFF, 0xD4,
    0xFF, 0xFF, 0xD4, 0xD4, 0xFF, 0xFF, 0xD4, 0xD4,    0xFF, 0xED, 0xD4, 0xD4, 0xFF, 0xD4, 0xF3, 0xD4,
    0xD4, 0x0E, 0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4,    0xD4, 0xFF, 0xD4, 0xD4, 0xE1, 0xE4, 0xD4, 0xD4,
    0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4,    0xF3, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0x86, 0x2D,
    0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,    0xD4, 0xE4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF,
    0xE4, 0xD4, 0xC9, 0xD4, 0xFF, 0xD4, 0xC9, 0xD4,    0xFF, 0xD4, 0xC9, 0xD4, 0xE4, 0xF9, 0xDA, 0xD4,
    0xD4, 0x2C, 0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4,    0xD4, 0x6F, 0xD4, 0xD4, 0xEB, 0xD4, 0xE6, 0xD4,
    0x6F, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4,    0xFF, 0xD4, 0x2A, 0xAF, 0xC8, 0xD4, 0xD4, 0xFF,
    0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0x07, 0xC8, 0xEB,    0xDC, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xE7, 0xD4,
    0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0x07, 0xB0,    0xBB, 0xAF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0x6F,
    0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xBC, 0xFC,    0x99, 0xD4, 0xFC, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4,
    0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0x99, 0xD4,    0xD4, 0x0A, 0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4,
    0xD4, 0xD4, 0xF3, 0xFF, 0xDD, 0xD4, 0xF3, 0xFF,    0xFF, 0xD4, 0xF3, 0xFF, 0xFF, 0xD4, 0xF9, 0xE9,
    0xFF, 0xD4, 0xFF, 0xD4, 0xEC, 0xED, 0xFF, 0xD4,    0xD4, 0xFF, 0xFF, 0xD4, 0xD4, 0xFF, 0xFC, 0xF3,
    0xF3, 0xFF, 0xF3, 0xFC, 0xF3, 0xFF, 0xFF, 0xD4,    0xFC, 0xDB, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4,
    0xFF, 0xD4, 0xFF, 0xDD, 0xFF, 0xD4, 0xF5, 0xFF,    0xF9, 0xFF, 0xF3, 0xFF, 0xF3, 0xFF, 0xF3, 0xFF,
    0xFF, 0xFF, 0xED, 0xD4, 0xFF, 0xFF, 0xED, 0xD4,    0x2D, 0xFF, 0xED, 0xD4, 0xD4, 0xFF, 0xED, 0xD4,
    0xFF, 0xFF, 0xD4, 0xD4, 0xFF, 0xFF, 0xD4, 0xD4,    0xFF, 0xDD, 0xD4, 0xD4, 0xFF, 0xD4, 0xE4, 0xD4,
    0xD4, 0xF9, 0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4,    0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xFC, 0xBC, 0xD4,
    0xF3, 0xBC, 0xD8, 0xD4, 0xFF, 0xD4, 0xED, 0xD4,    0xFC, 0xD4, 0xDB, 0x2D, 0xD4, 0xD4, 0xD4, 0xFF,
    0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xF5, 0xD4, 0xFF,    0xD4, 0xD4, 0xD4, 0xFF, 0xD0, 0xD4, 0xD4, 0xFF,
    0xF9, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4,    0xF9, 0xDD, 0xFF, 0xD4, 0xD4, 0xFF, 0x0A, 0xD4,
    0xD4, 0x99, 0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4,    0xD4, 0xA3, 0xBB, 0xD4, 0xC8, 0xD4, 0xF7, 0xD4,
    0xA3, 0xD4, 0xEB, 0xD4, 0xFF, 0xD4, 0xDA, 0xE3,    0xFF, 0xD4, 0xD4, 0xFF, 0xBC, 0xD4, 0xD4, 0xFF,
    0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xEB, 0xE7, 0xC8,    0xD3, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0x0C, 0xD4,
    0xFF, 0xD4, 0xFF, 0xD4, 0xF7, 0xD4, 0x2A, 0xF2,    0xD4, 0x08, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,
    0xD4, 0xDA, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF,    0xA3, 0xD4, 0xDB, 0xEC, 0xFF, 0xD4, 0xB4, 0xD4,
    0xD4, 0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0x2C, 0xD4,    0xD4, 0xFF, 0xD4, 0xD4, 0xD4, 0xFF, 0xD4, 0xD4,
    0xD4, 0xD4, 0xD4, 0xFF, 0xE1, 0xD4, 0xD4, 0xFF,    0xFF, 0xD4, 0xD4, 0xFF, 0xFF, 0xD4, 0x2D, 0xDD,
    0x19, 0xD4, 0xFF, 0xD4, 0xDD, 0x2D, 0xFF, 0xD4,    0xD4, 0xFF, 0xFF, 0xD4, 0xD4, 0xFF, 0xED, 0xFF,
    0xD4, 0xFF, 0xD8, 0xF3, 0xD4, 0xFF, 0xFF, 0xD4,    0xF9, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4,
    0xFF, 0xD4, 0xFF, 0xED, 0xFF, 0xDD, 0xD4, 0xFF,    0xDD, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,
    0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF,    0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF,
    0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF,    0xBC, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xBC, 0xFF,
    0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF,    0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF,
    0xF9, 0xFF, 0xDB, 0xFF, 0xDD, 0xFF, 0xF3, 0xFF,    0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xDD, 0xFF, 0xFF, 0xFF,    0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF,
    0xD4, 0xFF, 0xC9, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,    0x19, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF,
    0xE0, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF,    0xF0, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD7, 0xFF,
    0xD4, 0xFF, 0x0C, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF,    0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xBB, 0xFF,    0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,
    0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xF8, 0xFF,    0x76, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x95, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF,    0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xEC, 0xFF,
    0xD4, 0xFF, 0xBC, 0xFF, 0xD7, 0xFF, 0xD4, 0xFF,    0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF,
    0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xFF, 0xFF,    0xD4, 0xFF, 0xFF, 0xFF, 0xD4, 0xFF, 0xBC, 0xFF,
    0xBC, 0xFF, 0xD4, 0xFF, 0xF5, 0xFF, 0xD4, 0xFF,    0xFF, 0xFF, 0xD8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0x86, 0xFF, 0xF5, 0xFF, 0xD4, 0xFF,    0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF, 0xD4, 0xFF,
    0xD4, 0xFF, 0x2D, 0xFF, 0xE4, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xF3, 0xFF, 0xFF, 0xFF, 0xF3, 0xFF,    0xFF, 0xFF, 0xF3, 0xFF, 0xFF, 0xFF, 0xF3, 0xFF,
    0xFF, 0xFF, 0xF3, 0xFF, 0xFF, 0xFF, 0xF3, 0xFF,    0xF3, 0xFF, 0xF3, 0xFF, 0xF3, 0xFF, 0xF5, 0xFF,
    0xFF, 0xFF, 0xED, 0xFF, 0xFF, 0xFF, 0xED, 0xFF,    0xFF, 0xFF, 0x86, 0xFF, 0xFF, 0xFF, 0xF5, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xF5, 0xFF, 0xFF, 0xFF, 0x86, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0xFF, 0xFF, 0xFF,    0xF3, 0xFF, 0xFF, 0xFF, 0xF3, 0xFF, 0xFF, 0xFF,
    0x19, 0xFF, 0x0A, 0xFF, 0x19, 0xFF, 0x19, 0xFF,    0xFF, 0xFF, 0x19, 0xFF, 0xFF, 0xFF, 0x19, 0xFF,
    0x0A, 0xFF, 0xA3, 0xFF, 0xFF, 0xFF, 0xF2, 0xFF,    0x6C, 0xFF, 0x6F, 0xFF, 0xA3, 0xFF, 0xFF, 0xFF,
    0xA3, 0xFF, 0xFF, 0xFF, 0xA3, 0xFF, 0xFF, 0xFF,    0xA3, 0xFF, 0xFF, 0xFF, 0xA3, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xF2, 0xFF,    0xF2, 0xFF, 0xF2, 0xFF, 0xF2, 0xFF, 0xF2, 0xFF,
    0xF2, 0xFF, 0xF2, 0xFF, 0xF2, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF8, 0xFF, 0xFF, 0xFF, 0xA3, 0xFF, 0xFF, 0xFF,    0xA3, 0xFF, 0xFF, 0xFF, 0xA3, 0xFF, 0xFF, 0xFF,
    0x19, 0xFF, 0xFF, 0xFF, 0x0A, 0xFF, 0x19, 0xFF,    0xFF, 0xFF, 0xEC, 0xFF, 0xFF, 0xFF, 0xEC, 0xFF,
    0xED, 0xFF, 0xFF, 0xFF, 0xED, 0xFF, 0xFF, 0xFF,    0x19, 0xFF, 0xFF, 0xFF, 0xF5, 0xFF, 0xF3, 0xFF,
    0xFF, 0xFF, 0xF3, 0xFF, 0xFF, 0xFF, 0xF3, 0xFF,    0xFF, 0xFF, 0xF5, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xF9, 0xFF, 0xFC, 0xFF, 0xF3, 0xFF,    0xF3, 0xFF, 0xF3, 0xFF, 0xF3, 0xFF, 0xF3, 0xFF,
    0xF3, 0xFF, 0xFC, 0xFF, 0xF9, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x34, 0x31, 0x32, 0x7F, 0x31, 0x2F, 0x30, 0x7F,    0x37, 0x35, 0x36, 0x7F, 0x35, 0x33, 0x34, 0x7F,
    0x3D, 0x3B, 0x3C, 0x7F, 0x3B, 0x39, 0x3A, 0x7F,    0x39, 0x37, 0x38, 0x7F, 0x47, 0x45, 0x46, 0x7F,
    0x4E, 0x4D, 0x4E, 0x7F, 0x4D, 0x4C, 0x4D, 0x7F,    0x4C, 0x4B, 0x4C, 0x7F, 0x4B, 0x4A, 0x4B, 0x7F,
    0x4A, 0x49, 0x4A, 0x7F, 0x49, 0x48, 0x49, 0x7F,    0x48, 0x47, 0x48, 0x7F, 0x47, 0x46, 0x47, 0x7F,
    0x46, 0x44, 0x45, 0x7F, 0x41, 0x3F, 0x40, 0x7F,    0x32, 0x31, 0x32, 0x7F, 0x8A, 0x88, 0x8A, 0x7F,
    0x54, 0x53, 0x54, 0x7F, 0x52, 0x51, 0x52, 0x7F,    0x50, 0x4F, 0x50, 0x7F, 0x4F, 0x4E, 0x4F, 0x7F,
    0x44, 0x43, 0x44, 0x7F, 0x42, 0x41, 0x42, 0x7F,    0x5E, 0x5D, 0x5E, 0x7F, 0x5C, 0x5B, 0x5C, 0x7F,
    0x5A, 0x59, 0x5A, 0x7F, 0x58, 0x57, 0x58, 0x7F,    0x56, 0x55, 0x56, 0x7F, 0xE0, 0xDF, 0xE0, 0x7F,
    0x60, 0x5F, 0x61, 0x7F, 0x72, 0x72, 0x74, 0x7F,    0x54, 0x54, 0x55, 0x7F, 0x53, 0x53, 0x54, 0x7F,
    0x52, 0x52, 0x53, 0x7F, 0x51, 0x51, 0x52, 0x7F,    0x4F, 0x4F, 0x50, 0x7F, 0x4D, 0x4D, 0x4E, 0x7F,
    0x5D, 0x5D, 0x5E, 0x7F, 0x5C, 0x5C, 0x5D, 0x7F,    0x5B, 0x5B, 0x5C, 0x7F, 0x5A, 0x5A, 0x5B, 0x7F,
    0x59, 0x59, 0x5A, 0x7F, 0x58, 0x58, 0x59, 0x7F,    0x57, 0x57, 0x58, 0x7F, 0x55, 0x55, 0x56, 0x7F,
    0x4B, 0x4B, 0x4C, 0x7F, 0x6D, 0x6D, 0x6E, 0x7F,    0x65, 0x65, 0x66, 0x7F, 0x64, 0x64, 0x65, 0x7F,
    0x62, 0x62, 0x63, 0x7F, 0x60, 0x60, 0x61, 0x7F,    0x5F, 0x5F, 0x60, 0x7F, 0x5E, 0x5E, 0x5F, 0x7F,
    0xB3, 0xB3, 0xB4, 0x7F, 0x88, 0x88, 0x89, 0x7F,    0x7B, 0x7C, 0x7E, 0x7F, 0x79, 0x7A, 0x7C, 0x7F,
    0x78, 0x79, 0x7B, 0x7F, 0x77, 0x78, 0x7A, 0x7F,    0x73, 0x74, 0x76, 0x7F, 0x6F, 0x70, 0x72, 0x7F,
    0x7D, 0x7F, 0x81, 0x7F, 0x53, 0x54, 0x55, 0x7F,    0x51, 0x52, 0x53, 0x7F, 0x62, 0x63, 0x64, 0x7F,
    0x61, 0x62, 0x63, 0x7F, 0x60, 0x61, 0x62, 0x7F,    0x5F, 0x60, 0x61, 0x7F, 0x5D, 0x5E, 0x5F, 0x7F,
    0x6A, 0x6C, 0x6D, 0x7F, 0x7F, 0x81, 0x82, 0x7F,    0x4F, 0x50, 0x50, 0x7F, 0x59, 0x5A, 0x5A, 0x7F,
    0xA4, 0xA4, 0xA3, 0x7F, 0x33, 0x32, 0x31, 0x7F,    0x37, 0x36, 0x35, 0x7F, 0x55, 0x54, 0x53, 0x7F,
    0x5B, 0x5C, 0x5D, 0x7F, 0x57, 0x58, 0x59, 0x7F,    0x55, 0x56, 0x57, 0x7F, 0x76, 0x77, 0x78, 0x7F,
    0x6E, 0x6F, 0x70, 0x7F, 0x6A, 0x6B, 0x6C, 0x7F,    0x68, 0x69, 0x6A, 0x7F, 0x66, 0x67, 0x68, 0x7F,
    0x64, 0x63, 0x62, 0x7F, 0x60, 0x5F, 0x5E, 0x7F,    0xC5, 0xC4, 0xC3, 0x7F, 0x32, 0x30, 0x2F, 0x7F,
    0x30, 0x2E, 0x2D, 0x7F, 0x35, 0x33, 0x32, 0x7F,    0x34, 0x32, 0x31, 0x7F, 0x5D, 0x5B, 0x5A, 0x7F,
    0x8B, 0x89, 0x88, 0x7F, 0x07, 0x06, 0x06, 0x7F,    0x09, 0x08, 0x08, 0x7F, 0x17, 0x15, 0x15, 0x7F,
    0x0C, 0x0B, 0x0B, 0x7F, 0x1A, 0x18, 0x18, 0x7F,    0x32, 0x2F, 0x2F, 0x7F, 0x31, 0x2E, 0x2E, 0x7F,
    0x2C, 0x2A, 0x2A, 0x7F, 0x2B, 0x29, 0x29, 0x7F,    0x33, 0x31, 0x31, 0x7F, 0x2F, 0x2D, 0x2D, 0x7F,
    0x38, 0x36, 0x36, 0x7F, 0x37, 0x35, 0x35, 0x7F,    0x36, 0x34, 0x34, 0x7F, 0x3C, 0x3A, 0x3A, 0x7F,
    0x30, 0x2D, 0x2D, 0x7F, 0x10, 0x0F, 0x0F, 0x7F,    0x36, 0x33, 0x33, 0x7F, 0x34, 0x31, 0x31, 0x7F,
    0x23, 0x21, 0x21, 0x7F, 0x38, 0x35, 0x35, 0x7F,    0x25, 0x23, 0x23, 0x7F, 0x13, 0x12, 0x12, 0x7F,
    0x3B, 0x39, 0x39, 0x7F, 0x1D, 0x1C, 0x1C, 0x7F,    0x42, 0x40, 0x40, 0x7F, 0x40, 0x3E, 0x3E, 0x7F,
    0x20, 0x1F, 0x1F, 0x7F, 0x27, 0x26, 0x26, 0x7F,    0x5E, 0x5C, 0x5C, 0x7F, 0x57, 0x55, 0x55, 0x7F,
    0x33, 0x32, 0x32, 0x7F, 0x2F, 0x2E, 0x2E, 0x7F,    0x7F, 0x7D, 0x7D, 0x7F, 0x7C, 0x7A, 0x7A, 0x7F,
    0x7A, 0x78, 0x78, 0x7F, 0x78, 0x76, 0x76, 0x7F,    0x72, 0x70, 0x70, 0x7F, 0x70, 0x6E, 0x6E, 0x7F,
    0xA3, 0xA1, 0xA1, 0x7F, 0xA1, 0x9F, 0x9F, 0x7F,    0x9C, 0x9A, 0x9A, 0x7F, 0x97, 0x95, 0x95, 0x7F,
    0x95, 0x93, 0x93, 0x7F, 0x92, 0x90, 0x90, 0x7F,    0x90, 0x8E, 0x8E, 0x7F, 0x8D, 0x8B, 0x8B, 0x7F,
    0x6E, 0x6C, 0x6C, 0x7F, 0x6B, 0x69, 0x69, 0x7F,    0x68, 0x66, 0x66, 0x7F, 0x3E, 0x3D, 0x3D, 0x7F,
    0x3B, 0x3A, 0x3A, 0x7F, 0x37, 0x36, 0x36, 0x7F,    0xA8, 0xA6, 0xA6, 0x7F, 0xA5, 0xA3, 0xA3, 0x7F,
    0x88, 0x86, 0x86, 0x7F, 0x82, 0x80, 0x80, 0x7F,    0x80, 0x7E, 0x7E, 0x7F, 0x54, 0x53, 0x53, 0x7F,
    0x52, 0x51, 0x51, 0x7F, 0x51, 0x50, 0x50, 0x7F,    0x50, 0x4F, 0x4F, 0x7F, 0x4E, 0x4D, 0x4D, 0x7F,
    0x4C, 0x4B, 0x4B, 0x7F, 0x4A, 0x49, 0x49, 0x7F,    0x48, 0x47, 0x47, 0x7F, 0x44, 0x43, 0x43, 0x7F,
    0x43, 0x42, 0x42, 0x7F, 0xC9, 0xC7, 0xC7, 0x7F,    0xC4, 0xC2, 0xC2, 0x7F, 0xC1, 0xBF, 0xBF, 0x7F,
    0x75, 0x74, 0x74, 0x7F, 0x74, 0x73, 0x73, 0x7F,    0x6C, 0x6B, 0x6B, 0x7F, 0x69, 0x68, 0x68, 0x7F,
    0x62, 0x61, 0x61, 0x7F, 0x5A, 0x59, 0x59, 0x7F,    0x58, 0x57, 0x57, 0x7F, 0x57, 0x56, 0x56, 0x7F,
    0xBA, 0xB8, 0xB8, 0x7F, 0xB8, 0xB6, 0xB6, 0x7F,    0xB7, 0xB5, 0xB5, 0x7F, 0xB4, 0xB2, 0xB2, 0x7F,
    0xAF, 0xAD, 0xAD, 0x7F, 0xAC, 0xAA, 0xAA, 0x7F,    0xAB, 0xA9, 0xA9, 0x7F, 0x76, 0x75, 0x75, 0x7F,
    0xF9, 0xF8, 0xF8, 0x7F, 0xF7, 0xF6, 0xF6, 0x7F,    0xF4, 0xF3, 0xF3, 0x7F, 0xF1, 0xF0, 0xF0, 0x7F,
    0xF0, 0xEF, 0xEF, 0x7F, 0xEF, 0xEE, 0xEE, 0x7F,    0xEB, 0xEA, 0xEA, 0x7F, 0xE8, 0xE7, 0xE7, 0x7F,
    0xE4, 0xE3, 0xE3, 0x7F, 0xDD, 0xDC, 0xDC, 0x7F,    0xDB, 0xDA, 0xDA, 0x7F, 0xD8, 0xD7, 0xD7, 0x7F,
    0xD6, 0xD5, 0xD5, 0x7F, 0xD0, 0xCF, 0xCF, 0x7F,    0xCB, 0xCA, 0xCA, 0x7F, 0xC6, 0xC5, 0xC5, 0x7F,
    0xA1, 0xA0, 0xA0, 0x7F, 0x9E, 0x9D, 0x9D, 0x7F,    0x99, 0x98, 0x98, 0x7F, 0x84, 0x83, 0x83, 0x7F,
    0xFF, 0xFF, 0xFF, 0x7F, 0xFE, 0xFE, 0xFE, 0x7F,    0xFC, 0xFC, 0xFC, 0x7F, 0xE0, 0xE0, 0xE0, 0x7F,
    0xC2, 0xC1, 0xC1, 0x7F, 0xC1, 0xC0, 0xC0, 0x7F,    0xBD, 0xBC, 0xBC, 0x7F, 0xB5, 0xB4, 0xB4, 0x7F,
    0xB2, 0xB1, 0xB1, 0x7F, 0xB0, 0xAF, 0xAF, 0x7F,    0xAD, 0xAC, 0xAC, 0x7F, 0xA5, 0xA4, 0xA4, 0x7F,
    0xDF, 0xDF, 0xDF, 0x7F, 0xD3, 0xD3, 0xD3, 0x7F,    0xD0, 0xD0, 0xD0, 0x7F, 0xCF, 0xCF, 0xCF, 0x7F,
    0xC2, 0xC2, 0xC2, 0x7F, 0xBF, 0xBF, 0xBF, 0x7F,    0xB7, 0xB7, 0xB7, 0x7F, 0xB2, 0xB2, 0xB2, 0x7F,
    0xB0, 0xB0, 0xB0, 0x7F, 0xAF, 0xAF, 0xAF, 0x7F,    0xA6, 0xA6, 0xA6, 0x7F, 0xA2, 0xA2, 0xA2, 0x7F,
    0x9F, 0x9F, 0x9F, 0x7F, 0x97, 0x97, 0x97, 0x7F,    0x94, 0x94, 0x94, 0x7F, 0x93, 0x93, 0x93, 0x7F,
    0x72, 0x72, 0x72, 0x7F, 0x67, 0x67, 0x67, 0x7F,    0x44, 0x44, 0x44, 0x7F, 0x40, 0x40, 0x40, 0x7F,
    0x38, 0x38, 0x38, 0x7F, 0x30, 0x30, 0x30, 0x7F,    0x29, 0x29, 0x29, 0x7F, 0x25, 0x25, 0x25, 0x7F,
    0x90, 0x90, 0x90, 0x7F, 0x8F, 0x8F, 0x8F, 0x7F,    0x86, 0x86, 0x86, 0x7F, 0x83, 0x83, 0x83, 0x7F,
    0x80, 0x80, 0x80, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F,    0x78, 0x78, 0x78, 0x7F, 0x77, 0x77, 0x77, 0x7F,
    0x23, 0x23, 0x23, 0x7F, 0x20, 0x20, 0x20, 0x7F,    0x16, 0x16, 0x16, 0x7F, 0x15, 0x15, 0x15, 0x7F,
    0x10, 0x10, 0x10, 0x7F, 0x04, 0x04, 0x04, 0x7F,    0x02, 0x02, 0x02, 0x7F, 0x00, 0x00, 0x00, 0x7F,
};

//=========================================================================

struct ps2_startup_texture_packet
{
    u32         VIF[ 4 ];
    sceGifTag   GIFTag;
    u64         GSCmds[ 8 ];
    sceGifTag   GIFImage;
};

struct load_screen_data
{
    s32                             *DLists[ 2 ];
    u8                              *pDList;
    s32                             CurrentDList;
    sceDmaChan                      *pDMA;
    s32                             DMAHandler;
    xbool                           bHandlerOn;
    volatile xbool                  bTasksFinished;
    ps2_startup_texture_packet      Texture;
    ps2_startup_texture_packet      CLUT;
    ps2_screenfill_sprite_packet    Sprite[ 2 ];
};

static load_screen_data InitialLoadScreen;

//=========================================================================
static s32 s_ShiftW;
static s32 s_ShiftH;

static
void PS2_InitialLoadScreen_Setup( fsAABuff *Screen, load_screen_data &Data )
{
    sceGsResetGraph( 0, SCE_GS_INTERLACE, SCE_GS_NTSC, SCE_GS_FIELD );
    Setup_FSAA_buffer( Screen, 
                       640, 448, SCE_GS_PSMCT32, 
                       640, 448, SCE_GS_PSMCT32, 
                       SCE_GS_ZGEQUAL, SCE_GS_PSMZ16S, SCE_GS_CLEAR );

    s_fXConversion = 1.0f;//(f32)kDisplayWidth / 640.0f;
    s_fYConversion = 1.0f;//(f32)kDisplayHeight / 448.0f;

    x_bitmap *pTexture = (x_bitmap*)ps2_load_texture;
    s32 Width = pTexture->GetWidth();
    s32 shiftW = 5;
    if (Width == 64)
        shiftW = 6;
    else if (Width == 128)
        shiftW = 7;
    else if (Width == 256)
        shiftW = 8;
    s32 Height = pTexture->GetHeight();
    s32 shiftH = 5;
    if (Height == 64)
        shiftH = 6;
    else if (Height == 128)
        shiftH = 7;
    else if (Height == 256)
        shiftH = 8;
    s32 Format = VRAM_PS2_GetFormat( *pTexture );

    s_ShiftW = shiftW;
    s_ShiftH = shiftH;

    Data.Sprite[ 0 ].VIF[ 0 ] = Data.Sprite[ 1 ].VIF[ 0 ] = 0;
    Data.Sprite[ 0 ].VIF[ 1 ] = Data.Sprite[ 1 ].VIF[ 1 ] = 0;
    Data.Sprite[ 0 ].VIF[ 2 ] = Data.Sprite[ 1 ].VIF[ 2 ] = SCE_VIF1_SET_FLUSH( 0 );
    Data.Sprite[ 0 ].VIF[ 3 ] = Data.Sprite[ 1 ].VIF[ 3 ] = SCE_VIF1_SET_DIRECT( 28, 0 );
    VIFHELP_BuildGifTag1( &Data.Sprite[ 0 ].GIFTag, VIFHELP_GIFMODE_PACKED, 1, 27, FALSE, 0, 0, TRUE );
    VIFHELP_BuildGifTag2( &Data.Sprite[ 0 ].GIFTag, VIFHELP_GIFREG_AD, 0, 0, 0 );
    VIFHELP_BuildGifTag1( &Data.Sprite[ 1 ].GIFTag, VIFHELP_GIFMODE_PACKED, 1, 27, FALSE, 0, 0, TRUE );
    VIFHELP_BuildGifTag2( &Data.Sprite[ 1 ].GIFTag, VIFHELP_GIFREG_AD, 0, 0, 0 );
    Data.Sprite[ 0 ].GSCmds[ 0 ] = Data.Sprite[ 1 ].GSCmds[ 0 ] = 0;
    Data.Sprite[ 0 ].GSCmds[ 1 ] = Data.Sprite[ 1 ].GSCmds[ 1 ] = SCE_GS_TEXFLUSH;
    Data.Sprite[ 0 ].GSCmds[ 2 ] = Data.Sprite[ 1 ].GSCmds[ 2 ] = SCE_GS_SET_TEX1_1( 1, 0, 0, 0, 1, 0, 0 );
    Data.Sprite[ 0 ].GSCmds[ 3 ] = Data.Sprite[ 1 ].GSCmds[ 3 ] = SCE_GS_TEX1_1;
    // sorry for the hard-coded address - first texture goes to 13696
    Data.Sprite[ 0 ].GSCmds[ 4 ] = Data.Sprite[ 1 ].GSCmds[ 4 ] = SCE_GS_SET_TEX0_1( 13696, Width/64, Format, shiftW, shiftH, 1, 1, 13952, 0, 0, 0, 1 );
    Data.Sprite[ 0 ].GSCmds[ 5 ] = Data.Sprite[ 1 ].GSCmds[ 5 ] = SCE_GS_TEX0_1;
    Data.Sprite[ 0 ].GSCmds[ 6 ] = Data.Sprite[ 1 ].GSCmds[ 6 ] = SCE_GS_SET_CLAMP_1( 0, 0, 0, 0, 0, 0 );//( 1, 1, 0, 0, 0, 0 );
    Data.Sprite[ 0 ].GSCmds[ 7 ] = Data.Sprite[ 1 ].GSCmds[ 7 ] = SCE_GS_CLAMP_1;
    Data.Sprite[ 0 ].GSCmds[ 8 ] = Data.Sprite[ 1 ].GSCmds[ 8 ] = SCE_GS_SET_ALPHA_1( 0, 1, 0, 1, 0 );
    Data.Sprite[ 0 ].GSCmds[ 9 ] = Data.Sprite[ 1 ].GSCmds[ 9 ] = SCE_GS_ALPHA_1;
    s32 W = ENG_GetScreenWidth();
    s32 H = ENG_GetScreenHeight();
    Data.Sprite[ 0 ].GSCmds[ 10 ] = Data.Sprite[ 1 ].GSCmds[ 10 ] = SCE_GS_SET_FRAME_1( ((W*H)/2048), 10, Screen->drawLarge.frame1.PSM, 0 );
    Data.Sprite[ 0 ].GSCmds[ 11 ] = Data.Sprite[ 1 ].GSCmds[ 11 ] = SCE_GS_FRAME_1;
    Data.Sprite[ 0 ].GSCmds[ 12 ] = Data.Sprite[ 1 ].GSCmds[ 12 ] = SCE_GS_SET_PRIM( 6, 0, 1, 0, 0, 0, 1, 0, 0 );
    Data.Sprite[ 0 ].GSCmds[ 13 ] = Data.Sprite[ 1 ].GSCmds[ 13 ] = SCE_GS_PRIM;
    Data.Sprite[ 0 ].GSCmds[ 14 ] = Data.Sprite[ 1 ].GSCmds[ 14 ] = SCE_GS_SET_RGBAQ( 0x7F, 0x7F, 0x7F, 0x7F, 0x3F800000 );
    Data.Sprite[ 0 ].GSCmds[ 15 ] = Data.Sprite[ 1 ].GSCmds[ 15 ] = SCE_GS_RGBAQ;
    Data.Sprite[ 0 ].GSCmds[ 16 ] = Data.Sprite[ 1 ].GSCmds[ 16 ] = SCE_GS_SET_SCISSOR_1( 0, ENG_GetScreenWidth()-1, 0, ENG_GetScreenHeight()-1 );
    Data.Sprite[ 0 ].GSCmds[ 17 ] = Data.Sprite[ 1 ].GSCmds[ 17 ] = SCE_GS_SCISSOR_1;
    Data.Sprite[ 0 ].GSCmds[ 18 ] = Data.Sprite[ 1 ].GSCmds[ 18 ] = SCE_GS_SET_TEST_1( 0, 1, 0, 0, 0, 0, 1, 2 );
    Data.Sprite[ 0 ].GSCmds[ 19 ] = Data.Sprite[ 1 ].GSCmds[ 19 ] = SCE_GS_TEST_1;
    Data.Sprite[ 0 ].GSCmds[ 20 ] = Data.Sprite[ 1 ].GSCmds[ 20 ] = SCE_GS_SET_COLCLAMP( 1 );
    Data.Sprite[ 0 ].GSCmds[ 21 ] = Data.Sprite[ 1 ].GSCmds[ 21 ] = SCE_GS_COLCLAMP;

    s32 count = Width / 32;
    s32 index1 = 22;
    s32 index2 = 22;
    s32 UStep = 32<<4;
    s32 U0 = 0;
    s32 V0 = 0;
    s32 U1 = (UStep-1);
    s32 V1 = Height<<4;
    s32 XStep = 32<<4;
    s32 X0 = (2048+(Width>>1))<<4;
    s32 Y0 = (2048+(Height>>1))<<4;
    s32 X1 = X0 + (XStep-1);
    s32 Y1 = (2048+(Height<<1))<<4;
    s32 i;
    for (i=0; i<count; ++i)
    {
        Data.Sprite[ 0 ].GSCmds[ index1++ ] = Data.Sprite[ 1 ].GSCmds[ index2++ ] = SCE_GS_SET_UV( U0, V0 );
        Data.Sprite[ 0 ].GSCmds[ index1++ ] = Data.Sprite[ 1 ].GSCmds[ index2++ ] = SCE_GS_UV;
        Data.Sprite[ 0 ].GSCmds[ index1++ ] = Data.Sprite[ 1 ].GSCmds[ index2++ ] = SCE_GS_SET_XYZ2( X0, Y0, 10 );
        Data.Sprite[ 0 ].GSCmds[ index1++ ] = Data.Sprite[ 1 ].GSCmds[ index2++ ] = SCE_GS_XYZ2;
        Data.Sprite[ 0 ].GSCmds[ index1++ ] = Data.Sprite[ 1 ].GSCmds[ index2++ ] = SCE_GS_SET_UV( U1, V1 );
        Data.Sprite[ 0 ].GSCmds[ index1++ ] = Data.Sprite[ 1 ].GSCmds[ index2++ ] = SCE_GS_UV;
        Data.Sprite[ 0 ].GSCmds[ index1++ ] = Data.Sprite[ 1 ].GSCmds[ index2++ ] = SCE_GS_SET_XYZ2( X1, Y1, 10 );
        Data.Sprite[ 0 ].GSCmds[ index1++ ] = Data.Sprite[ 1 ].GSCmds[ index2++ ] = SCE_GS_XYZ2;
        U0 = U1 + 1;
        X0 = X1 + 1;
        U1 += UStep;
        X1 += XStep;
    }
}

static
void PS2_InitialLoadScreen_SendTexture( x_bitmap *pTexture, load_screen_data &Data )
{
    s32 Width = pTexture->GetWidth();
    s32 Height = pTexture->GetHeight();
    s32 BPP = pTexture->GetBPP();

    s32 ImageSize = pTexture->GetDataSize() >> 4;

    sceDmaTag *pTag = (sceDmaTag *)Data.pDList;
    Data.pDList += sizeof( sceDmaTag );
    DMAHELP_BuildTagRef( pTag, (u32)&Data.Texture, sizeof( ps2_startup_texture_packet ) );

    Data.Texture.VIF[ 0 ] = 0;
    Data.Texture.VIF[ 1 ] = 0;
    Data.Texture.VIF[ 2 ] = SCE_VIF1_SET_FLUSH( 0 );
    Data.Texture.VIF[ 3 ] = SCE_VIF1_SET_DIRECT( 6 + ImageSize, 0 );
    VIFHELP_BuildGifTag1( &Data.Texture.GIFTag, VIFHELP_GIFMODE_PACKED, 1, 4, FALSE, 0, 0, TRUE );
    VIFHELP_BuildGifTag2( &Data.Texture.GIFTag, VIFHELP_GIFREG_AD, 0, 0, 0 );
    s32 SwizzledW = ((Width * BPP) >> 4);
    s32 SwizzledH = ((Height * BPP) >> 4);
    s32 Format;
    if ( pTexture->IsDataSwizzled() && (Width >= 16) )
    {
        ASSERTS( BPP == 8, "No support for swizzled 4- and 16-bit images yet!" );
        SwizzledW = ((Width * BPP) >> 4);
        SwizzledH = ((Height * BPP) >> 4);
        Format = SCE_GS_PSMCT32;
    }
    else
    {
        SwizzledW = Width;
        SwizzledH = Height;
        Format = VRAM_PS2_GetFormat( *pTexture );
    }
    s32 sbw = MAX(1, (SwizzledW >> 6) );
    Data.Texture.GSCmds[ 0 ] = SCE_GS_SET_BITBLTBUF( 13696, sbw, Format, 13696, sbw, Format );
    Data.Texture.GSCmds[ 1 ] = SCE_GS_BITBLTBUF;
    Data.Texture.GSCmds[ 2 ] = SCE_GS_SET_TRXPOS( 0, 0, 0, 0, 0x00 );
    Data.Texture.GSCmds[ 3 ] = SCE_GS_TRXPOS;
    Data.Texture.GSCmds[ 4 ] = SCE_GS_SET_TRXREG( SwizzledW, SwizzledH );
    Data.Texture.GSCmds[ 5 ] = SCE_GS_TRXREG;
    Data.Texture.GSCmds[ 6 ] = SCE_GS_SET_TRXDIR( 0x00 );
    Data.Texture.GSCmds[ 7 ] = SCE_GS_TRXDIR;
    VIFHELP_BuildGifTag1( &Data.Texture.GIFImage, VIFHELP_GIFMODE_IMAGE, 0, ImageSize, FALSE, 0, 0, TRUE );

    pTag = (sceDmaTag *)Data.pDList;
    Data.pDList += sizeof( sceDmaTag );
    DMAHELP_BuildTagRef( pTag, NULL, 16 );
    pTag->qwc = ImageSize;
    pTag->next = (sceDmaTag *)pTexture->GetDataPtr();



    pTag = (sceDmaTag *)Data.pDList;
    Data.pDList += sizeof( sceDmaTag );
    DMAHELP_BuildTagRef( pTag, (u32)&Data.CLUT, sizeof( ps2_startup_texture_packet ) );

    s32 ClutSize = 64;
    Data.CLUT.VIF[ 0 ] = 0;
    Data.CLUT.VIF[ 1 ] = 0;
    Data.CLUT.VIF[ 2 ] = SCE_VIF1_SET_FLUSH( 0 );
    Data.CLUT.VIF[ 3 ] = SCE_VIF1_SET_DIRECT( 6 + ClutSize, 0 );
    VIFHELP_BuildGifTag1( &Data.CLUT.GIFTag, VIFHELP_GIFMODE_PACKED, 1, 4, FALSE, 0, 0, TRUE );
    VIFHELP_BuildGifTag2( &Data.CLUT.GIFTag, VIFHELP_GIFREG_AD, 0, 0, 0 );
    Data.CLUT.GSCmds[ 0 ] = SCE_GS_SET_BITBLTBUF( 0, 0, 0, 13952, 1, SCE_GS_PSMCT32 );
    Data.CLUT.GSCmds[ 1 ] = SCE_GS_BITBLTBUF;
    Data.CLUT.GSCmds[ 2 ] = SCE_GS_SET_TRXPOS( 0, 0, 0, 0, 0x00 );
    Data.CLUT.GSCmds[ 3 ] = SCE_GS_TRXPOS;
    Data.CLUT.GSCmds[ 4 ] = SCE_GS_SET_TRXREG( 16, 16 );
    Data.CLUT.GSCmds[ 5 ] = SCE_GS_TRXREG;
    Data.CLUT.GSCmds[ 6 ] = SCE_GS_SET_TRXDIR( 0x00 );
    Data.CLUT.GSCmds[ 7 ] = SCE_GS_TRXDIR;
    VIFHELP_BuildGifTag1( &Data.CLUT.GIFImage, VIFHELP_GIFMODE_IMAGE, 0, ClutSize, FALSE, 0, 0, TRUE );

    pTag = (sceDmaTag *)Data.pDList;
    Data.pDList += sizeof( sceDmaTag );
    DMAHELP_BuildTagRef( pTag, NULL, 16 );
    pTag->qwc = ClutSize;
    pTag->next = (sceDmaTag *)pTexture->GetClutPtr();
}

//=========================================================================

s32 s_OffsetX = 25;
s32 s_OffsetY = 0;
xbool s_bFinished = FALSE;
s32 s_Format = 0x13;
s32 s_TFX = 1;
s32 s_R = 0x2f;
s32 s_G = 0x2f;
s32 s_B = 0x2f;
s32 s_A = 0x7f;
static
void PS2_InitialLoadScreen_UpdateSprite( load_screen_data &Data  )
{
    // if you want to mess with any of the sprite settings, do it here.
    // to modify the color output mask, change [ 10 ]
    // to modify the alpha blend, change [ 8 ]
    // to modify the positions, loop starting at [ 18 ] and step by 4
    // to modify the uvs, loop starting at [ 16 ] and step by 4
    // to modify the actual primitive color, change [ 14 ]

    s32 Width = 128;
    Data.Sprite[ 0 ].GSCmds[ 4 ] = SCE_GS_SET_TEX0_1( 13696, Width/64, s_Format, s_ShiftW, s_ShiftH, 1, s_TFX, 13952, 0, 0, 0, 1 );
    Data.Sprite[ 0 ].GSCmds[ 14 ] = SCE_GS_SET_RGBAQ( s_R, s_G, s_B, s_A, 0x3F800000 );
    s32 Height = 128;
    s32 count = Width / 32;
    s32 index1 = 22;
    s32 XStep = 32<<4;
    s32 X0 = ((2048+(Width>>1) + s_OffsetX)<<4)+8;
    s32 Y0 = ((2048+(Height>>1) + s_OffsetY)<<4)+8;
    s32 X1 = X0 + (XStep-1);
    s32 Y1 = Y0 + (Height<<4);
    s32 i;
    for (i=0; i<count; ++i)
    {
        index1+=2;
        Data.Sprite[ 0 ].GSCmds[ index1++ ] = SCE_GS_SET_XYZ2( X0, Y0, 10 );
        Data.Sprite[ 0 ].GSCmds[ index1++ ] = SCE_GS_XYZ2;
        index1+=2;
        Data.Sprite[ 0 ].GSCmds[ index1++ ] = SCE_GS_SET_XYZ2( X1, Y1, 10 );
        Data.Sprite[ 0 ].GSCmds[ index1++ ] = SCE_GS_XYZ2;
        X0 = X1 + 1;
        X1 += XStep;
    }
}

//=========================================================================

static 
void PS2_InitialLoadScreen_DrawSprite( load_screen_data &Data )
{
    sceDmaTag *pTag = (sceDmaTag *)Data.pDList;
    Data.pDList += sizeof( sceDmaTag );

    DMAHELP_BuildTagRef( pTag, (u32)&Data.Sprite[ 0 ], sizeof( ps2_screenfill_sprite_packet ) );
}

//=========================================================================

static 
void PS2_InitialLoadScreen_WipeDisplay( load_screen_data &Data )
{
    sceDmaTag *pTag = (sceDmaTag *)Data.pDList;
    Data.pDList += sizeof( sceDmaTag );

    Data.Sprite[ 1 ].GSCmds[ 10 ] = SCE_GS_SET_FRAME_1( 0, 10, aaBuff.drawSmall.frame1.PSM, 0 );
    Data.Sprite[ 1 ].GSCmds[ 12 ] = SCE_GS_SET_PRIM( 6, 0, 1, 0, 0, 0, 1, 0, 0 );
    Data.Sprite[ 1 ].GSCmds[ 14 ] = SCE_GS_SET_RGBAQ( 255, 0, 0, 0x3F, 0x3F800000 );

    s32 count = 4;
    s32 Width = ENG_GetScreenWidth();
    s32 Height = ENG_GetScreenHeight();
    s32 index2 = 22;
    s32 XStep = (Width/count)<<4;
    s32 X0 = (2048-(Width>>1))<<4;
    s32 Y0 = (2048-(Height>>1))<<4;
    s32 X1 = X0 + (XStep-1);
    s32 Y1 = (2048+(Height>>1))<<4;
    s32 i;
    for (i=0; i<count; ++i)
    {
        Data.Sprite[ 1 ].GSCmds[ index2++ ] = SCE_GS_SET_UV( 0, 0 );
        Data.Sprite[ 1 ].GSCmds[ index2++ ] = SCE_GS_UV;
        Data.Sprite[ 1 ].GSCmds[ index2++ ] = SCE_GS_SET_XYZ2( X0, Y0, 10 );
        Data.Sprite[ 1 ].GSCmds[ index2++ ] = SCE_GS_XYZ2;
        Data.Sprite[ 1 ].GSCmds[ index2++ ] = SCE_GS_SET_UV( 0, 0 );
        Data.Sprite[ 1 ].GSCmds[ index2++ ] = SCE_GS_UV;
        Data.Sprite[ 1 ].GSCmds[ index2++ ] = SCE_GS_SET_XYZ2( X1, Y1, 10 );
        Data.Sprite[ 1 ].GSCmds[ index2++ ] = SCE_GS_XYZ2;
        X0 = X1 + 1;
        X1 += XStep;
    }
    DMAHELP_BuildTagRef( pTag, (u32)&Data.Sprite[ 1 ], sizeof( ps2_screenfill_sprite_packet ) );
}

//=========================================================================

static
void PS2_InitialLoadScreen_PageFlip( fsAABuff &Screen, load_screen_data &Data )
{
    static xbool bFirst = TRUE;
    static u32 OddFrame = 0;
    // end the "current" DList
    DMAHELP_BuildTagEnd( (sceDmaTag *)Data.pDList, 0 );
    Data.pDList += sizeof( sceDmaTag );

    if (bFirst)
    {
        bFirst = FALSE;
        FlushCache(WRITEBACK_DCACHE);
        // "current" DList gets "sent"
        // Let path3 be intermittent    
        {
            // continuous = 0
            // intermittent = 4
            (*GIF_MODE) |= 0x04;
        }
        // Setup DMA
        Data.pDMA->chcr.TTE = 0;
	    Data.pDMA->chcr.TIE = 1;
        u32 C = *D_STAT;
        if( ((C>>(16+1))&0x01) == 0 )
            *D_STAT = (u32)((1<<(16+1)) | (1<<(1)));
        // Kick off DMA
        u32 vcnt = 0;
        while(DGET_D2_CHCR() & 0x0100)
        {
            if((vcnt++)>0x1000000)
            {
                x_printf("Error starting DMA: DMA does not terminate %d\r\n%s\n", __LINE__, __FILE__ );
            }
        }

        sceDmaSend( Data.pDMA, (void*)((u32)Data.DLists[ Data.CurrentDList ] & 0x8fffffff) );
        Data.CurrentDList = !Data.CurrentDList;
    }

    while (!Data.bTasksFinished)
    {
//        if (!Data.pDMA->chcr.STR)
//            Data.bTasksFinished = TRUE;
    }

    Data.bHandlerOn = FALSE;
    Data.bTasksFinished = FALSE;

    // copy the DRAW buffer to the DISPLAY buffer
    SetDownSampleSpriteToDisplay( &Screen, pShrinkSprite, TRUE );
    OddFrame = sceGsSyncV(0)^0x01;
    PutDrawBufferSmall( &Screen );
    PutDownSampleSprite( &pShrinkSprite->GIFtag );
    sceGsSyncPath(0,0);
    PutDispBuffer( &Screen, !OddFrame );
    PutDrawBufferLarge( &Screen );
    sceGsSyncPath(0,0);

    Data.bHandlerOn = TRUE;

    // "current" DList gets "sent"
    // Let path3 be intermittent    
    {
        // continuous = 0
        // intermittent = 4
        (*GIF_MODE) |= 0x04;
    }
    // Setup DMA
    Data.pDMA->chcr.TTE = 0;
	Data.pDMA->chcr.TIE = 1;
    u32 C = *D_STAT;
    if( ((C>>(16+1))&0x01) == 0 )
        *D_STAT = (u32)((1<<(16+1)) | (1<<(1)));
    // Kick off DMA
    u32 vcnt = 0;
    while(DGET_D2_CHCR() & 0x0100)
    {
        if((vcnt++)>0x1000000)
        {
            x_printf("Error starting DMA: DMA does not terminate %d\r\n%s\n", __LINE__, __FILE__ );
        }
    }

    sceDmaSend( Data.pDMA, (void*)((u32)Data.DLists[ Data.CurrentDList ] & 0x8fffffff) );
    InitialLoadScreen.CurrentDList = !InitialLoadScreen.CurrentDList;

}

//=========================================================================

// I feel like a rat bastard for doing this, but hey.
class x_bitmap_cheat : public x_bitmap
{
public:
    void SetDataPtr( byte *ptr );
    void SetClutPtr( byte *ptr );
};

//=========================================================================

void x_bitmap_cheat::SetDataPtr( byte *ptr )
{
    m_pData = ptr;
}

//=========================================================================

void x_bitmap_cheat::SetClutPtr( byte *ptr )
{
    m_pClut = ptr;
}

//=========================================================================

static 
int InitialClearScreenInterruptHandler( int ca )
{
    if (!InitialLoadScreen.bHandlerOn)
        return 1;

    InitialLoadScreen.bTasksFinished = TRUE;
    // Let path3 be intermittent    
    {
        // continuous = 0
        // intermittent = 4
        (*GIF_MODE) |= 0x04;
    }
    // Setup DMA
    InitialLoadScreen.pDMA->chcr.TTE = 0;
	InitialLoadScreen.pDMA->chcr.TIE = 1;
    u32 C = *D_STAT;
    if( ((C>>(16+1))&0x01) == 0 )
        *D_STAT = (u32)((1<<(16+1)) | (1<<(1)));
    // Kick off DMA
    u32 vcnt = 0;
    while(DGET_D2_CHCR() & 0x0100)
    {
        if((vcnt++)>0x1000000)
        {
            x_printf("Error starting DMA: DMA does not terminate %d\r\n%s\n", __LINE__, __FILE__ );
        }
    }

    sceDmaSend( InitialLoadScreen.pDMA, (void*)((u32)InitialLoadScreen.DLists[ InitialLoadScreen.CurrentDList ] & 0x8fffffff) );

    InitialLoadScreen.CurrentDList = !InitialLoadScreen.CurrentDList;
    InitialLoadScreen.pDList = (u8*)InitialLoadScreen.DLists[ InitialLoadScreen.CurrentDList ];

    return 1;
}

//=========================================================================

void PS2_InitialLoadScreen_Init( void )
{
    sceDmaEnv denv;
    sceDmaReset(1);
    sceDmaGetEnv(&denv);
    denv.notify = 0x0100; // enable Ch.8 CPCOND 
    sceDmaPutEnv(&denv);
    sceGsResetPath();
    InitialLoadScreen.bTasksFinished = TRUE;
    InitialLoadScreen.bHandlerOn = TRUE;
    InitialLoadScreen.pDMA = sceDmaGetChan(SCE_DMA_VIF1);
    InitialLoadScreen.DMAHandler = AddDmacHandler( DMAC_VIF1, InitialClearScreenInterruptHandler, 0 );
    EnableDmac( DMAC_VIF1 );
    FlushCache( WRITEBACK_DCACHE );

    // Setup graphics environment
    sceGsResetPath();
    sceDmaReset(1);

    x_bitmap *pTexture = (x_bitmap *)ps2_load_texture;
    // cheat the data ptr
    ((x_bitmap_cheat*)pTexture)->SetDataPtr( (byte*)(ps2_load_texture + sizeof(x_bitmap)) );
    ((x_bitmap_cheat*)pTexture)->SetClutPtr( (byte*)(pTexture->GetDataPtr() + pTexture->GetDataSize()) );

    s32 HowBig = 1 * 1024; // 1K?
    // we can't use SMEM yet, so we need to do this by HAND...
    InitialLoadScreen.DLists[ 0 ] = new s32[ HowBig ];
    InitialLoadScreen.DLists[ 1 ] = new s32[ HowBig ];

    x_memset( InitialLoadScreen.DLists[ 0 ], 0, sizeof( s32 ) * HowBig );
    x_memset( InitialLoadScreen.DLists[ 1 ], 0, sizeof( s32 ) * HowBig );

    InitialLoadScreen.pDList = (u8 *)InitialLoadScreen.DLists[ 0 ];
    InitialLoadScreen.CurrentDList = 0;

    pShrinkSprite = (gsDrawDecalSprite*) (((u32)(&shrinkSprite)) | 0x20000000);

    s_XRes = kDisplayWidth;
    s_YRes = kDisplayHeight;
    pAAbuff = (fsAABuff*) (((u32)(&aaBuff)) | 0x20000000);
    PS2_InitialLoadScreen_Setup( pAAbuff, InitialLoadScreen );

    FlushCache(0);
    while(sceGsSyncV(0) == 0);  

    PS2_InitialLoadScreen_SendTexture( pTexture, InitialLoadScreen );
    PS2_InitialLoadScreen_WipeDisplay( InitialLoadScreen );

    {
        // If possible, wrap this into a separate thread.
        PS2_InitialLoadScreen_Pump();
        PS2_InitialLoadScreen_Pump();
    }

}

void PS2_InitialLoadScreen_Pump( void )
{
    PS2_InitialLoadScreen_UpdateSprite( InitialLoadScreen );
    PS2_InitialLoadScreen_DrawSprite( InitialLoadScreen );
    PS2_InitialLoadScreen_PageFlip( *pAAbuff, InitialLoadScreen );
}

//=========================================================================

void PS2_InitialLoadScreen_Kill( void )
{
    InitialLoadScreen.bHandlerOn = FALSE;
    if (InitialLoadScreen.DLists[ 0 ])
        delete [] InitialLoadScreen.DLists[ 0 ];
    InitialLoadScreen.DLists[ 0 ] = NULL;
    if (InitialLoadScreen.DLists[ 1 ])
        delete [] InitialLoadScreen.DLists[ 1 ];
    InitialLoadScreen.DLists[ 1 ] = NULL;

    DisableDmac( DMAC_VIF1 );
    RemoveDmacHandler( DMAC_VIF1, InitialLoadScreen.DMAHandler );
}

//=========================================================================

inline
s32 ENG_GetScreenWidth( void )
{
    return s_XRes;
}

//=========================================================================

inline
s32 ENG_GetScreenHeight( void )
{
    return s_YRes;
}

//=========================================================================

f32 PS2_GetScreenXConversionMultiplier( void )
{
    if (s_bScreenConversionOverride)
        return 1.0f;
    return s_fXConversion;
}

//=========================================================================

f32 PS2_GetScreenYConversionMultiplier( void )
{
    if (s_bScreenConversionOverride)
        return 1.0f;
    return s_fYConversion;
}

void PS2_SetFrameBufferSizeOverride( xbool bSet )
{
    s_bScreenConversionOverride = bSet;
}

//=========================================================================
void PS2_InitGraphicsCheat( s32 iIndex )
{
    (void)iIndex;
    s_bGraphicsCheatActive = TRUE;
//    s_bGraphicsCheatActive = FALSE;
}

//=========================================================================
void PS2_KillGraphicsCheat( s32 iIndex )
{
    (void)iIndex;
    s_bGraphicsCheatActive = FALSE;
}

//=========================================================================
xbool PS2_IsGraphicsCheatActive( s32 iIndex )
{
    (void)iIndex;
    return s_bGraphicsCheatActive;
}


void PS2_ConvertBackCoordToFrontCoord( f32 &DstX, f32 &DstY, f32 SrcX, f32 SrcY )
{
    f32 fBackToFrontX = 640.0f / (f32)aaBuff.drawW;
    f32 fBackToFrontY = 448.0f / (f32)aaBuff.drawH;
    DstX = SrcX * fBackToFrontX;
    DstY = SrcY * fBackToFrontY;
}

//=========================================================================
//=========================================================================
